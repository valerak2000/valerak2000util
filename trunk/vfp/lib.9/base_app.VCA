SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1251

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0IM287
[CLASS] base_form
[CLASSLOC] base_gui.vcx
[BASECLASS] form
[OBJNAME] _calendar
[START PROPERTIES]
AlwaysOnTop = .T.
BackColor = 255,255,255
BorderStyle = 2
Caption = "Календарь"
DoCreate = .T.
Height = 457
Icon = ..\bmp\calendar.ico
Left = 0
Name = "_calendar"
Picture = ..\bmp\calendar.gif
TitleBar = 0
Top = 0
Width = 725
ncalendar = 0
saveset.Name = "saveset"
[END PROPERTIES]
[START METHODS]
PROCEDURE Activate
THIS.cntTitleband.lEnabled=.T.
DODEFAULT()
ENDPROC
PROCEDURE Deactivate
THIS.cntTitleband.lEnabled=.F.
DODEFAULT()
ENDPROC
PROCEDURE Init
LPARAMETERS toForm AS Object, tcAlias AS String, tnIdRecord AS Integer
LOCAL loButton AS Object
	* ПОДНАСТРОИМ ИНОРОДНОЕ ТЕЛО
	WITH THIS.oleCalendar
		* СТАРТОВАЯ ДАТА (ВЫДЕЛЕНА СЕРЫМ ЦВЕТОМ)
		.Object.Value=DATE()
		* ОТСТУП СВЕРХУ
		.Top=THIS.cntTitleBand.Height
	ENDWITH
	* ВОССТАНОВИМ ПОЛЬЗОВАТЕЛЬСКУЮ НАСТРОЙКУ ВИДА КАЛЕНДАРЯ
	THIS.nCalendar=3
	loButton=GETPEM(THIS.cntTitleband, "cmd"+TRANSFORM(THIS.nCalendar))
	m.loButton.Click()

	DODEFAULT()
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
3[END RESERVED2]
[START RESERVED3]
ncalendar
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\calendar.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\calendar.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0KD7KR
[CLASS] cnttitleband
[CLASSLOC] base_gui.vcx
[BASECLASS] container
[OBJNAME] cntTitleband
[PARENT] _calendar
[START PROPERTIES]
Height = 18
ImageGradient.Name = "ImageGradient"
LBLTITLE.Caption = " Календарь"
LBLTITLE.Name = "LBLTITLE"
Name = "cntTitleband"
chkOnTop.Alignment = 0
chkOnTop.Name = "chkOnTop"
cmd1.Caption = "1"
cmd1.Name = "cmd1"
cmd1.ToolTipText = "Месяц"
cmd2.Caption = "3"
cmd2.Name = "cmd2"
cmd2.ToolTipText = "Квартал"
cmd3.Caption = "6"
cmd3.Name = "cmd3"
cmd3.ToolTipText = "Полгода"
cmdClose.Name = "cmdClose"
[END PROPERTIES]
[START METHODS]
PROCEDURE cmd1.Click
THISFORM.LockScreen=.T.

WITH THISFORM
	IF THIS.VisualEffect=0
		THIS.VisualEffect=2

		.oleCalendar.MonthColumns=1
		.oleCalendar.MonthRows=1
		.oleCalendar.Left=0
		.Height=172
		.Width=161
		.nCalendar=1
	ELSE
		THIS.VisualEffect=0
		.oleCalendar.MonthColumns=4
		.oleCalendar.MonthRows=3
		.oleCalendar.Left=.nLeftIndent
		.Height=457
		.Width=662+.nLeftIndent
		.nCalendar=0
	ENDIF
ENDWITH

WITH THIS.Parent
	.Width=THISFORM.Width
	.cmd2.VisualEffect=0
	.cmd3.VisualEffect=0
ENDWITH

THISFORM.LockScreen=.F.
ENDPROC
PROCEDURE cmd2.Click
THISFORM.LockScreen=.T.

WITH THISFORM
	IF THIS.VisualEffect=0
		THIS.VisualEffect=2
		.oleCalendar.MonthColumns=3
		.oleCalendar.MonthRows=1
		.oleCalendar.Left=0
		.Height=172
		.Width=495
		.nCalendar=2
	ELSE
		THIS.VisualEffect=0
		.oleCalendar.MonthColumns=4
		.oleCalendar.MonthRows=3
		.oleCalendar.Left=.nLeftIndent
		.Height=457
		.Width=662+.nLeftIndent
		.nCalendar=0
	ENDIF
ENDWITH

WITH THIS.Parent
	.Width=THISFORM.Width
	.cmd2.VisualEffect=0
	.cmd3.VisualEffect=0
ENDWITH

THISFORM.LockScreen=.F.
ENDPROC
PROCEDURE cmd3.Click
THISFORM.LockScreen=.T.

WITH THISFORM
	IF THIS.VisualEffect=0
		THIS.VisualEffect=2
		.oleCalendar.MonthColumns=3
		.oleCalendar.MonthRows=2
		.oleCalendar.Left=0
		.Height=315
		.Width=495
		.nCalendar=3
	ELSE
		THIS.VisualEffect=0
		.oleCalendar.MonthColumns=4
		.oleCalendar.MonthRows=3
		.oleCalendar.Left=.nLeftIndent
		.Height=457
		.Width=662+.nLeftIndent
		.nCalendar=0
	ENDIF
ENDWITH

WITH THIS.Parent
	.Width=THISFORM.Width
	.cmd2.VisualEffect=0
	.cmd3.VisualEffect=0
ENDWITH

THISFORM.LockScreen=.F.
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0IVNKR
[CLASS] olecalendar
[CLASSLOC] base_gui.vcx
[BASECLASS] olecontrol
[OBJNAME] Olecalendar
[PARENT] _calendar
[START PROPERTIES]
Height = 457
Left = 63
Name = "Olecalendar"
Top = 19
Width = 662
[END PROPERTIES]
[START METHODS]
PROCEDURE KeyPress
*** ActiveX Control Event ***
LPARAMETERS tnKeyCode
	IF m.tnKeyCode=27
		KEYBOARD '{ESC}'
	ENDIF
ENDPROC
[END METHODS]
[BINSTART OLE]
CHECKSUM=59953
[BINEND OLE]
[BINSTART OLE2]
CHECKSUM=5725
[BINEND OLE2]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] _calendar
[START PROPERTIES]
MS Sans Serif, 0, 8, 5, 13, 11, 11, 2, 0
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0ARL59
[CLASS] base_form
[CLASSLOC] base_gui.vcx
[BASECLASS] form
[OBJNAME] _clock
[START PROPERTIES]
AlwaysOnTop = .T.
BorderStyle = 0
Caption = "Часы"
Comment = "Design 640x480=632x295 800x600=792x415 1024x768=1016x583 Размеры этой формы 630х288 и кратны 9"
DoCreate = .T.
Height = 144
Left = 0
Name = "_clock"
TitleBar = 0
Top = 0
Width = 144
dbcontainer.Name = "dbcontainer"
ohour = 
ominute = 
osecond = 
saveset_form.Name = "saveset_form"
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
LOCAL lnDiameter AS Integer, lnRegionHandle AS Integer
	DODEFAULT()
	* ДИАМЕТЕР КРУГА
	lnDiameter=MIN(THIS.Width, THIS.Height)
	* ОПРЕДЕЛИМ ХЭНДЛ КРУГОВОЙ ОБЛАСТИ НА ФОРМЕ
	lnRegionHandle=m.goApp.oWinAPI.CreateEllipticRgn(0, 0, m.lnDiameter, m.lnDiameter)
	* ПОПЫТАЕМСЯ ОГРАНИЧИТЬ ОБЛАСТЬ ВЫВОДА КРУГОМ
	IF m.lnRegionHandle<>0
		m.goApp.oWinAPI.SetWindowRgn(THIS.HWnd, m.lnRegionHandle)
	ENDIF
ENDPROC
PROCEDURE addhmsobject
* КОРЕНЬ В НАЗВАНИИ ОБЪЕКТА-СТРЕЛКИ, РАДИУС СТРЕЛКИ, ТОЛЩИНА СТРЕЛКИ, ЦВЕТ СТРЕЛКИ
* .AddHMSObject('SEC', lnRadius, 1, COLOR_RED)
LPARAMETERS tcRoot AS String, tnRadius AS Integer, tnWidth AS Integer, tnColor AS Integer
LOCAL lnCount AS Integer, lnSinus AS Integer, lnCosinus AS Integer, lcName AS String, loLine AS Object
	lnLeft=THIS.cntClock.Width/2
	lnTop=THIS.cntClock.Height/2

	FOR lnCount=0 TO 59
		lnSinus=m.tnRadius*SIN(DTOR(6*m.lnCount))
		lnCosinus=m.tnRadius*COS(DTOR(6*m.lnCount))
		lcName="lin"+m.tcRoot+TRANSFORM(m.lnCount, "@L 99")

		THIS.cntClock.AddObject(m.lcName, 'Line')
		loLine=GETPEM(THIS.cntClock, m.lcName)

		WITH m.loLine AS Line
			.BorderWidth=m.tnWidth
			.BorderColor=m.tnColor

			DO CASE
			CASE BETWEEN(m.lnCount, 0, 14)
				.LineSlant	= '/'
				.Left		= m.lnLeft
				.Top		= m.lnTop-m.lnCosinus
				.Width		= m.lnSinus
				.Height		= m.lnCosinus
			CASE BETWEEN(m.lnCount, 15, 29)
				.LineSlant	= '\'
				.Left		= m.lnLeft
				.Top		= m.lnTop
				.Width		= m.lnSinus
				.Height		= -m.lnCosinus
			CASE BETWEEN(m.lnCount, 30, 44)
				.LineSlant	= '/'
				.Left		= m.lnLeft+m.lnSinus
				.Top		= m.lnTop
				.Width		= -m.lnSinus
				.Height		= -m.lnCosinus
			CASE BETWEEN(m.lnCount, 45, 59)
				.LineSlant	= '\'
				.Left		= m.lnLeft+m.lnSinus
				.Top		= m.lnTop-m.lnCosinus
				.Width		= -m.lnSinus
				.Height		= m.lnCosinus
			ENDCASE
		ENDWITH
	ENDFOR
ENDPROC
PROCEDURE showtime
LPARAMETERS tlFirstExecute AS Logical
LOCAL lnHour AS Integer, loHour AS Object, loMinute AS Object, loSecond AS Object
	* ВЫЧИСЛИМ ССЫЛКИ НА НОВЫЕ ОБЪЕКТЫ
	lnHour=SECONDS()/60/60
	lnHour=IIF(m.lnHour>12, m.lnHour-12, m.lnHour)
	lnHour=FLOOR(5*m.lnHour)	&& 0-59
	loHour=GETPEM(THIS.cntClock, "linHOUR"+TRANSFORM(m.lnHour, "@L 99"))
	loMinute=GETPEM(THIS.cntClock, "linMIN"+SUBSTR(TIME(), 4, 2))
	loSecond=GETPEM(THIS.cntClock, "linSEC"+RIGHT(TIME(), 2))
	* СКРОЕМ СТАРЫЕ И ПОКАЖЕМ НОВЫЕ ОБЪЕКТЫ
	WITH THIS
		IF m.tlFirstExecute
			.oHour=m.loHour
			.oMinute=m.loMinute

			STORE .T. TO loHour.Visible, loMinute.Visible
		ELSE
			IF .oHour<>m.loHour
				.oHour.Visible=.F.
				.oHour=m.loHour
				.oHour.Visible=.T.
			ENDIF

			IF .oMinute<>m.loMinute
				.oMinute.Visible=.F.
				.oMinute=m.loMinute
				.oMinute.Visible=.T.
			ENDIF

			.oSecond.Visible=.F.
		ENDIF

		.oSecond=m.loSecond
		.oSecond.Visible=.T.
	ENDWITH
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
6[END RESERVED2]
[START RESERVED3]
*addhmsobject 
*showtime 
ohour
ominute
osecond
[END RESERVED3]
[START RESERVED4]
..\bmp\clock.ico[END RESERVED4]
[START RESERVED5]
..\bmp\clock.ico[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0GYLNY
[CLASS] commonbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdClose
[PARENT] _clock
[START PROPERTIES]
Anchor = 0
Caption = ""
Height = 18
Left = 63
Name = "cmdClose"
Picture = ..\bmp\release.bmp
Top = 63
Width = 18
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
THISFORM.Release()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0G4W7V
[CLASS] base_container
[CLASSLOC] base_gui.vcx
[BASECLASS] container
[OBJNAME] cntClock
[PARENT] _clock
[START PROPERTIES]
Anchor = 768
BackStyle = 0
Height = 144
Left = 0
Name = "cntClock"
Top = 0
Width = 144
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
LOCAL lnRadius as Integer
	DODEFAULT()

	WITH THIS
		* УБЕРЕМ РАМКУ РЕСАЙЗИНГА
		.BorderWidth=0
		* ОТМАСШТАБИРУЕМ КАРТИНКУ
		WITH .imgClock
			.Width=THIS.Width
			.Height=THIS.Height
			.Anchor=1+2+4+8
		ENDWITH
		* МАКСИМАЛЬНЫЙ РАДИУС СЕКУНДНОЙ СТРЕЛКИ
		lnRadius=MIN(.Height/2, .Width/2)
		* КОРЕНЬ В НАЗВАНИИ, РАДИУС, ТОЛЩИНА, ЦВЕТ
		THISFORM.AddHMSObject("HOUR", 0.5*m.lnRadius, 3, COLOR_BLACK)
		THISFORM.AddHMSObject("MIN", 0.7*m.lnRadius, 2, COLOR_BLACK)
		THISFORM.AddHMSObject("SEC", 0.8*m.lnRadius, 1, COLOR_YELLOW)
		* ПОКАЖЕМ СТРЕЛКИ
		THISFORM.ShowTime(.T.)
		* ЗАПУСТИМ ТАЙМЕР
		.tmrClock.Enabled=.T.
	ENDWITH
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0GO6N0
[CLASS] base_image
[CLASSLOC] base_gui.vcx
[BASECLASS] image
[OBJNAME] ImgClock
[PARENT] _clock.cntClock
[START PROPERTIES]
Height = 81
Left = 0
Name = "ImgClock"
Picture = ..\bmp\clock.gif
Stretch = 2
Top = 0
Width = 81
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0GQMXF
[CLASS] base_timer
[CLASSLOC] base_gui.vcx
[BASECLASS] timer
[OBJNAME] tmrClock
[PARENT] _clock.cntClock
[START PROPERTIES]
Interval = 1000
Left = 72
Name = "tmrClock"
Top = 108
[END PROPERTIES]
[START METHODS]
PROCEDURE Timer
* ПЕРЕДВИНЕМ СТРЕЛКИ
THISFORM.ShowTime()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0GT3GF
[CLASS] base_shape
[CLASSLOC] base_gui.vcx
[BASECLASS] shape
[OBJNAME] shpClock
[PARENT] _clock
[START PROPERTIES]
BackStyle = 0
BorderStyle = 0
Height = 144
Name = "shpClock"
SpecialEffect = 0
Width = 144
[END PROPERTIES]
[START METHODS]
PROCEDURE MouseDown
* ОРГАНИЗУЕМ ПЕРЕТАСКИВАНИЕ ФОРМЫ
LPARAMETERS tnButton, tnShift, tnXCoord, tnYCoord
	DO CASE
	CASE m.tnButton=1	&& Left Button
		m.goApp.oWinApi.ReleaseCapture()
		m.goApp.oWinApi.SendMessage(THISFORM.HWnd, WM_SYSCOMMAND, SC_MOVE+HTCAPTION, 0)

		NODEFAULT
	OTHERWISE
		DODEFAULT(m.tnButton, m.tnShift, m.tnXCoord, m.tnYCoord)
	ENDCASE
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] _clock
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RY07WLOI
[CLASS] base_form_szgr
[CLASSLOC] base_gui.vcx
[BASECLASS] form
[OBJNAME] _messages
[START PROPERTIES]

Caption = "Список сообщений"
DoCreate = .T.
Dockable = 1
HalfHeightCaption = .T.
Height = 250
Icon = ..\bmp\user_headset.ico
Left = 0
MinHeight = 60
Name = "_messages"
ShowWindow = 0
Top = 0
Width = 375
_memberdata =      221<VFPData><memberdata name="msgtxt" type="property" display="MsgTxt"/><memberdata name="msgtxt_assign" type="method" display="MsgTxt_Assign"/><memberdata name="clearmsgtxt" type="method" display="ClearMsgTxt"/></VFPData>
dbcontainer.Enabled = .F.
dbcontainer.Name = "dbcontainer"
msgtxt =  
resizecorner.Image.Height = 16
resizecorner.Image.Name = "Image"
resizecorner.Image.Width = 16
resizecorner.Name = "resizecorner"
resizecorner.resize_timer.Name = "resize_timer"
resizecorner.tmrRefresh.Name = "tmrRefresh"
saveset_form.Name = "saveset_form"
[END PROPERTIES]
[START METHODS]
PROCEDURE AfterDock
THIS.BorderStyle = 2
ENDPROC
PROCEDURE Init
DODEFAULT()

THIS.MsgTxt = ''
THIS.Dock(3)
ENDPROC
PROCEDURE UnDock
THIS.BorderStyle = 3
ENDPROC
PROCEDURE clearmsgtxt
THIS.editboxMsg.Value = ''
THIS.editboxMsg.Refresh()
ENDPROC
PROCEDURE msgtxt_assign
LPARAMETERS tcNewVal
*To do: Modify this routine for the Assign method
	WITH THIS
		IF !EMPTY(m.tcNewVal)
			.editboxMsg.Value = .editboxMsg.Value + m.tcNewVal + CRLF
		ENDIF
		*встать на последний символ
		.editboxMsg.SelStart = LENC(.editboxMsg.Value)
		.editboxMsg.Refresh()
	ENDWITH
ENDPROC
PROCEDURE saveset_form.loadset
NODEFAULT
ENDPROC
PROCEDURE saveset_form.saveset
NODEFAULT
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*clearmsgtxt 
*msgtxt_assign 
msgtxt
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RY0822RE
[CLASS] base_editbox
[CLASSLOC] base_gui.vcx
[BASECLASS] editbox
[OBJNAME] editboxMsg
[PARENT] _messages
[START PROPERTIES]
Anchor = 15
BackStyle = 0
Height = 236
HideSelection = .F.
Left = 5
Name = "editboxMsg"
NullDisplay = " "
ReadOnly = .T.
Top = 5
Width = 362
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] _messages
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Z210IUUY
[CLASS] aboutbox
[CLASSLOC] aboutbox.vcx
[BASECLASS] form
[OBJNAME] about_app
[START PROPERTIES]
Applications_pageframe.Base_Page1.Name = "Base_Page1"
Applications_pageframe.Base_Page1.imgLogo.Name = "imgLogo"
Applications_pageframe.Base_Page1.lblAppName.Name = "lblAppName"
Applications_pageframe.Base_Page1.lblCopyright.Name = "lblCopyright"
Applications_pageframe.Base_Page1.lblLicense.Name = "lblLicense"
Applications_pageframe.Base_Page1.lblTrademark.Name = "lblTrademark"
Applications_pageframe.Base_Page1.lblUserCorp.Caption = "GNU"
Applications_pageframe.Base_Page1.lblUserCorp.Name = "lblUserCorp"
Applications_pageframe.Base_Page1.lblUserName.Name = "lblUserName"
Applications_pageframe.Base_Page1.lblVersion.Name = "lblVersion"
Applications_pageframe.Base_Page1.shpRectangle.Name = "shpRectangle"
Applications_pageframe.Base_Page2.Name = "Base_Page2"
Applications_pageframe.ErasePage = .T.
Applications_pageframe.Name = "Applications_pageframe"
DoCreate = .T.
Name = "about_app"
cmdOK.Left = 273
cmdOK.Name = "cmdOK"
cmdOK.Top = 260
cmdSysInfo.Name = "cmdSysInfo"
dbcontainer.Name = "dbcontainer"
registry.Name = "registry"
resizecorner.Image.Height = 16
resizecorner.Image.Name = "Image"
resizecorner.Image.Width = 16
resizecorner.Name = "resizecorner"
resizecorner.resize_timer.Name = "resize_timer"
resizecorner.tmrRefresh.Name = "tmrRefresh"
saveset_form.Name = "saveset_form"
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
LPARAMETERS tcAppName, tcVersion, tcCopyright, tcTrademark, tcLogoBMP
LOCAL lnElem, lcVer
LOCAL ARRAY laFile[1]
	lnElem = AGETFILEVERSION(laFile, m.goApp.oVars.cAppExeName)
	
	IF m.lnElem > 0
		lcVer = laFile(4)
	ELSE
		lcVer = 'Not found EXE!'
	ENDIF
	
	DODEFAULT(m.goApp.oVars.cTaskCaption + CHR(169), m.lcVer, "All Rights Reserved", "Copyright" + CHR(169) + " 2004-2009 Козлитин В.А.", "..\bmp\infernus.gif")
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] about_app
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1S01C6OH8
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] activitybar
[START PROPERTIES]
Enabled = .F.
Height = 44
Left = 0
Name = "activitybar"
Top = 0
Width = 48
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1S01CED89
[CLASS] base_image
[CLASSLOC] base_gui.vcx
[BASECLASS] image
[OBJNAME] status_anim
[PARENT] activitybar
[START PROPERTIES]
Height = 38
Left = 5
Name = "status_anim"
Picture = ..\bmp\trafficlight_off.ico
Stretch = 2
ToolTipText = "Индикатор запросов к серверу"
Top = 3
Width = 38
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] activitybar

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1OL10ND6W
[CLASS] container
[BASECLASS] container
[OBJNAME] base_app
[START PROPERTIES]

Height = 97
Name = "base_app"
Width = 135
_memberdata =     4199<VFPData><memberdata name="goform" type="Method" display="goForm" favorites="True"/><memberdata name="go" type="Method" display="go" favorites="True"/><memberdata name="ctaskcaption" type="property" display="cTaskCaption"/><memberdata name="cappcurpaths" type="property" display="cAppCurPaths"/><memberdata name="cappname" type="property" display="cAppName"/><memberdata name="closeallwindows" type="method" display="CloseAllWindows"/><memberdata name="ctaskcaption_assign" type="method" display="cTaskCaption_Assign"/><memberdata name="ctaskicon_assign" type="method" display="cTaskIcon_Assign"/><memberdata name="ctaskname" type="property" display="cTaskName"/><memberdata name="domenu" type="method" display="DoMenu"/><memberdata name="loadsettings" type="method" display="loadSettings"/><memberdata name="load_ini" type="method" display="load_Ini"/><memberdata name="savesettings" type="method" display="saveSettings"/><memberdata name="save_ini" type="method" display="save_Ini"/><memberdata name="setenvironment" type="method" display="setEnvironment"/><memberdata name="ctaskicon" type="property" display="cTaskIcon"/><memberdata name="ctaskdesktoppicture" type="property" display="cTaskDesktopPicture"/><memberdata name="ctaskdesktoppicture_assign" type="method" display="cTaskDesktopPicture_Assign"/><memberdata name="release" type="method" display="release"/><memberdata name="gomenu" type="method" display="goMenu"/><memberdata name="addwindow" type="method" display="addWindow"/><memberdata name="arraypointer" type="method" display="ArrayPointer"/><memberdata name="asavedlls" type="property" display="aSaveDlls"/><memberdata name="eventloaded" type="property" display="EventLoaded"/><memberdata name="handlewinmsg" type="method" display="handleWinMsg"/><memberdata name="lcleanalldlls" type="property" display="lCleanallDlls"/><memberdata name="loadevent" type="method" display="loadEvent"/><memberdata name="lscreenhwnd" type="property" display="lScreenHwnd"/><memberdata name="releaseevent" type="method" display="releaseEvent"/><memberdata name="removewindow" type="method" display="removeWindow"/><memberdata name="wndproc" type="property" display="Wndproc"/><memberdata name="div" type="method" display="Div"/><memberdata name="removedll" type="method" display="removeDll"/><memberdata name="showerrmsg" type="method" display="ShowErrMsg"/><memberdata name="ltaskbar" type="property" display="lTaskBar"/><memberdata name="otaskbar" type="property" display="oTaskBar"/><memberdata name="tasklist" type="property" display="TaskList"/><memberdata name="otasklist" type="property" display="oTaskList"/><memberdata name="lkeepdlls" type="property" display="lKeepDlls"/><memberdata name="cdbname" type="property" display="cDBName"/><memberdata name="cdbpath" type="property" display="cDBPath"/><memberdata name="ndbtype" type="property" display="nDBType"/><memberdata name="ocurrenttask" type="property" display="oCurrentTask"/><memberdata name="ocurrenttask_assign" type="method" display="oCurrentTask_Assign"/><memberdata name="odbconnect" type="property" display="oDBConnect"/><memberdata name="nidsession" type="property" display="nIdSession"/><memberdata name="login" type="method" display="login"/><memberdata name="logout" type="method" display="logout"/><memberdata name="schema" type="property" display="Schema"/><memberdata name="otoolbar" type="property" display="oToolBar"/><memberdata name="checkmenu" type="method" display="CheckMenu"/><memberdata name="onmenuevents" type="method" display="onMenuEvents"/><memberdata name="showmsg" type="method" display="showMsg"/><memberdata name="timeterminate" type="property" display="TimeTerminate"/><memberdata name="ndatasessionid" type="property" display="nDataSessionId"/><memberdata name="ltoolbar" type="property" display="lToolBar"/><memberdata name="cappexename" type="property" display="cAppExeName"/><memberdata name="vars" type="property" display="Vars"/><memberdata name="createmenu" type="method" display="CreateMenu"/><memberdata name="lstorepassword" type="property" display="lStorePassword"/><memberdata name="stop" type="method" display="stop"/><memberdata name="goproc" type="method" display="goProc"/></VFPData>
ndatasessionid = 0
otaskbar = .NULL.
otoolbar = .NULL.
[END PROPERTIES]
[START PROTECTED]
ActiveControl^
AddProperty^
Anchor^
BackColor^
BackStyle^
BorderColor^
BorderWidth^
ColorSource^
ControlCount^
Controls^
DblClick^
DragDrop^
DragIcon^
DragMode^
DragOver^
Drag^
Draw^
ForeColor^
GotFocus^
LostFocus^
MiddleClick^
MouseDown^
MouseEnter^
MouseIcon^
MouseLeave^
MouseMove^
MousePointer^
MouseUp^
MouseWheel^
Move^
Moved^
OLECompleteDrag^
OLEDragDrop^
OLEDragMode^
OLEDragOver^
OLEDragPicture^
OLEDrag^
OLEDropEffects^
OLEDropHasData^
OLEDropMode^
OLEGiveFeedback^
OLESetData^
OLEStartDrag^
Picture^
Refresh^
Resize^
RightClick^
SetFocus^
SpecialEffect^
StatusBarText^
Style^
ndatasessionid^
[END PROTECTED]
[START METHODS]
PROCEDURE AddObject
LPARAMETERS toForms as Form
	IF VARTYPE(m.toForms) = 'O' AND m.toForms.BaseClass == "Form"
		THIS.oApp_collection.Add(m.toForms)
	ENDIF

	NODEFAULT
ENDPROC
PROCEDURE Destroy
THIS.Release()
ENDPROC
PROCEDURE Init
LPARAMETERS tcNameApp, tcCaption, tcIcon, tcCurPaths
LOCAL loExc as Exception
	NODEFAULT
#IF !_DEVELOP_MODE
	TRY
#ENDIF
		*создаем самые "свежие" объекты
		Container::AddObject("oVars", "cstVars")
		Container::AddObject("oMenu", "SFMenu_app", "m.goApp.oMenu")

		WITH THIS
			.oVars.cAppExeName = SYS(16, 0)

			IF !EMPTY(m.tcNameApp)
				.oVars.cAppName = ALLTRIM(m.tcNameApp)
			ENDIF

			IF EMPTY(m.tcCurPaths)
				.oVars.cAppCurPaths = SYS(5) + SYS(2003) + '\'
			ELSE
				.oVars.cAppCurPaths = ADDBS(m.tcCurPaths)
			ENDIF

			IF !EMPTY(m.tcCaption)
				.oVars.cTaskCaption = m.tcCaption
			ENDIF

			IF !EMPTY(m.tcIcon)
				.oVars.cTaskIcon = m.tcIcon
			ENDIF

			IF VARTYPE(_Screen) = 'O'
				_Screen.WindowState = 2
				_Screen.ShowTips = .T.
			ENDIF

			.oVars.lTaskBar = .T.

			.setEnvironment()
			.loadSettings()

			.nDataSessionId = SET("Datasession")

			IF .oVars.lToolBar
#IF !_DEVELOP_MODE
				TRY
#ENDIF
					.oToolBar = CREATEOBJECT("Collection")
					.oToolBar.Add(CREATEOBJECT("editbar"), "TBEdit")
					.oToolBar.Item["TBEdit"].Dock(0, 0, 0)
					.oToolBar.Item["TBEdit"].Show()

					.oToolBar.Add(CREATEOBJECT("servicebar"), "TBService")
					.oToolBar.Item["TBService"].Dock(0)
					.oToolBar.Item["TBService"].Show()

					.oToolBar.Add(CREATEOBJECT("basetuningbar"), "TBBaseTuning")
					.oToolBar.Item["TBBaseTuning"].Dock(0)
					.oToolBar.Item["TBBaseTuning"].Show()

					.oToolBar.Add(CREATEOBJECT("activitybar"), "TBActivity")
					.oToolBar.Item["TBActivity"].Dock(0)
					.oToolBar.Item["TBActivity"].Show()

					.oToolBar.Add(CREATEOBJECT("exitbar"), "TBExit")
					.oToolBar.Item["TBExit"].Dock(0)
					.oToolBar.Item["TBExit"].Show()
#IF !_DEVELOP_MODE
				CATCH TO loExc
					.oFunction.showErrMsg(m.loExc)

					.oToolBar = .NULL.
				ENDTRY
#ENDIF
			ENDIF

			IF .oVars.lTaskBar
#IF !_DEVELOP_MODE
				TRY
#ENDIF
					.oTaskBar = CREATEOBJECT("taskbar")
#IF !_DEVELOP_MODE
				CATCH TO loExc
					.oFunction.showErrMsg(m.loExc)

					.oVars.lTaskBar = .F.
					.oTaskBar = .NULL.
				ENDTRY
#ENDIF
			ENDIF
		ENDWITH
#IF !_DEVELOP_MODE
	CATCH TO loExc
		THIS.oFunction.showErrMsg(m.loExc)
	ENDTRY
#ENDIF
ENDPROC
PROCEDURE RemoveObject
LPARAMETERS toForms as Object
	IF VARTYPE(m.toForms) = 'O' AND m.toForms.BaseClass = "Form"
		LOCAL lnI as Integer

		FOR lnI = 1 TO THIS.oApp_Collection.Count
			IF THIS.oApp_Collection.Item[m.lnI] = m.toForms
				THIS.oApp_Collection.Remove(m.lnI)

				EXIT
			ENDIF
		ENDFOR
	ENDIF

	NODEFAULT
ENDPROC
PROCEDURE addwindow
LPARAMETERS thWnd as Integer
LOCAL loForm as Form, llAddFormOK as Logical
	IF m.thWnd = _VFP.hWnd
		RETURN
	ENDIF

	lAddFormOK = .F.
	*first, scan forms collection to see if hWnd is from some active form
	FOR EACH loForm IN _Screen.Forms 
		IF m.loForm.hWnd = m.thWnd
			IF !(EMPTY(m.loForm.Caption) OR INLIST(m.loForm.Caption, "Debugger",;
																	 "Watch",;
																	 "Locals",;
																	 "Trace",;
																	 "Call Stack",;
																	 "Debug Output",;
																	 "Report Preview"));
			   AND m.loForm.BaseClass == "Form"
				llAddFormOK = .T.
			ENDIF

			EXIT
		ENDIF
	ENDFOR

	IF m.llAddFormOK
		LOCAL lnI as Integer

		llAddFormOK = .F.

		WITH THIS
			FOR lnI = 1 TO .oApp_Collection.Count
				IF .oApp_Collection.Item[m.lnI] = m.loForm
					llAddFormOK = .T.

					EXIT
				ENDIF
			ENDFOR

			IF !m.llAddFormOK
				.AddObject(m.loForm)

				IF .oVars.lTaskBar			
				*перехват оконных событий пока только если нужен таск бар
				*для report окон fox падает
*!*				BINDEVENT(m.loForm, "Release", THIS, "RemoveWindow", 0)
					BINDEVENT(m.thWnd, WM_DESTROY, THIS, "handlewinmsg", 4)
					BINDEVENT(m.thWnd, WM_SETTEXT, THIS, "handlewinmsg", 4)
					BINDEVENT(m.thWnd, WM_SETFOCUS, THIS, "handlewinmsg", 4)
*!*				BINDEVENT(m.thWnd, WM_WINDOWPOSCHANGED, THIS, "handlewinmsg", 4)
				ENDIF

				IF .oVars.lTaskBar
					.oTaskBar.addFormButton(m.loForm)
				ENDIF
			ENDIF
		ENDWITH
	ENDIF
ENDPROC
PROCEDURE go
LPARAMETERS tcUserName as String, tcUserPassword as String, tv3, tv4, tv5, tv6, tv7, tv8
LOCAL loForm as login_form OF ..\lib.9\base_app, loExc as Exception
	WITH THIS
		*проверить - запущена ли еще одна копия?
		IF .oVars.oCurrentTask.oVars.lOnceStart AND .oWinApi.findWindow(.oVars.cTaskCaption) <> 0
			RETURN .F.
		ENDIF
		*провести идентификацию пользователя
		IF !EMPTY(m.tcUserName) AND !ISNULL(.oVars.oCurrentTask)
			*сохранить логин и пароль текущую задачу
			.oVars.oCurrentTask.oVars.cUserName = ALLTRIM(m.tcUserName)
			.oVars.oCurrentTask.oVars.cUserPassword = ALLTRIM(m.tcUserPassword)
			.oVars.oCurrentTask.oVars.lStorePassword = .T.
		ENDIF

		IF .Login()
		*удачно подконнектились и залогинились
		*неудачная попытка подключения к базе обрабатывается в login_form, если пользователь задан жестко,
		*то - значит настроен автоматический запуск - и все идут лесом
		*сохраним под кем зашли
			*сохранить настройки
			.saveSettings()

			IF .oVars.lToolBar
				LOCAL loObj as Object

				FOR EACH loObj IN .oToolBar
					loObj.Enabled = .T.
				ENDFOR
			ENDIF
#IF !_DEVELOP_MODE
			TRY
#ENDIF
				IF .oVars.lMenuBar AND EMPTY(m.tcUserName)
				*если вызвали с параметрами то меню не активировать.
					.goMenu()

					READ EVENTS
					*сохранить настройки
					.saveSettings()
				ENDIF
#IF !_DEVELOP_MODE
			CATCH TO loExc
				.oFunction.showErrMsg(m.loExc)
			ENDTRY
#ENDIF
			.logout()
		ELSE
			RETURN .F.
		ENDIF
	ENDWITH
ENDPROC
PROCEDURE goform
*выполнить форму в ее датасессии
PARAMETERS tcFormName as String, tndsid as Integer, tcFormPtr as String, tcVar as String, tvp1, tvp2, tvp3, tvp4,;
		   tvp5, tvp6, tvp7, tvp8
LOCAL lcRun as String, lnI as Integer, loExc as Exception, lvVar as Variant
PRIVATE poFormPtr as Form
#IF !_DEVELOP_MODE
	TRY
#ENDIF
		lvVar = .F.
		poFormPtr = .NULL.

*!*			lcRun = "DO FORM "+IIF(_VFP.StartMode = 0, THIS.oVars.cAppCurPaths+"\FORMS\", '')+m.tcFormName+;
*!*					IIF(!ISNULL(m.tcFormPtr), " NAME m.poFormPtr", '')+;
*!*					IIF(!ISNULL(m.tcVar), " TO m.lvVar", '')

		lcRun = "DO FORM " + m.tcFormName +;
				IIF(!ISNULL(m.tcFormPtr), " NAME m.poFormPtr", '') +;
				IIF(!ISNULL(m.tcVar), " TO m.lvVar", '')

		IF PCOUNT() > 4
			lcRun = m.lcRun+" WITH "

			FOR lnI = 1 TO PCOUNT() - 4
				lcRun = m.lcRun + "m.tvp" + LTRIM(TRANSFORM(m.lnI)) + ','
				*TRANSFORM(EVALUATE("m.tvp"+LTRIM(TRANSFORM(lnI))))+','
			ENDFOR

			lcRun = LEFT(m.lcRun, LEN(m.lcRun) - 1)
		ENDIF

		IF m.tndsid <> 0
			SET DATASESSION TO m.tndsid
		ENDIF

*!*			EXECSCRIPT(m.lcRun)
		&lcRun

*!*			lcRun = "DO FORM "+IIF(_VFP.StartMode = 0, THIS.oVars.cAppCurPaths+"\FORMS\", '')+m.tcFormName+;
*!*					IIF(!ISNULL(m.tcFormPtr), " NAME m.poFormPtr", '')+;
*!*					IIF(!ISNULL(m.tcVar), " TO m.lvVar", '')

		lcRun = "DO FORM " + m.tcFormName +;
				IIF(!ISNULL(m.tcFormPtr), " NAME m.poFormPtr", '') +;
				IIF(!ISNULL(m.tcVar), " TO m.lvVar", '')

*!*			IF !(VARTYPE(m.tvvar) = 'O' AND ISNULL(m.tvvar))
		IF VARTYPE(m.tcVar) = 'O' AND !ISNULL(m.tcVar)
			STORE m.lvVar TO (m.tcVar)
		ENDIF

		IF VARTYPE(m.tcFormPtr) = 'O' AND !ISNULL(m.tcFormPtr)
			STORE m.poFormPtr TO (m.tcFormPtr)
		ENDIF

		IF m.tndsid <> 0
			SET DATASESSION TO THIS.nDataSessionId
		ENDIF
#IF !_DEVELOP_MODE
	CATCH TO loExc
		THIS.oFunction.showErrMsg(m.loExc)
	ENDTRY
#ENDIF
ENDPROC
PROCEDURE gomenu
LOCAL loExc as Exception
	WITH THIS.oVars
		IF .lToolBar
		*выставить "птички" на активных тулбарах
*!*					*редактирование
*!*					SET MARK OF BAR 1 OF toolbr_pop TO .T.
*!*					*сервис
*!*					SET MARK OF BAR 3 OF toolbr_pop TO .T.
*!*					*настройки
*!*					SET MARK OF BAR 4 OF toolbr_pop TO .T.
*!*					*активность соединения
*!*					SET MARK OF BAR 6 OF toolbr_pop TO .T.

*!*					IF THIS.oVars.lTaskBar
*!*					*taskbar
*!*						SET MARK OF BAR 5 OF toolbr_pop TO .T.
*!*					ENDIF
		ENDIF

		IF .lMenuBar
			THIS.oMenu.Show()
		ENDIF
	ENDWITH
ENDPROC
PROCEDURE goproc
*выполнить функцию в отдельной датасессии
PARAMETERS tcProcName as String, tndsid as Integer, tvp1, tvp2, tvp3, tvp4, tvp5, tvp6, tvp7, tvp8
LOCAL lcRun as String, lnI as Integer, loExc as Exception, lvVar as Variant, loSession as Session
PRIVATE poFormPtr as Form
#IF !_DEVELOP_MODE
	TRY
#ENDIF
		lvVar = .F.
		lcRun = "lvVar = " + m.tcProcName + "("

		IF PCOUNT() > 2
			FOR lnI = 1 TO PCOUNT() - 2
				lcRun = m.lcRun + "m.tvp" + LTRIM(TRANSFORM(m.lnI)) + ','
			ENDFOR

			lcRun = LEFT(m.lcRun, LEN(m.lcRun) - 1)
		ENDIF

		lcRun = m.lcRun + ')'

		IF m.tndsid = 0
			loSession = NEWOBJECT("base_session", "base_session.prg")
			
			tndsid = m.loSession.DataSessionId
		ENDIF

		SET DATASESSION TO m.tndsid

*!*				EXECSCRIPT(m.lcRun)
		&lcRun

		IF m.tndsid > 0
			SET DATASESSION TO THIS.nDataSessionId
		ENDIF
#IF !_DEVELOP_MODE
	CATCH TO loExc
		THIS.oFunction.showErrMsg(m.loExc)
	ENDTRY
#ENDIF
RETURN m.lvVar
ENDPROC
PROCEDURE handlewinmsg
LPARAMETERS thWnd as Integer, tnMsg as Integer, tnwParam as Integer, tnlParam as Integer
LOCAL lnRetvalue
	lnRetvalue = 0

	WITH THIS.oVars
		DO CASE
		CASE m.tnMsg = WM_WINDOWPOSCHANGED
		*z-order change
			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)
	*!*			lhwndInsAfter = CTOBIN(SYS(2600, m.tnlParam+(4*1), 4), "4rs")

	*!*			i = THIS.FindAWindow(hWnd)
	*!*			IF i >0
	*!*				THIS.otView.nodes(i).Selected = 1
	*!*			ENDIF 
		CASE m.tnMsg = WM_SETFOCUS
		*focus
			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)

			IF .lTaskBar 
				THIS.oTaskBar.activateFormButton(m.thWnd)

				IF TYPE("_Screen.ActiveForm") = 'O' AND !ISNULL(_Screen.ActiveForm) AND _Screen.ActiveForm.WindowType = 1
				*активна модальная форма
					THIS.oTaskBar.Enabled = .F.
				ELSE
					THIS.oTaskBar.Enabled = .T.
				ENDIF
			ENDIF
		CASE m.tnMsg = WM_SETTEXT
		*title change
			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)

			IF .lTaskBar
				LOCAL loForm as Form

				FOR EACH loForm IN THIS.oApp_Collection
					IF m.loForm.HWnd = m.thWnd
						THIS.oTaskBar.captionAssignHandler(m.loForm)

						EXIT
					ENDIF
				ENDFOR
			ENDIF
	*!*		CASE m.tnMsg = WM_ACTIVATE
	*!*				DO CASE
	*!*				CASE m.tnwParam = WA_INACTIVE
	*!*					*Activated by some method other than a mouse click .
	*!*				CASE m.tnwParam = WA_CLICKACTIVE
	*!*					*Activated by a mouse click.
	*!*				CASE m.tnwParam = WA_INACTIVE
	*!*					*Deactivated.
	*!*				ENDCASE
		CASE m.tnMsg = WM_SHOWWINDOW
		*show
	*!*			IF m.tnwParam! = 0
			IF .lTaskBar 
			*добавить в таскбар
			*activate
				THIS.addWindow(m.thWnd)

	*!*				DO CASE
	*!*				CASE m.tnlParam = SW_OTHERUNZOOM
	*!*					*The window is being uncovered because a maximize window was restored or minimized.
	*!*				CASE m.tnlParam = SW_OTHERZOOM
	*!*					*The window is being covered by another window that has been maximized.
	*!*				CASE m.tnlParam = SW_PARENTCLOSING
	*!*					*The window's owner window is being minimized.
	*!*				CASE m.tnlParam = SW_PARENTOPENING
	*!*					*The window's owner window is being restored.
	*!*				ENDCASE

				UNBINDEVENTS(m.thWnd, m.tnMsg)	
	*!*			ELSE
	*!*			*убрать из таскбара
	*!*			*hide
	*!*				IF THIS.oVars.lTaskBar
	*!*					THIS.oTaskBar.DeactivateHandler(m.thWnd)
	*!*				ENDIF
			ENDIF

			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)

			IF .lTaskBar AND VARTYPE(THIS.oTaskBar) = 'O'
				IF TYPE("_Screen.ActiveForm") = 'O' AND !ISNULL(_Screen.ActiveForm) AND _Screen.ActiveForm.WindowType = 1
				*активна модальная форма
					THIS.oTaskBar.Enabled = .F.
				ELSE
					THIS.oTaskBar.Enabled = .T.
				ENDIF
			ENDIF
		CASE m.tnMsg = WM_CREATE
			LOCAL lndwStyle
			lndwStyle = CTOBIN(SYS(2600, m.tnlParam + (4 * 8), 4), "4rs")

			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)

			IF BITAND(m.lndwStyle, WS_BORDER) = WS_BORDER
				BINDEVENT(m.thWnd, WM_SHOWWINDOW, THIS, "handlewinmsg", 4)
			ENDIF

			lnRetvalue = 0
		CASE m.tnMsg = WM_DESTROY
			THIS.removeWindow(m.thWnd)

			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)
		ENDCASE
	ENDWITH
RETURN m.lnRetvalue
ENDPROC
PROCEDURE load_ini
LPARAMETERS tcSection, tcKey, tcKeyValue, tcFields, toFieldsValue
	THIS.oXml_Ini.getXmlIniEntry(THIS.oVars.cAppCurPaths + THIS.oVars.cAppName + ".XML", m.tcSection, m.tcKey, m.tcKeyValue,;
								 m.tcFields, @toFieldsValue)
ENDPROC
PROCEDURE loadevent
LOCAL ARRAY laDLLs[1]
	WITH THIS
		ADLLS(laDLLs)
		ACOPY(laDLLs, .oVars.aSaveDlls)

		DECLARE integer CallWindowProc IN WIN32API;
			integer lpPrevWndFunc,;
			integer hWnd, integer Msg,;
			integer wParam,;
			integer lParam

		.oVars.wndProc = .oWinApi.getWindowLong(IIF(.oVars.lScreenhWnd, _Screen.HWnd, _VFP.HWnd), GWL_WNDPROC)

		BINDEVENT(0, WM_CREATE, THIS, "handlewinmsg", 4)

		.oVars.Eventloaded = .T.
	ENDWITH
ENDPROC
PROCEDURE loadsettings
#INCLUDE "..\lib.9\base_idb.h"
LOCAL loExc as Exception, lctask_name as String, lnI as Integer, lnJ as Integer, lnK as Integer, lnL as Integer,;
		loFields as xml_fields OF ..\lib.9\xml_ini, lnIdVars, lnRow, lnCol
LOCAL ARRAY laTmp[1], laTmp1[1, 1]
	WITH THIS
#IF !_DEVELOP_MODE
		TRY
#ENDIF
			LOCAL loProgrammProperties as Collection

			.load_ini("ProgrammProperties", .F., .F., '', @loProgrammProperties)

			IF VARTYPE(m.loProgrammProperties) = 'O' AND (!ISNULL(m.loProgrammProperties);
														  AND m.loProgrammProperties.Count > 0)
				FOR lnI = 1 TO m.loProgrammProperties.Count
					loFields = m.loProgrammProperties.Item[m.lnI]
					
					FOR lnJ = 1 TO ALEN(m.loFields.aFields, 1)
						IF m.loFields.aFields[m.lnJ, 1] = "Name"
							lvValue = ''

							FOR lnK = 1 TO ALEN(m.loFields.aFields, 1)
								IF m.loFields.aFields[m.lnK, 1] = "Value"
									lvValue = VAL(m.loFields.aFields[m.lnK, 2])

									EXIT
								ENDIF
							ENDFOR
							
							IF !EMPTY(m.lvValue)
								DO CASE
								CASE m.loFields.aFields[m.lnJ, 2] = "SystemTimerInterval"
									.oApp_Timer.Interval = m.lvValue

									EXIT
								OTHERWISE
								ENDCASE
							ENDIF
						ENDIF
					ENDFOR
				ENDFOR
			ELSE
			ENDIF
#IF !_DEVELOP_MODE
		CATCH TO loExc
			.Function.showErrMsg(m.loExc)
		ENDTRY
#ENDIF
#IF !_DEVELOP_MODE
		TRY
#ENDIF
			LOCAL loDataBases as Collection

			.load_ini("TaskList", .F., .F., '', @loDataBases)

			IF VARTYPE(m.loDataBases) = 'O' AND (!ISNULL(m.loDataBases) AND m.loDataBases.Count > 0)
				LOCAL lotask as tasklist OF ..\lib.9\base_app

				FOR lnI = 1 TO m.loDataBases.Count
				*цикл по задачам
					loFields = m.loDataBases.Item[m.lnI]
					*хорошо бы сделать копирование tasklist-a главного объекта программы
					lotask = NEWOBJECT("tasklist")

					FOR lnJ = 1 TO ALEN(m.loFields.aFields, 1)
					*цикл по полям задачи
						*убрать пробелы
						loFields.aFields[m.lnJ, 2] = ALLTRIM(m.loFields.aFields[m.lnJ, 2])
						*найти в массиве данное поле
						lnIdVars = ASCAN(m.lotask.oVars.aStoreXmlVars, m.loFields.aFields[m.lnJ, 1],;
										 -1, -1, 2, 15)
						
						IF m.lnIdVars <> 0
							*выполнить преобразование типов
							DO CASE
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'd' &&типа date
								lvValue = CTOD(m.loFields.aFields[m.lnJ, 2])
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'c' &&типа char
								lvValue = IIF(VARTYPE(m.loFields.aFields[m.lnJ, 2]) = 'C',;
											  ALLTRIM(m.loFields.aFields[m.lnJ, 2]),;
											  '')
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'n' &&типа numeric
								lvValue = IIF(VARTYPE(m.loFields.aFields[m.lnJ, 2]) = 'C',;
											  VAL(m.loFields.aFields[m.lnJ, 2]),;
											  0)
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'v' &&типа variable
								lvValue = IIF(VARTYPE(m.loFields.aFields[m.lnJ, 2]) = 'C',;
											  ALLTRIM(m.loFields.aFields[m.lnJ, 2]),;
											  m.loFields.aFields[m.lnJ, 2])
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'l' &&типа logical
								lvValue = IIF(VARTYPE(m.loFields.aFields[m.lnJ, 2]) = 'C',;
											  m.loFields.aFields[m.lnJ, 2] == "TRUE",;
											  .F.)
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'a' &&типа array
								*распаковать архив
								ALINES(laTmp, SUBSTR(m.loFields.aFields[m.lnJ, 2],;
													 3,;
									   				 LEN(m.loFields.aFields[m.lnJ, 2]) - 4),;
									   2, '"]["')

								lnRow = ALEN(laTmp, 1)
								lnCol = THIS.oFunction.getWordCount(laTmp[1], '";"')
								*новый массивчик
								DIMENSION laTmp1[m.lnRow, m.lnCol]

								FOR lnK = 1 TO m.lnRow
									FOR lnL = 1 TO m.lnCol
										laTmp1[m.lnK, m.lnL] = THIS.oFunction.getWordNum(laTmp[m.lnK], m.lnL, '";"')
									ENDFOR
								ENDFOR

								lcExp = "DIMENSION m.lotask.oVars." + m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 1];
										+ '[' + TRANSFORM(m.lnRow) + ',' + TRANSFORM(m.lnCol) + ']'
								&lcExp

								lcExp = "ACOPY(laTmp1, m.lotask.oVars." + m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 1] + ')'
								&lcExp
							OTHERWISE
								lvValue = IIF(VARTYPE(m.loFields.aFields[m.lnJ, 2]) = 'C',;
											  ALLTRIM(m.loFields.aFields[m.lnJ, 2]),;
											  m.loFields.aFields[m.lnJ, 2])
							ENDCASE
							*сохранить в переменную объекта Vars
							IF m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] <> 'a'
								STORE m.lvValue TO ("m.lotask.oVars." + m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 1])
							ENDIF
						ENDIF
					ENDFOR

					lotask.oVars.cTaskCaption = m.lotask.oVars.cTaskName

					IF !m.lotask.oVars.lStorePassword
						lotask.oVars.cUserPassword = ''
					ENDIF

					.oTaskList.Add(m.lotask)

					IF m.lotask.oVars.lActive
						.oVars.oCurrentTask = m.lotask
					ENDIF
				ENDFOR
			ELSE
				lotask = NEWOBJECT("tasklist")

				.oTaskList.Add(m.lotask)
			ENDIF

			IF ISNULL(.oVars.oCurrentTask)
				.oVars.oCurrentTask = .oTaskList.Item[1]
			ENDIF
#IF !_DEVELOP_MODE
		CATCH TO loExc
			.oFunction.showErrMsg(m.loExc)
		ENDTRY
#ENDIF
	ENDWITH
ENDPROC
PROCEDURE login
*форма авторизации
LOCAL llreslogin as Logical, lcCursorName as String, llResult as Logical, llsuccess as Logical,;
	  loExc as Exception
	llreslogin = .F.

	WITH THIS
		IF !ISNULL(.oVars.oCurrentTask)
			IF .oVars.oCurrentTask.oVars.lStorePassword
				*подключаться без вывода формы "логина"
#IF !_DEVELOP_MODE
				TRY
#ENDIF
					.oVars.oDBConnect = NEWOBJECT("DbConnect", "..\lib.9\base_idb", '', .oVars.oCurrentTask.oVars.nDBType)

					llsuccess = .oVars.oDBConnect.connect(.oVars.oCurrentTask.oVars.cDBPath,;
														  .oVars.oCurrentTask.oVars.cDBName,;
														  .oVars.oCurrentTask.oVars.cUserName,;
														  .oVars.oCurrentTask.oVars.cUserPassword)
#IF !_DEVELOP_MODE
				CATCH TO loExc
					.Function.showErrMsg(m.loExc)
				ENDTRY
#ENDIF
			ENDIF

			IF !m.llsuccess AND !.oVars.oCurrentTask.oVars.lStorePassword
			*подключиться не удалось либо требуется ввести пароль - запускаем форму "логина"
				loForm = CREATEOBJECT("login_form", THIS)

				WITH m.loForm
					IF !.lPassVerification
						.Show(1)
					ENDIF

					llsuccess = .lPassVerification
					THIS.oVars.oDBConnect = .oDBConnect

					.Release()
				ENDWITH
			ENDIF

			IF !ISNULL(.oVars.oDBConnect)
				DO CASE
				CASE .oVars.oCurrentTask.oVars.nDBType = DB_FoxPro
					.oVars.oCurrentTask.nIdSession = .oVars.oDBConnect.nId_Connection
				CASE .oVars.oCurrentTask.oVars.nDBType = DB_PostgreSQL
					LOCAL loSql as dbsql OF ..\lib.9\base_idb
					lcCursorName = SYS(2015)

					loSql = NEWOBJECT("dbsql", "..\lib.9\base_idb", '', .oVars.oDBConnect)
					llResult = m.loSql.execute("SELECT " + .oVars.oCurrentTask.oVars.cDBSchema;
											   + ".login_user()", m.lcCursorName)

					RELEASE m.loSql

					.oVars.oCurrentTask.nIdSession = IIF(m.llResult,;
														EVALUATE(m.lcCursorName + ".login_user"),;
														0)

					USE IN SELECT(m.lcCursorName)
				CASE .oVars.oCurrentTask.oVars.nDBType = DB_MSSQL
					.oVars.oCurrentTask.nIdSession = .oVars.oDBConnect.nId_Connection
				CASE .oVars.oCurrentTask.oVars.nDBType = DB_Oracle
				CASE .oVars.oCurrentTask.oVars.nDBType = DB_Access
					.oVars.oCurrentTask.nIdSession = .oVars.oDBConnect.nId_Connection
				OTHERWISE
					.oVars.oCurrentTask.nIdSession = .oVars.oDBConnect.nId_Connection
				ENDCASE

				IF .oVars.oCurrentTask.nIdSession < 1
					.oVars.oDBConnect.Destroy()
					.oVars.oDBConnect = .NULL.
					.oApp_timer.Enabled = .F.

					.showMsg("Cannot login!")
				ELSE
*!*						.SaveSettings()
					llreslogin = .T.
					.oApp_timer.Enabled = .T.
				ENDIF
			ENDIF
		ENDIF
	ENDWITH
RETURN m.llreslogin
ENDPROC
PROCEDURE logout
WITH THIS
	IF !ISNULL(.oVars.oCurrentTask) AND !ISNULL(.oVars.oDBConnect) AND !ISNULL(.oVars.oCurrentTask.nIdSession)
		.oApp_timer.Enabled = .F.

		DO CASE
		CASE .oVars.oCurrentTask.oVars.nDBType = DB_FoxPro
		CASE .oVars.oCurrentTask.oVars.nDBType = DB_PostgreSQL
			LOCAL loSql as Object, lnnIdSession as Integer
			lcCursorName = SYS(2015)
			lnIdSession = .oVars.oCurrentTask.nIdSession

			loSql = NEWOBJECT("dbsql", "..\lib.9\base_idb", '', .oVars.oDBConnect)
			llResult = m.loSql.execute("SELECT " + .oVars.oCurrentTask.oVars.cDBSchema;
									   + ".logout_user(CAST("+TRANSFORM(m.lnIdSession) + " AS INTEGER))",;
									   m.lcCursorName)

			RELEASE m.loSql

			USE IN SELECT(m.lcCursorName)

			.oVars.oCurrentTask.nIdSession = .NULL.
		CASE .oVars.oCurrentTask.oVars.nDBType = DB_MSSQL
		CASE .oVars.oCurrentTask.oVars.nDBType = DB_Oracle
		CASE .oVars.oCurrentTask.oVars.nDBType = DB_Access
		ENDCASE
	ENDIF
ENDWITH
ENDPROC
PROCEDURE onmenuevents
LPARAMETERS tcNameMenu as String
LOCAL loExc as Exception
#IF !_DEVELOP_MODE
	TRY
#ENDIF
		DO CASE
		CASE m.tcNameMenu = "Find"
			IF TYPE("_Screen.ActiveForm") = 'O' AND;
				_Screen.ActiveForm.Baseclass = "Form" AND;
				_Screen.ActiveForm.Class = "Main_form"
				_Screen.ActiveForm.cntToolbars.cntFind.Click()
			ENDIF
		CASE m.tcNameMenu = "Replace"
		CASE m.tcNameMenu = "Clock"
			LOCAL loClock as Form

			loClock = NEWOBJECT("_Clock", "..\lib.9\base_app")
			m.loClock.Show()

			THIS.AddWindow(m.loClock.HWnd)
		CASE m.tcNameMenu = "Calendar"
			LOCAL loCalendar as Form

			loCalendar = NEWOBJECT("_Calendar", "..\lib.9\base_app")
			m.loCalendar.Show()

			THIS.addWindow(m.loCalendar.HWnd)
		CASE m.tcNameMenu = "TBEdit"
		*редактирование
			IF THIS.oMenu.FacePad.ToolBarPad.Item["ToolBar"].lMarked
				THIS.oMenu.FacePad.ToolBarPad.Item["ToolBar"].lMarked = .F.

				THIS.oToolBar.Item["TBEdit"].Visible = .F.
			ELSE
				THIS.oMenu.FacePad.ToolBarPad.Item["ToolBar"].lMarked = .T.

				THIS.oToolBar.Item["TBEdit"].Visible = .T.
			ENDIF
		CASE m.tcNameMenu = "TBService"
		*сервис
			IF THIS.oMenu.FacePad.ToolBarPad.Item["ServiceBar"].lMarked
				THIS.oMenu.FacePad.ToolBarPad.Item["ServiceBar"].lMarked = .F.

				THIS.oToolBar.Item["TBService"].Visible = .F.
			ELSE
				THIS.oMenu.FacePad.ToolBarPad.Item["ServiceBar"].lMarked = .T.

				THIS.oToolBar.Item["TBService"].Visible = .T.
			ENDIF
		CASE m.tcNameMenu = "TBBaseTuning"
		*настройки
			IF THIS.oMenu.FacePad.ToolBarPad.Item["BaseTuningBar"].lMarked
				THIS.oMenu.FacePad.ToolBarPad.Item["BaseTuningBar"].lMarked = .F.

				THIS.oToolBar.Item["TBBaseTuning"].Visible = .F.
			ELSE
				THIS.oMenu.FacePad.ToolBarPad.Item["BaseTuningBar"].lMarked = .T.

				THIS.oToolBar.Item["TBBaseTuning"].Visible = .T.
			ENDIF
		CASE m.tcNameMenu = "TBActivity"
		*настройки
			IF THIS.oMenu.FacePad.ToolBarPad.Item["ActivityBar"].lMarked
				THIS.oMenu.FacePad.ToolBarPad.Item["ActivityBar"].lMarked = .F.

				THIS.oToolBar.Item["TBActivity"].Visible = .F.
			ELSE
				THIS.oMenu.FacePad.ToolBarPad.Item["ActivityBar"].lMarked = .T.

				THIS.oToolBar.Item["TBActivity"].Visible = .T.
			ENDIF
		ENDCASE
#IF !_DEVELOP_MODE
	CATCH TO loExc
		THIS.showErrMsg(m.loExc)
	ENDTRY
#ENDIF
ENDPROC
PROCEDURE release
LOCAL laDLLs, lni, lnCount, loObj as Toolbar
	*закрыть окна
	WITH THIS
		.oFunction.closeAllWindows()

		IF !ISNULL(.oVars.oDBConnect)
			.oVars.oDBConnect.Destroy()
		ENDIF
		*status bar
#IF !_DEVELOP_MODE
		TRY
#ENDIF
			IF !ISNULL(.oTaskBar)
				.oTaskBar.Release()
			ENDIF
#IF !_DEVELOP_MODE
		CATCH TO loExc
		FINALLY
#ENDIF
			THIS.oTaskBar = .NULL.
#IF !_DEVELOP_MODE
		ENDTRY
#ENDIF
		*toolbars
		IF .oVars.lToolBar
#IF !_DEVELOP_MODE
			TRY
#ENDIF
				FOR EACH loObj IN .oToolBar
					m.loObj.RemoveObject()
				ENDFOR
#IF !_DEVELOP_MODE
			CATCH TO loExc
			FINALLY
#ENDIF
				.oToolBar = .NULL.
#IF !_DEVELOP_MODE
			ENDTRY
#ENDIF
		ENDIF
		*windows
		FOR EACH loObj IN .oApp_Collection
			IF TYPE("m.loObj.BaseClass") = 'C' AND m.loObj.BaseClass == "Form"
				m.loObj.Release()
			ELSE
				RELEASE m.loObj
			ENDIF
		ENDFOR

		DIMENSION laDLLs[1]

		IF .oVars.EventLoaded
			.releaseEvent()
		ENDIF

		IF .oVars.lCleanAllDlls
			lnCount = ADLLS(laDLLs)

			FOR lni = 1 TO m.lnCount
				.removeDLL(laDLLs[m.lni, 1])
			ENDFOR
		ENDIF

		.removeDLL("CallWindowProc")	

		CLEAR EVENTS
	ENDWITH
ENDPROC
PROCEDURE releaseevent
THIS.oVars.Eventloaded = .F.

UNBINDEVENTS(0, WM_CREATE)
*!*	UNBINDEVENTS(0, WM_DESTROY)
*!*	UNBINDEVENTS(0, WM_SETTEXT)
*!*	UNBINDEVENTS(0, WM_SETFOCUS)
*!*	UNBINDEVENTS(0, WM_WINDOWPOSCHANGED)
*!*	UNBINDEVENTS(0, WM_SHOWWINDOW)
ENDPROC
PROCEDURE removedll
LPARAMETERS tcDLLName as String
	IF VARTYPE(THIS.oVars.lKeepDlls) = 'L' AND THIS.oVars.lKeepDlls
		RETURN
	ENDIF

	IF ASCAN(THIS.oVars.aSaveDLLs, m.tcDLLName, -1, -1, 1, 1) = 0
		CLEAR DLLS &tcDLLName
	ENDIF
ENDPROC
PROCEDURE removewindow
LPARAMETERS thWnd as Integer
LOCAL loForm as Form
	IF m.thWnd = _VFP.hWnd
		RETURN
	ENDIF
	*first, scan forms collection to see if hWnd is from some active form
*!*		FOR EACH loForm IN THIS.oApp_Collection
*!*			IF m.loForm.hWnd = larrEv[1,1].hWnd &&m.thWnd
*!*				UNBINDEVENTS(m.loForm, "Release", THIS, "RemoveWindow")
*!*				UNBINDEVENTS(m.thWnd, WM_WINDOWPOSCHANGED)
*!*				
*!*				THIS.RemoveObject(m.loForm)

			IF THIS.oVars.lTaskBar
				UNBINDEVENTS(m.thWnd, WM_DESTROY)
				UNBINDEVENTS(m.thWnd, WM_SETTEXT)
				UNBINDEVENTS(m.thWnd, WM_SETFOCUS)

				IF VARTYPE(THIS.oTaskBar) = 'O'
					THIS.oTaskBar.removeFormButton(m.thWnd)
				ENDIF
			ENDIF
*!*				
*!*				EXIT
*!*			ENDIF
*!*		ENDFOR
ENDPROC
PROCEDURE save_ini
LPARAMETERS tcSection, tcKey, tcKeyValue, tcFields, taFieldsValue
	THIS.oXml_Ini.writeXmlIniEntry(THIS.oVars.cAppCurPaths + THIS.oVars.cAppName + ".XML", m.tcSection, m.tcKey, m.tcKeyValue,;
								   m.tcFields, @taFieldsValue)
ENDPROC
PROCEDURE savesettings
#INCLUDE "..\lib.9\base_idb.h"
LOCAL loExc as Exception, lcDBType as String, lcVars, lcValues, lnI, lnJ, lnK, lvValue, lnCol
#IF !_DEVELOP_MODE
	TRY
#ENDIF
		*общие настройки
		THIS.save_ini("ProgrammProperties", "Name", "SystemTimerInterval", "Value", TRANSFORM(THIS.oApp_Timer.Interval))

		WITH THIS.oVars.oCurrentTask.oVars
			*настройки текущей задачи
			IF !ISNULL(THIS.oVars.oCurrentTask)
				*кастомные переменные
				lcVars = ''
				lcValues = ''
				*цикл по полям которые надо сохранять
				FOR lnI = 1 TO ALEN(.aStoreXmlVars, 1)
					lcVars = m.lcVars + ',' + .aStoreXmlVars[m.lnI, 2]
					
					DO CASE
					CASE .aStoreXmlVars[m.lnI, 3] = 'd' &&типа date
						lcValues = m.lcValues + ',' + TRANSFORM(EVALUATE("." + .aStoreXmlVars[m.lnI, 1]))
					CASE .aStoreXmlVars[m.lnI, 3] = 'c' &&типа char
						lvValue = EVALUATE("." + .aStoreXmlVars[m.lnI, 1])
						lcValues = m.lcValues + ',' + IIF(VARTYPE(m.lvValue) = 'C', ALLTRIM(m.lvValue), '')
					CASE .aStoreXmlVars[m.lnI, 3] = 'n' &&типа numeric
						lcValues = m.lcValues + ',' + TRANSFORM(EVALUATE("." + .aStoreXmlVars[m.lnI, 1]))
					CASE .aStoreXmlVars[m.lnI, 3] = 'v' &&типа variable
						lcValues = m.lcValues + ',' + TRANSFORM(EVALUATE("." + .aStoreXmlVars[m.lnI, 1]))
					CASE .aStoreXmlVars[m.lnI, 3] = 'l' &&типа logical
						lcValues = m.lcValues + ',' + IIF(EVALUATE("." + .aStoreXmlVars[m.lnI, 1]),;
														  "TRUE", "FALSE")
					CASE .aStoreXmlVars[m.lnI, 3] = 'a' &&типа array
						lcValues = m.lcValues + ','

						FOR lnJ = 1 TO EVALUATE("ALEN(." + .aStoreXmlVars[m.lnI, 1] + ", 1)")
							lcValues = m.lcValues + '["'
							lnCol = EVALUATE("ALEN(." + .aStoreXmlVars[m.lnI, 1] + ", 2)")

							FOR lnK = 1 TO IIF(m.lnCol = 0, 1, m.lnCol)
								lvValue = EVALUATE("." + .aStoreXmlVars[m.lnI, 1];
												   + '[' + TRANSFORM(m.lnJ) + ',' + TRANSFORM(m.lnK) +']')
								lcValues = m.lcValues + ALLTRIM(IIF(VARTYPE(m.lvValue) <> 'C', TRANSFORM(m.lvValue), m.lvValue)) + '";"'
							ENDFOR

							
*!*								lcValues = IIF(EVALUATE("ALEN(." + .aStoreXmlVars[m.lnI, 1] + ", 2)") > 0,;
*!*											   LEFT(m.lcValues, LEN(m.lcValues) - 3),;
*!*											   m.lcValues);
*!*										   + '"]'
							lcValues = LEFT(m.lcValues, LEN(m.lcValues) - 3) + '"]'
						ENDFOR
					OTHERWISE
						lcValues = m.lcValues + ',' + ALLTRIM(EVALUATE("." + .aStoreXmlVars[m.lnI, 1]))
					ENDCASE
				ENDFOR
				*убрать лишнюю ','
				lcVars = SUBSTR(m.lcVars, 2)
				lcValues = SUBSTR(m.lcValues, 2)

				THIS.save_ini("TaskList", "Name", .cTaskName, m.lcVars, m.lcValues)
			ENDIF
		ENDWITH
#IF !_DEVELOP_MODE
	CATCH TO loExc
		THIS.oFunction.showErrMsg(m.loExc)
	ENDTRY
#ENDIF
ENDPROC
PROCEDURE setenvironment
LPARAMETERS tnDataSessionId as Integer
	IF VARTYPE(m.tnDataSessionId) <> 'N'
		tnDataSessionId = 0
	ELSE
		IF m.tnDataSessionId <> 0
			SET DATASESSION TO m.tnDataSessionId
		ENDIF
	ENDIF

	SET ANSI OFF
	SET CENTURY ON
	SET SYSFORMATS ON
	SET DATE DMY
	SET SECONDS ON
	SET HOURS TO 24 
	SET EXCLUSIVE OFF
	SET EXACT OFF
	SET TALK OFF
	SET SAFETY OFF
	SET COMPATIBLE OFF
	SET NOTIFY OFF
	SET CONFIRM ON
	SET DELETE ON
	SET NEAR ON
	SET POINT TO '.'
	SET DECIMAL TO 6
	SET MULTILOCKS ON
	SET ESCAPE OFF
	SET STATUS BAR OFF
	SET ECHO OFF
*!*		SET NULL ON

	IF m.tnDataSessionId <> 0
		SET DATASESSION TO THIS.nDataSessionId
	ENDIF
ENDPROC
PROCEDURE showmsg
LPARAMETERS tcMsg as String
LOCAL loPanelMsg as _messages OF ..\lib.9\base_app, lnI as Integer,;
	  llfou as Logical, loExc as Exception
	TRY
		FOR lnI = 1 TO _Screen.FormCount
			IF _Screen.Forms[m.lnI].Class == "_messages"
				llfou = .T.

				EXIT
			ENDIF
		ENDFOR
	CATCH TO loExc
		THIS.oFunction.showErrMsg(m.loExc)
	ENDTRY

	IF m.llfou
		loPanelMsg = _Screen.Forms[m.lnI]
	ELSE
		loPanelMsg = CREATEOBJECT("_messages")
*!*			
*!*			IF !THIS.oVars.lTaskBar
*!*			*т.к. сообщения не ловим - то добавить в коллекцию руками
*!*				THIS.AddObject(m.loPanelMsg)
*!*			ENDIF

		m.loPanelMsg.Show()
	ENDIF

	loPanelMsg.MsgTxt = m.tcMsg
ENDPROC
PROCEDURE stop
	ON SHUTDOWN

	IF TYPE("m.goApp") = 'O'
		m.goApp.Release()
		RELEASE m.goApp
	ENDIF

	ON ERROR err = .t.
*!*		CLEAR ALL
	SET STATUS BAR ON
	SET MESSAGE TO
	SET BELL ON
	POP KEY ALL
	RESTORE MACROS
	SET CLASSLIB TO
	SET SYSMENU TO DEFAULT
	ON ERROR
	CLEAR EVENTS

	IF _VFP.StartMode = 0
		CANCEL
	ELSE
		QUIT
	ENDIF
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
7[END RESERVED2]
[START RESERVED3]
*addwindow 
*go 
*goform 
*gomenu 
*goproc 
*handlewinmsg 
*load_ini 
*loadevent 
*loadsettings 
*login 
*logout 
*onmenuevents 
*release Releases a FormSet or Form from memory.
*releaseevent 
*removedll 
*removewindow 
*save_ini 
*savesettings 
*setenvironment 
*showmsg 
*stop 
_memberdata XML Metadata for customizable properties
ndatasessionid
otaskbar
otoolbar
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\factory.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\factory.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1PJ0VMLBI
[CLASS] base_collection
[CLASSLOC] base_gui.vcx
[BASECLASS] collection
[OBJNAME] oapp_collection
[PARENT] base_app
[START PROPERTIES]
Left = 8
Name = "oapp_collection"
Top = 64
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1PJ0U50MI
[CLASS] base_timer
[CLASSLOC] base_gui.vcx
[BASECLASS] timer
[OBJNAME] oApp_timer
[PARENT] base_app
[START PROPERTIES]
Enabled = .F.
Interval = 10000
Left = 8
Name = "oApp_timer"
Top = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Timer
#INCLUDE ..\lib.9\base_idb.h
LOCAL loSql as Object, lcCursorName as String, llResult as Logical,;
	  lcOldAlias as String, lcUserName as String, lnIdUser as Integer,;
	  lcSql as String, lnIdSession as Integer
	WITH THIS.Parent
		IF !ISNULL(.oVars.TimeTerminate) AND DATETIME() >= .oVars.TimeTerminate
			KEYBOARD "{ALT+F4}"
		ENDIF

		IF !ISNULL(.oVars.oCurrentTask) AND !ISNULL(.oVars.oDBConnect) AND .oVars.oDBConnect.lock()
			THIS.Enabled = .F.
			lcOldAlias = ALIAS()
			loSql = NEWOBJECT("dbsql", "..\lib.9\base_idb", "", .oVars.oDBConnect)
			lcCursorName = SYS(2015)
			lnIdSession = .oVars.oCurrentTask.nIDSession

			DO CASE
			CASE .oVars.oCurrentTask.oVars.nDBType = DB_FoxPro
			CASE .oVars.oCurrentTask.oVars.nDBType = DB_PostgreSQL
				llResult = m.loSql.execute("SELECT * FROM " + .oVars.oCurrentTask.oVars.cDBSchema;
										   + ".get_messages_to(" + TRANSFORM(.oVars.oCurrentTask.nIDSession) + ", 'L')",;
										   m.lcCursorName)
			CASE .oVars.oCurrentTask.oVars.nDBType = DB_MSSQL
			CASE .oVars.oCurrentTask.oVars.nDBType = DB_Oracle
			OTHERWISE
				llResult = .F.
			ENDCASE

			IF m.llResult
				SELECT (m.lcCursorName)

				SCAN
					lnIdSession = ID_Session_From

					DO CASE
					CASE .oVars.oCurrentTask.oVars.nDBType = DB_FoxPro
					CASE .oVars.oCurrentTask.oVars.nDBType = DB_PostgreSQL
TEXT TO m.lcSql NOSHOW TEXT
SELECT NAME
FROM <<.oVars.oCurrentTask.oVars.cDBSchema>>.View_Users
WHERE ID = (SELECT ID_User
		  FROM <<.oVars.oCurrentTask.oVars.cDBSchema>>.Sessions
		  WHERE ID = <<TRANSFORM(ID_Session_From)>>)
ENDTEXT

						llResult = m.loSql.execute(m.lcsql, m.lcCursorName + "_u")
					CASE .oVars.oCurrentTask.oVars.nDBType = DB_MSSQL
					CASE .oVars.oCurrentTask.oVars.nDBType = DB_Oracle
					ENDCASE

					IF m.llResult
						lcUserName = ALLTRIM(EVALUATE(m.lcCursorName+"_u.NAME")) + " : "
						USE IN (m.lcCursorName + "_u")

						SELECT (m.lcCursorName)
					ELSE
						lcUserName = ''
					ENDIF

					DO CASE
					CASE TYPEMSG = 'M'
					*вывести мессагу
						.showMsg("Сообщение от " + m.lcUserName + ALLTRIM(MESSAGE))
						.oWinApi.messageBeep()
*						MESSAGEBOX("Сообщение от "+m.lcUserName+CHR(10)+ALLTRIM(MESSAGE), 64, .cTaskCaption)
					CASE TYPEMSG = 'A'
					*закрыть приложение
						LOCAL lnposmes as Integer
						lnposmes = AT("DATETIME:", MESSAGE)

						.TimeTerminate = CTOT(SUBSTRC(MESSAGE, m.lnposmes + 9, 16))

						.showMsg(m.lcUserName + MSG_ALERT_EXIT + " " + TTOC(.oVars.nTimeTerminate, 2) + "! "+SUBSTRC(MESSAGE, m.lnposmes + 9 + 18))
						.oWinApi.messageBeep()
					CASE TYPEMSG = 'C'
					ENDCASE
				ENDSCAN

				USE IN (m.lcCursorName)
			ENDIF

			RELEASE m.loSql

			IF !EMPTY(m.lcOldAlias)
				SELECT (m.lcOldAlias)
			ENDIF

			.oVars.oDBConnect.unLock()
			THIS.Enabled = .T.
		ENDIF
	ENDWITH
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0KYGSG
[CLASS] cstfunction
[CLASSLOC] base_app.vcx
[BASECLASS] custom
[OBJNAME] oFunction
[PARENT] base_app
[START PROPERTIES]
Left = 72
Name = "oFunction"
Top = 8
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QC0CNAY3
[CLASS] base_collection
[CLASSLOC] base_gui.vcx
[BASECLASS] collection
[OBJNAME] oTaskList
[PARENT] base_app
[START PROPERTIES]
Left = 40
Name = "oTaskList"
Top = 64
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0BT33K
[CLASS] cstwinapi
[CLASSLOC] base_app.vcx
[BASECLASS] custom
[OBJNAME] oWinApi
[PARENT] base_app
[START PROPERTIES]
Left = 40
Name = "oWinApi"
Top = 8
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1PJ0VS2Y9
[CLASS] xml_ini
[CLASSLOC] xml_ini.vcx
[BASECLASS] custom
[OBJNAME] oXml_ini
[PARENT] base_app
[START PROPERTIES]
Height = 17
Left = 8
Name = "oXml_ini"
Top = 32
Width = 24
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] base_app

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM01C8TQ
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] basetuningbar
[START PROPERTIES]
Enabled = .F.
Height = 44
Left = 0
Name = "basetuningbar"
Top = 0
Width = 48
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM01FW5W
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdBaseTuning
[PARENT] basetuningbar
[START PROPERTIES]
Left = 5
Name = "cmdBaseTuning"
Picture = ..\bmp\preferences.ico
ToolTipText = "Базовые настройки программы"
Top = 3
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
m.goApp.goForm("base_tuning", 0, .NULL., .NULL.)
*!*	m.goApp.goForm("FORMS\base_tuning", 0, .NULL., .NULL.)
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] basetuningbar
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0SZ0L98A3
[CLASS] custom
[BASECLASS] custom
[OBJNAME] cstfunction
[START PROPERTIES]

Name = "cstfunction"
Width = 20
_memberdata =     2531<VFPData><memberdata name="addprinter" type="method" display="addPrinter"/><memberdata name="colortorgb" type="method" display="colorToRGB"/><memberdata name="directorytoarray" type="method" display="directoryToArray"/><memberdata name="erasefile" type="method" display="eraseFile"/><memberdata name="fddformat" type="method" display="fddFormat"/><memberdata name="getfileattributes" type="method" display="getFileAttributes"/><memberdata name="getfilesize" type="method" display="getFileSize"/><memberdata name="getwordcount" type="method" display="getWordCount"/><memberdata name="getwordnum" type="method" display="getWordNum"/><memberdata name="hextodec" type="method" display="hexToDec"/><memberdata name="isfileequal" type="method" display="isFileEqual"/><memberdata name="isfileused" type="method" display="isFileUsed"/><memberdata name="ispicturevalid" type="method" display="isPictureValid"/><memberdata name="longtostring" type="method" display="longToString"/><memberdata name="monthbetween" type="method" display="monthBetween"/><memberdata name="pixeltofoxel" type="method" display="pixelToFoxel"/><memberdata name="pixeltotwip" type="method" display="pixelToTwip"/><memberdata name="playwav" type="method" display="playWav"/><memberdata name="spelling" type="method" display="spelling"/><memberdata name="writelogfile" type="method" display="writeLogFile"/><memberdata name="div" type="method" display="div"/><memberdata name="closeallwindows" type="method" display="closeAllWindows"/><memberdata name="arraypointer" type="method" display="arrayPointer"/><memberdata name="transform_my" type="method" display="transform_my"/><memberdata name="showerrmsg" type="method" display="showErrMsg"/><memberdata name="openlog" type="method" display="openLog"/><memberdata name="writelog" type="method" display="writeLog"/><memberdata name="getfont" type="method" display="getFont"/><memberdata name="gettagstring" type="method" display="getTagString"/><memberdata name="divmat" type="method" display="divMat"/><memberdata name="showerrdialog" type="method" display="showErrDialog"/><memberdata name="removedirectory" type="method" display="removeDirectory"/><memberdata name="removefolder" type="method" display="removeFolder"/><memberdata name="resourcetopath" type="method" display="resourceToPath"/><memberdata name="secondtotime" type="method" display="secondToTime"/><memberdata name="showerrdlg" type="method" display="showErrDlg"/><memberdata name="getnextfilename" type="method" display="getNextFileName"/></VFPData>
[END PROPERTIES]
[START METHODS]
PROCEDURE addprinter
* ADD PRINTER WIZARD

RUN /N rundll32.exe shell32.dll, SHHelpShortcuts_RunDLL AddPrinter

ENDPROC
PROCEDURE arraypointer
LPARAMETERS tcArray
RETURN @&tcArray
ENDPROC
PROCEDURE closeallwindows
LOCAL loExc as Exception, loI as Object
	FOR EACH loI IN _Screen.Forms
		TRY 
			m.loI.Release()
		CATCH TO loExc
			THIS.ShowErrMsg(m.loExc)
		ENDTRY
	ENDFOR
	
*!*	LOCAL lncntobj, lnobj, loExc as Exception, loI as Object
*!*		lncntobj=_Screen.FormCount
*!*		lnobj=1
*!*		DO WHILE m.lncntobj>0
*!*			TRY 
*!*				IF TYPE("_Screen.Forms")='O' AND _Screen.Forms[m.lnobj].BaseClass="Form"
*!*					_Screen.Forms[m.lnobj].Release()
*!*				ELSE
*!*					_Screen.Objects[m.lnobj].Release()

*!*					lnobj=m.lnobj+1
*!*				ENDIF
*!*			CATCH TO loExc
*!*				THIS.ShowErrMsg(m.loExc)
*!*			ENDTRY

*!*			lncntobj=m.lncntobj-1
*!*		ENDDO
ENDPROC
PROCEDURE colortorgb
* LOCAL lnRed, lnGreen, lnBlue
* This.ColorToRGB(256*256*256-1, @lnRed, @lnGreen, @lnBlue)
* DEBUGOUT lnRed, lnGreen, lnBlue -> 255, 255, 255
LPARAMETERS tnColor AS Integer, vnRed AS Byte, vnGreen AS Byte, vnBlue AS Byte
LOCAL lcHexadecimal
	lcHexadecimal = SUBSTR(TRANSFORM(m.tnColor, '@0'), 5)
	vnRed = EVALUATE('0x' + RIGHT(m.lcHexadecimal, 2))
	vnGreen = EVALUATE('0x' + SUBSTR(m.lcHexadecimal, 3, 2))
	vnBlue = EVALUATE('0x' + LEFT(m.lcHexadecimal, 2))

*!* ВАРИАНТ 1
*!*	R  =  MOD(INT(RGB(...)/(256^0)),256)
*!*	G  =  MOD(INT(RGB(...)/(256^1)),256)
*!*	B  =  MOD(INT(RGB(...)/(256^2)),256)

*!* ВАРИАНТ 2
*!*	vnBlue  =  INT(tnColor/(256^2))
*!*	tnColor  =  MOD(tnColor,(256^2))
*!*	vnGreen  =  INT(tnColor/256)
*!*	vnRed  =  MOD(tnColor,256)

ENDPROC
PROCEDURE complexperc
* РАСЧЕТ СЛОЖНОГО ПРОЦЕНТА (%% НА %%)
LPARAMETERS tnPerc, tnPeriod, tnRegim	&& Ставка, Периодичность в месяцах, Режим
LOCAL llClnd, llLeap, lnYear, lnSumm, lnBase, lnCount, lnDays
	IF m.tnPerc <= 0 OR 12 % m.tnPeriod # 0 OR !BETWEEN(m.tnRegim,1,3)
		RETURN -1							&& Периодичность начислений : 1, 2, 3, 4, 6, 12
	ENDIF 									&& Режимы 1-360 бнк.дн, 2-365 кал.дн, 3-366 кал.дн

	llClnd = m.tnRegim <> 1					&& Календарность
	llLeap = m.tnRegim = 3					&& Високосность
	lnYear = IIF(m.llLeap, 2000, 1999)		&& Ломы делать массив - пусть перевычисляет ;)
	lnSumm = 0								&& Начислено за период
	lnBase = 1								&& База для начислений в рублях (остаток)

	FOR lnCount = 1 TO 12 / m.tnPeriod
		lnDays = IIF(!m.llClnd,;
					 m.tnPeriod * 30,;
					 GOMONTH(CTOD('01/' + TRANSFORM(m.lnCount * m.tnPeriod, '@L 99') + '/';
					 			  + TRANSFORM(m.lnYear, '@L 9999')), 1) - CTOD('01/';
					 + TRANSFORM((m.lnCount - 1) * tnPeriod + 1, '@L 99') + '/';
					 + TRANSFORM(m.lnYear, '@L 9999')))
		lnSumm = m.lnBase * m.tnPerc * m.lnDays / IIF(!m.llClnd, 360, IIF(m.llLeap, 366, 365)) / 100
		lnBase = m.lnBase + m.lnSumm
	ENDFOR
RETURN m.lnBase * 100 - 100

ENDPROC
PROCEDURE copyfile
* КОПИРОВАНИЕ ФАЙЛА ВМЕСТЕ С АТРИБУТАМИ И ВОЗМОЖНОСТЬЮ ПЕРЕЗАПИСИ
* ПАРАМЕТРЫ : ФАЙЛ-ИСТОЧНИК, ФАЙЛ-ПРИЕМНИК, РЕЖИМ ПЕРЕЗАПИСИ
* РЕЗУЛЬТАТ : ПУСТАЯ СТРОКА ИЛИ СТРОКА С СООБЩЕНИЕМ ОБ ОШИБКЕ
LPARAMETERS tcSourceFile AS String, tcTargetFile AS String, tlOverwrite AS Logical
	ASSERT VARTYPE(m.tcSourceFile) = 'C' AND VARTYPE(m.tcTargetFile) = 'C' AND VARTYPE(m.tlOverwrite) = 'L'
	* ЕСЛИ ФАЙЛ-ИСТОЧНИК СУЩЕСТВУЕТ
	IF FILE(m.tcSourceFile, 1)
		* СКОПИРУЕМ ВМЕСТЕ С АТРИБУТАМИ
		IF This.Parent.oWinAPI.CopyFile(m.tcSourceFile, m.tcTargetFile, m.tlOverwrite)
			RETURN ''
		ENDIF
		* ОШИБКА КОПИРОВАНИЯ ФАЙЛА
		RETURN MSG_FILECOPYERROR + CHR_CR + m.tcSourceFile + ' -> ' + m.tcTargetFile
	ENDIF
* НЕ НАЙДЕН ФАЙЛ
RETURN MSG_FILENOTFOUND + CHR_CR + m.tcSourceFile

ENDPROC
PROCEDURE copyproperties
* ДОБАВИМ И ПРИСВОИМ СВОЙСТВА КОНТЕЙНЕРУ
* This.CopyProperties(loSource, loTarget)
LPARAMETERS toSource AS Object, toTarget AS Object
LOCAL lcProperty AS String, luValue AS Variant
LOCAL ARRAY laProperty[1]
* ВЫБЕРЕМ В МАССИВ ТОЛЬКО СВОЙСТВА
	ASSERT VARTYPE(m.toSource) = 'O' AND VARTYPE(m.toTarget) = 'O'
	AMEMBERS(laProperty, m.toSource)

	FOR EACH lcProperty IN laProperty
		* ВЫЧИСЛИМ ЗНАЧЕНИЕ СВОЙСТВА ОБЪЕКТА-ИСТОЧНИКА
		luValue = EVALUATE('toSource.' + m.lcProperty)

		IF VARTYPE(m.luValue) = 'C'
			luValue = ALLTRIM(m.luValue)
		ENDIF
		* ЕСЛИ У ЦЕЛЕВОГО ОБЪЕКТА НЕТ ТАКОГО СВОЙСТВА
		IF !PEMSTATUS(m.toTarget, m.lcProperty, 5)
			* ДОБАВИМ СВОЙСТВО И ПРИСВОИМ ЗНАЧЕНИЕ
			toTarget.AddProperty(m.lcProperty, m.luValue)
		ELSE
			* ПЕРЕПРИСВОИМ ЗНАЧЕНИЕ, ЕСЛИ НЕ READONLY
			IF !PEMSTATUS(m.toTarget, m.lcProperty, 1)
				toTarget.&lcProperty = m.luValue
			ENDIF
		ENDIF
	ENDFOR

ENDPROC
PROCEDURE cryptkey
* ОБРАТИМОЕ ШИФРОВАНИЕ XOR ПО СТРОКОВОМУ КЛЮЧУ.
* МАКСИМАЛЬНУЮ КРИПТОСТОЙКОСТЬ ДАЕТ КЛЮЧ, СОСТОЯЩИЙ ИЗ СЛУЧАЙНОГО
* НАБОРА ASCII СИМВОЛОВ И РАВНЫЙ ПО ДЛИНЕ ШИФРУЕМОЙ СТРОКЕ.
* НАПРИМЕР КОГДА СТРАНИЦУ РУССКОГО ТЕХНИЧЕСКОГО ТЕКСТА
* ШИФРУЕМ СТРАНИЦЕЙ ИЗ РОМАНА НА АНГЛИЙСКОМ ЯЗЫКЕ ;)
* CryptKey([#;-=!'], 'urfin') = 'VIKTOR'
* CryptKey('VIKTOR', 'urfin') = [#;-=!']
LPARAMETERS tcSourceString AS String, tсKeyString AS String
LOCAL lсCryptString AS String, lnKeyPosition AS Integer, lnSourcePosition AS Integer
	ASSERT VARTYPE(m.tcSourceString) = 'C' AND VARTYPE(m.tсKeyString) = 'C'
	lсCryptString = ''

	IF LEN(m.tcSourceString) > 0
		lnKeyPosition = 1

		FOR lnSourcePosition = 1 TO LEN(m.tcSourceString)
			lсCryptString = m.lсCryptString;
							+ CHR(BITXOR(ASC(SUBSTR(m.tcSourceString, m.lnSourcePosition, 1)),;
								  		 ASC(SUBSTR(m.tсKeyString, m.lnKeyPosition, 1))))
			lnKeyPosition = IIF(m.lnKeyPosition = LEN(m.tсKeyString), 1, m.lnKeyPosition + 1)
		ENDFOR
	ENDIF
RETURN m.lсCryptString
ENDPROC
PROCEDURE cryptxor
* ПРОСТЕЙШАЯ ОБРАТИМАЯ ШИФРОВКА XOR БЕЗ КЛЮЧА 
* CryptXor('VIKTOR')) = 'WKHPJT'
* CryptXor('WKHPJT')) = 'VIKTOR'
LPARAMETERS tcString AS String
	ASSERT VARTYPE(tcString) = 'C'
	LOCAL lnCount AS Integer, lcResult AS String
	lcResult = ''

	FOR lnCount = 1 to LEN(m.tcString)
		lcResult = m.lcResult + CHR(BITXOR(MOD(m.lnCount, 255), ASC(SUBS(m.tcString, m.lnCount, 1))))
	ENDFOR
RETURN m.lcResult

ENDPROC
PROCEDURE datetostring
* ДАТА СТРОКОЙ
* StrDate(ldDate)			- ДАТА + МЕСЯЦ + ГОД = SET DATE LONG
* StrDate(ldDate, .T., .T.)	- МЕСЯЦ + ГОД
* StrDate(ldDate, .T.)		- ТОЛЬКО МЕСЯЦ
* StrDate(ldDate, .F., T.)	- ТОЛЬКО ГОД
LPARAMETERS tdDate AS Date, tlMonth AS Logical, tlYear AS Logical
	IF VARTYPE(m.tdDate) = 'D' AND m.tdDate <> {}
		IF !tlMonth AND m.tlYear				&& ТОЛЬКО ГОД
			RETURN TRANSFORM(YEAR(m.tdDate)) + ' г.'
		ELSE
			LOCAL lnMonth AS Integer, lcString AS String
			lnMonth = MONTH(m.tdDate)                   

			DO CASE
			CASE m.lnMonth = 01
				lcString = 'январ'	+ IIF(m.tlMonth, 'ь', 'я')
			CASE m.lnMonth = 02
				lcString = 'феврал'	+ IIF(m.tlMonth, 'ь', 'я')
			CASE m.lnMonth = 03
				lcString = 'март'	+ IIF(m.tlMonth, '',  'а')
			CASE m.lnMonth = 04
				lcString = 'апрел'	+ IIF(m.tlMonth, 'ь', 'я')
			CASE m.lnMonth = 05
				lcString = 'ма'		+ IIF(m.tlMonth, 'й', 'я')
			CASE m.lnMonth = 06
				lcString = 'июн'	+ IIF(m.tlMonth, 'ь', 'я')
			CASE m.lnMonth = 07
				lcString = 'июл'	+ IIF(m.tlMonth, 'ь', 'я')
			CASE m.lnMonth = 08
				lcString = 'август'	+ IIF(m.tlMonth, '',  'а')
			CASE m.lnMonth = 09
				lcString = 'сентябр'+ IIF(m.tlMonth, 'ь', 'я')
			CASE m.lnMonth = 10
				lcString = 'октябр'	+ IIF(m.tlMonth, 'ь', 'я')
			CASE m.lnMonth = 11
				lcString = 'ноябр'	+ IIF(m.tlMonth, 'ь', 'я')
			CASE m.lnMonth = 12
				lcString = 'декабр'	+ IIF(m.tlMonth, 'ь', 'я')
			ENDCASE

			DO CASE
			CASE !m.tlMonth AND !m.tlYear		&& ДАТА + МЕСЯЦ + ГОД
				RETURN LTRIM(STR(DAY(m.tdDate))) + ' ' + m.lcString + ' ';
					   + TRANSFORM(YEAR(m.tdDate)) + ' г.'
			CASE m.tlMonth AND m.tlYear		&& МЕСЯЦ + ГОД
				RETURN m.lcString + ' ' + TRANSFORM(YEAR(m.tdDate)) + ' г.'
			OTHERWISE						&& ТОЛЬКО МЕСЯЦ
				RETURN m.lcString
			ENDCASE
		ENDIF
	ENDIF
RETURN ''
ENDPROC
PROCEDURE dectohex
* DEC -> HEX
* 15			-> '0000000F'
* 4294967295	-> 'FFFFFFFF'
LPARAMETERS lnDecimal AS Integer
	ASSERT VARTYPE(m.lnDecimal) = 'N'
	ASSERT BETWEEN(m.lnDecimal, -TYPE_INTEGER, TYPE_INTEGER)
RETURN SUBSTR(TRANSFORM(m.lnDecimal, '@0'), 3)
ENDPROC
PROCEDURE directorytoarray
* ДОПОЛНИМ МАССИВ TAFILENAME ИМЕНАМИ ФАЙЛОВ,
* УДОВЛЕТВОРЯЮЩИХ МАСКЕ TCPATHFILEMASK
* РЕЗУЛЬТАТ - КОЛИЧЕСТВО ДОБАВЛЕННЫХ ЭЛЕМЕНТОВ МАССИВА
* LOCAL ARRAY laFileName[1] && Массив имен файлов
* This.DirectoryToArray(@laFileName, lcPath + '*.DBF')
* P.S. ПРИМЕНЯЕТСЯ РЕДКО ИЛИ НИКОГДА ;)
LPARAMETERS taFileName, tcPathFileMask AS String, tcAttribute AS String
LOCAL lnFileCount AS Integer, lnArraySize AS Integer
LOCAL ARRAY laDirectory[1, 5]
	ASSERT TYPE('taFileName', 1) = 'A'
	tcPathFileMask = IIF(VARTYPE(m.tcPathFileMask) = 'C',;
						 m.tcPathFileMask,;
						 FULLPATH('') + '*.*')
	tcAttribute = IIF(VARTYPE(m.tcAttribute) = 'C', m.tcAttribute, "HS")
	lnArraySize = IIF(VARTYPE(m.taFileName) = 'C', ALEN(taFileName, 1), 0)

	FOR lnFileCount = 1 TO ADIR(laDirectory, m.tcPathFileMask, m.tcAttribute)
		DIMENSION taFileName[m.lnArraySize + m.lnFileCount]
		taFileName[m.lnArraySize + m.lnFileCount] = laDirectory[m.lnFileCount, 1]
	ENDFOR
RETURN m.lnFileCount - 1
ENDPROC
PROCEDURE div
*деление с учетом граничных ситуаций
LPARAMETERS tn1, tn2
LOCAL lnResult
	IF m.tn2 = 0
		RETURN .0
	ELSE
		RETURN m.tn1 / m.tn2
	ENDIF
RETURN m.lnResult
ENDPROC
PROCEDURE divmat
*деление с учетом граничных ситуаций(по матматике)
LPARAMETERS tn1, tn2
LOCAL lnResult
	TRY
		lnResult = m.tn1 / m.tn2
	CATCH
		lnResult = 9999999999999999999.
	ENDTRY
RETURN m.lnResult
ENDPROC
PROCEDURE erasefile
* УДАЛЕНИЕ ФАЙЛА C ПРЕДВАРИТЕЛЬНЫМ СНЯТИЕМ АТРИБУТОВ R/S/H
* РЕЗУЛЬТАТ : ПУСТАЯ СТРОКА ИЛИ СТРОКА С СООБЩЕНИЕМ ОБ ОШИБКЕ
LPARAMETERS tcPathFile AS String
LOCAL lcMessage AS String
*!*		ASSERT VARTYPE(m.tcPathFile) = 'C'
	lcMessage = ''

	IF FILE(m.tcPathFile, 1)
		* ВЫСТАВИМ АТРИБУТ NORMAL
		IF This.Parent.oWinAPI.SetAttributes(m.tcPathFile)
			TRY
				* УДАЛИМ ФАЙЛ
				ERASE (m.tcPathFile)
			CATCH
				* ОШИБКА УДАЛЕНИЯ ФАЙЛА
				lcMessage = MSG_FILEERASEERROR + CHR_CR + m.tcPathFile
			ENDTRY
		ELSE
			* ОШИБКА УСТАНОВКИ АТРИБУТОВ ФАЙЛА
			lcMessage = MSG_FILESETATTRERROR + CHR_CR + m.tcPathFile
		ENDIF
	ENDIF
RETURN m.lcMessage
ENDPROC
PROCEDURE fddformat
* FORMAT FLOPPY DRIVE (НЕ ПАШЕТ ПОД XP)

RUN /N rundll32.exe shell32.dll, SHFormatDrive
ENDPROC
PROCEDURE getbias
* РАЗНИЦА В МИНУТАХ МЕЖДУ COORDINATED UNIVERSAL TIME (UTC) AND LOCAL TIME 
* PS1 : ДЛЯ ОМСКА = - 360 МИНУТ
* PS2 : UTC = LOCAL TIME + BIAS 

RETURN This.StringToLong(LEFT(This.Parent.oWinApi.GetTimeZoneInformation(), 4))
ENDPROC
PROCEDURE getfileattributes
* ВОЗВРАЩАЕТ СТРОКУ С АТРИБУТАМИ ФАЙЛА ИЛИ КАТАЛОГА
* НАПРИМЕР 'RASHD' ИЛИ '.....', ИЛИ ПУСТУЮ СТРОКУ,
* ЕСЛИ ФАЙЛ ИЛИ КАТАЛОГ НЕ НАЙДЕН
LPARAMETERS tcPathFileOrFolderName AS String
LOCAL ARRAY laDir[1, 5]
	IF ADIR(laDir, m.tcPathFileOrFolderName, 'SHD') = 1
		RETURN laDir[1, 5]
	ELSE
		RETURN ''
	ENDIF

ENDPROC
PROCEDURE getfilesize
* РАЗМЕР ФАЙЛА В БАЙТАХ
* ЕСЛИ ФАЙЛ НЕ НАЙДЕН ВОЗВРАЩАЕТ -1
LPARAMETERS lcPathName AS Character
ASSERT VARTYPE(m.lcPathName) = 'C'
LOCAL lcCompatible, lnFileSize
	lnFileSize = -1

	IF FILE(m.lcPathName, 1)
		lcCompatible = SET('COMPATIBLE')
		SET COMPATIBLE ON
		lnFileSize = FSIZE(m.lcPathName)
		SET COMP &lcCompatible
	ENDIF
RETURN m.lnFileSize
ENDPROC
PROCEDURE getfont
* ВЫБОР И=ТАНОВКА ШРИФТА ДЛЯ ОБЪЕКТА loObject ИЛИ АКТИВНОГО
LPARAMETERS loObject AS Object
LOCAL lcGetFont AS String
	IF VARTYPE(m.loObject) <> 'O'
		IF TYPE('Application.ActiveForm.ActiveControl') <> 'O'
			RETURN
		ELSE
			loObject = Application.ActiveForm.ActiveControl
		ENDIF
	ENDIF

	IF PEMSTATUS(m.loObject, 'FontName', 5)
		* НАЗВАНИЕ, РАЗМЕР, СТИЛЬ
		WITH loObject
			lcGetFont = GETFONT(.FontName, .FontSize,;
								IIF(.FontBold,'B','') + IIF(.FontItalic,'I',''))

			IF !EMPTY(m.lcGetFont)
				.FontName = GETWORDNUM(m.lcGetFont, 1, ',')
				.FontSize = VAL(GETWORDNUM(m.lcGetFont, 2, ','))
				.FontBold = 'B' $ GETWORDNUM(m.lcGetFont, 3, ',')
				.FontItalic = 'I' $ GETWORDNUM(m.lcGetFont, 3, ',')
			ENDIF
		ENDWITH
	ENDIF

ENDPROC
PROCEDURE getgdiguiddescription
* КРАТКАЯ ИЛИ ПОЛНАЯ РАСШИФРОВКА GDIPLUS GUID
* ПАРАМЕТРЫ : СТРОКА VARBINARY 16, КРАТКАЯ ИЛИ ПОЛНАЯ РАСШИФРОВКА
LPARAMETERS tqGUID AS Variant, tlFullDescription AS Logical
	DO CASE
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_BMP
		RETURN IIF(!m.tlFullDescription, 'BMP', 'Windows bitmap format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_JPEG
		RETURN IIF(!m.tlFullDescription, 'JPG', 'Joint Photographic Experts Group format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_GIF
		RETURN IIF(!m.tlFullDescription, 'GIF', 'Graphics Interchange Format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_ICON
		RETURN IIF(!m.tlFullDescription, 'ICO', 'Icon format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_TIFF
		RETURN IIF(!m.tlFullDescription, 'TIF', 'Tag Image File Format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_PNG
		RETURN IIF(!m.tlFullDescription, 'PNG', 'Portable Network Graphics format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_WMF
		RETURN IIF(!m.tlFullDescription, 'WMF', 'Windows Metafile format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_EMF
		RETURN IIF(!m.tlFullDescription, 'EMF', 'Enhanced Metafile format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_EXIF
		RETURN IIF(!m.tlFullDescription, 'JPE', 'Exchangeable Image File format')	&& Exif is a variation of JPEG, used by almost all digital cameras
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_MEMORYBMP
		RETURN IIF(!m.tlFullDescription, 'BMP', 'Image was constructed from a memory bitmap')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_UNDEFINED
		RETURN IIF(!m.tlFullDescription, '', 'GDI+ is unable to determine the format')
	OTHERWISE
		RETURN IIF(!m.tlFullDescription, '', 'GDI+ GUID not recognized')
	ENDCASE

ENDPROC
PROCEDURE getimageinformation
* СТРОКА С ИНФОРМАЦИЕЙ О ФАЙЛЕ С ИЗОБРАЖЕНИЕМ
LPARAMETERS tcPathFileExt AS String
LOCAL lcInfo AS String, lnSize AS String
	ASSERT VARTYPE(m.tcPathFileExt) = 'C'

	IF !FILE(m.tcPathFileExt)
		* НЕ НАЙДЕН ФАЙЛ
		RETURN MSG_FILENOTFOUND
	ENDIF

	WITH This.Parent
		IF !EMPTY(.oWinAPI.GdipGetImageRawFormat(m.tcPathFileExt))
			* РАЗМЕР В ПИКСЕЛЯХ
			lcInfo = TRANSFORM(.oWinAPI.GdipGetImageWidth(m.tcPathFileExt))
			lcInfo = m.lcInfo + 'x' + TRANSFORM(.oWinAPI.GdipGetImageHeight(m.tcPathFileExt))
			* РАЗМЕР В БАЙТАХ
			lnSize = This.GetFileSize(m.tcPathFileExt)

			DO CASE
			CASE m.lnSize < 1024
				lcInfo = m.lcInfo + ' ' + TRANSFORM(m.lnSize) + ' Byte'
			CASE m.lnSize < 1024 * 1024
				lcInfo = m.lcInfo + ' ' + TRANSFORM(ROUND(m.lnSize / 1024, 0)) + ' Kb.'
			CASE m.lnSize < 1024 * 1024 * 1024
				lcInfo = m.lcInfo + ' ' + TRANSFORM(ROUND(m.lnSize / 1024 / 1024, 0)) + ' Mb.'
			OTHERWISE
				lcInfo = m.lcInfo + ' ' + TRANSFORM(ROUND(m.lnSize / 1024 / 1024 / 1024, 0)) + ' Gb.'
			ENDCASE
			* НАЗВАНИЕ ФОРМАТА ИЗОБРАЖЕНИЯ
			RETURN m.lcInfo + ' ' + This.GetGDIGUIDDescription(.oWinAPI.GdipGetImageRawFormat(m.tcPathFileExt), .T.)
		ELSE
			* НЕВЕРНЫЙ ФОРМАТ ИЗОБРАЖЕНИЯ
			RETURN MSG_PICTUREBADFORMAT
		ENDIF
	ENDWITH

ENDPROC
PROCEDURE getnextfilename
*следующее имя файла - добавляет нумератор в конец имени
LPARAMETERS tcFileName
LOCAL lcPath, lcFileName, lcFileExt, lnI
	lcPath = JUSTPATH(m.tcFileName)
	lcFileName = JUSTSTEM(m.tcFileName)
	lcFileExt = JUSTEXT(m.tcFileName)
	lnI = 1

	DO WHILE FILE(m.lcPath + '\' + m.lcFileName + LTRIM(TRANSFORM(m.lnI)) + '.' + m.lcFileExt)
		lnI = m.lnI + 1
	ENDDO
RETURN m.lcPath + '\' + m.lcFileName + LTRIM(TRANSFORM(m.lnI)) + '.' + m.lcFileExt
ENDPROC
PROCEDURE getrandomnumber
* ВОЗВPАЩАЕТ ЦЕЛОЕ ИЗ ИНТЕРВАЛА
* ФУНКЦИЯ ИЗ HELP FPD2.6 - VFP8.0 НЕВЕРНА :
* INT((gnUpper - gnLower + 1) * RAND( ) + gnLower)
LPARAMETERS tnMinimum AS Integer, tnMaximum AS Integer
	ASSERT VARTYPE(m.tnMinimum) = 'N' AND VARTYPE(m.tnMaximum) = 'N'
RETURN ROUND(RAND() * (m.tnMaximum - m.tnMinimum) + m.tnMinimum, 0)

ENDPROC
PROCEDURE gettagstring
*Вынимает строку между заданными тэгами
LPARAMETERS tcString as String, tcTagBegin as String, tcTagEnd as String
LOCAL lnWordCount as Integer
	IF EMPTY(m.tcTagBegin)
		tcTagBegin = ' '
	ENDIF

	IF EMPTY(m.tcTagEnd)
		tcTagEnd = ' '
	ENDIF

	lnWordCount = OCCURS(m.tcDelimiter, m.tcString) + 1

	IF m.lnWordCount = 1 AND LENC(m.tcString) = 0
		lnWordCount = 0
	ENDIF
RETURN m.lnWordCount
ENDPROC
PROCEDURE gettempfile
* VFP TEMP FOLDER + УНИКАЛЬНОЕ ИМЯ ФАЙЛА ПО GUID ДЛИННОЙ 32 БАЙТА + '.TMP'
* НАПРИМЕР : 'C:\WINDOWS\TEMP\96C1E335B6C241C79602295CD99988E3.TMP'
LPARAMETERS tcExtention AS String
	tcExtention = '.' + IIF(VARTYPE(m.tcExtention)='C', ALLTRIM(m.tcExtention), 'tmp')
RETURN ADDBS(SYS(2023)) + This.GetTempName() + m.tcExtention
ENDPROC
PROCEDURE gettempname
* УНИКАЛЬНАЯ СТРОКА ДЛИННОЙ 32 БАЙТА ПО GUID
* НАПРИМЕР : '96C1E335B6C241C79602295CD99988E3'
RETURN CHRTRAN(This.Parent.oWinAPI.GetGuid(), '{-}', '')

ENDPROC
PROCEDURE gettextstringwidth
* ШИРИНА ТЕКСТОВОЙ СТРОКИ В ПИКСЕЛЯХ
* This.GetTextStringWidth('SomeTextString', 'Tahoma', 8, 'N')
LPARAMETERS tcString, tcFontName, tnFontSize, tcFontStyle
	ASSERT VARTYPE(m.tcString) = 'C'
	tcFontName = IIF(VARTYPE(m.tcFontName) = 'C', m.tcFontName, WFONT(1))
	tnFontSize = IIF(VARTYPE(m.tnFontSize) = 'C', m.tnFontSize, WFONT(2))
	tcFontStyle	 =  IIF(VARTYPE(m.tcFontStyle) = 'C', m.tcFontStyle, WFONT(3))
RETURN TXTWIDTH(m.tcString, m.tcFontName, m.tnFontSize, m.tcFontStyle);
	   * FONTMETRIC(6, m.tcFontName, m.tnFontSize, m.tcFontStyle)
ENDPROC
PROCEDURE getwordcount
*Число слов в предложении
LPARAMETERS tcString as String, tcDelimiter as String
LOCAL lnWordCount as Integer
*!*		IF LEN(m.tcString) = 0
*!*			RETURN 1
*!*		ENDIF
	IF EMPTY(m.tcString) OR VARTYPE(m.tcString) <> 'C'
		tcString = ''
	ENDIF

	IF EMPTY(m.tcDelimiter) OR VARTYPE(m.tcDelimiter) <> 'C'
		tcDelimiter = ' '
	ENDIF
	*создадим кешевую переменную
	IF TYPE("THIS.Parent.oVars") = "O"
		WITH THIS.Parent.oVars
			IF TYPE("THIS.Parent.oVars.cGetWords") = "U"
				.AddProperty("cGetWords", '')
				.AddProperty("cGetDelimiter", '')
				.AddProperty("aGetWords[1]")
			ENDIF

			IF .cGetWords == m.tcString AND .cGetDelimiter == m.tcDelimiter
				lnWordCount = ALEN(.aGetWords, 1)
			ELSE
				.cGetWords = m.tcString
				.cGetDelimiter = m.tcDelimiter
				lnWordCount = ALINES(.aGetWords, m.tcString, 2, m.tcDelimiter)
			ENDIF
		ENDWITH
	ENDIF
*!*		lnWordCount = OCCURS(m.tcDelimiter, m.tcString) + 1

*!*		IF m.lnWordCount = 1 AND LENC(m.tcString) = 0
*!*			lnWordCount = 0
*!*		ENDIF
RETURN m.lnWordCount
ENDPROC
PROCEDURE getwordnum
*Вынимает N-ое слово из предложения
LPARAMETERS tcString as String, tnNumWord as Integer, tcDelimiter as String
LOCAL lnCnt as Integer
*!*		lnFirst as Integer, lnSecond as Integer,, lnLenDelim as String;
*!*		  lnLenString as Integer, lcResult as String
	IF EMPTY(m.tcString) OR VARTYPE(m.tcString) <> 'C'
		tcString = ''
	ENDIF

	IF EMPTY(m.tcDelimiter) OR VARTYPE(m.tcDelimiter) <> 'C'
		tcDelimiter = ' '
	ENDIF

	lcResult = ''
	lnCnt = THIS.getWordCount(m.tcString, m.tcDelimiter)

	IF m.lnCnt <> 0 AND m.lnCnt >= m.tnNumWord
		lcResult = THIS.Parent.oVars.aGetWords[m.tnNumWord]
	ENDIF

*!*		IF !(m.tnNumWord=0 OR m.lnLenString=0 OR m.lnLenDelim=0)
*!*			IF m.tnNumWord=1
*!*				lnFirst=1
*!*			ELSE
*!*				lnFirst=ATC(m.tcDelimiter, m.tcString, m.tnNumWord-1)
*!*				lnFirst=IIF(m.lnFirst=0, m.lnLenString, m.lnFirst+m.lnLenDelim)
*!*			ENDIF

*!*			lnSecond=ATC(m.tcDelimiter, m.tcString, m.tnNumWord)
*!*			lnSecond=IIF(m.lnSecond=0, m.lnLenString+m.lnLenDelim, m.lnSecond)

*!*			IF m.lnFirst<>m.lnSecond
*!*				lcResult=SUBSTRC(m.tcString, m.lnFirst, m.lnSecond-m.lnFirst)
*!*			ENDIF
*!*		ENDIF
RETURN m.lcResult
ENDPROC
PROCEDURE hextodec
* HEX -> DEC
* 'F' -> 15
LPARAMETERS lcHexadecimal AS String    						 		&& '0' <= s <= 'FFFFFFFF'
	ASSERT VARTYPE(m.lcHexadecimal) = 'C'
RETURN EVALUATE('0x' + m.lcHexadecimal)

ENDPROC
PROCEDURE isdirectoryreadonly
* ЯВЛЯЕТСЯ ЛИ КАТАЛОГ ДОСТУПНЫМ ДЛЯ ЗАПИСИ ?
LPARAMETERS tcDirectory AS String
LOCAL lcPathFileName AS String
	ASSERT VARTYPE(m.tcDirectory) = 'C'
	lcPathFileName = ADDBS(ALLTRIM(m.tcDirectory)) + This.GetTempName()

	IF FCLOSE(FCREATE(m.lcPathFileName))
		ERASE (m.lcPathFileName)
		RETURN .F.
	ENDIF
ENDPROC
PROCEDURE isfileequal
* РАЗЛИЧАЮТСЯ ЛИ ФАЙЛЫ TCPATHFILE1 И TCPATHFILE2
* ПО ДАТЕ И ВРЕМЕНИ МОДИФИКАЦИИ, РАЗМЕРУ ИЛИ АТРИБУТАМ ?
* P.S. СРАВНИВАЕМ ВРЕМЯ МОДИФИКАЦИИ ФАЙЛА С ТОЧНОСТЬЮ ДО ТРЕХ СЕКУНД !
* (РАСХОЖДЕНИЯ ПОЯВЛЯЮТСЯ ПРИ КОПИРОВАНИИ С FAT16/32 НА NTFS И НАОБОРОТ)
LPARAMETERS tcPathFile1 as String, tcPathFile2 as String
LOCAL ltTime1 as Datetime, ltTime2 as Datetime,;
	lnSize1 as Integer, lnSize2 as Integer,;
	lcAttr1 as String, lcAttr2 as String
LOCAL ARRAY laFile1[1, 5], laFile2[1, 5]
	ASSERT FILE(m.tcPathFile1)
	ASSERT FILE(m.tcPathFile2)
	ADIR(laFile1, m.tcPathFile1, 'HS')
	ADIR(laFile2, m.tcPathFile2, 'HS')
	* ДАТА И ВРЕМЯ
	ltTime1 = CTOD(LEFT(DTOS(laFile1[1, 3]), 4) + '-' + SUBSTR(DTOS(laFile1[1, 3]), 5, 2) +;
				   '-' + RIGHT(DTOS(laFile1[1, 3]), 2) + 'T' + laFile1[1, 4])
	ltTime2 = CTOD(LEFT(DTOS(laFile2[1, 3]), 4) + '-' + SUBSTR(DTOS(laFile2[1, 3]), 5, 2) +;
				   '-' + RIGHT(DTOS(laFile2[1, 3]), 2) + 'T' + laFile2[1, 4])
	* РАЗМЕРЫ
	lnSize1 = laFile1[1, 2]
	lnSize2 = laFile2[1, 2]
	* АТРИБУТЫ
	lcAttr1 = laFile1[1, 5]
	lcAttr2 = laFile2[1, 5]
RETURN ABS(m.ltTime1 - m.ltTime2) < 4 AND m.lnSize1 = m.lnSize2 AND m.lcAttr1 = m.lcAttr2
ENDPROC
PROCEDURE isfileused
* ЕСТЬ ЛИ КАКИЕ ЛИБО ПРИЧИНЫ НЕ ПОЗВОЛЯЮЩИЕ ОТКРЫТЬ ФАЙЛ НА ЗАПИСЬ ?
* (УЖЕ О=ЫТ / ОТКРЫТ ДРУГИМ / НЕТ ФАЙЛА / АТРИБУТ RO И Т.П.)

LPARAMETERS tcFile AS String
LOCAL lnHandle AS Integer
	lnHandle = FOPEN(m.tcFile, 1)
RETURN !(m.lnHandle > 0 AND FCLOSE(m.lnHandle))
ENDPROC
PROCEDURE isinternetconnected
* ПОДКЛЮЧЕН ЛИ КОМПЬЮТЕР К ИНТЕРНЕТУ ?
* 00 - ПОДКЛЮЧЕНИЕ ОТСУТСТВУЕТ
* 16 - RAS УСТАНОВЛЕН
* 32 - РАБОТАЕМ OFFLINE
RETURN !INLIST(This.Parent.oWinAPI.InternetGetConnectedState(), 0, 16, 32, 48)

ENDPROC
PROCEDURE ispicturevalid
* ЯВЛЯЕТСЯ ЛИ СОДЕРЖИМОЕ ФАЙЛА КООРЕКТНЫМ С ТОЧКИ ЗРЕНИЯ GDI+
LPARAMETERS tcPathFileExt AS String
	ASSERT VARTYPE(m.tcPathFileExt)='C'

	IF FILE(m.tcPathFileExt)
		RETURN !EMPTY(This.Parent.oWinAPI.GdipGetImageRawFormat(m.tcPathFileExt))
	ENDIF
RETURN .F.
ENDPROC
PROCEDURE makedirectory
* СОЗДАНИЕ КАТАЛОГА
* РЕЗУЛЬТАТ : ПУСТАЯ СТРОКА ИЛИ СТРОКА С СООБЩЕНИЕМ ОБ ОШИБКЕ
LPARAMETERS tcDirectory AS String
LOCAL lcMessage AS String
	ASSERT VARTYPE(m.tcDirectory)='C'
	lcMessage=''
	* ЕСЛИ КАТАЛОГА НЕТ
	IF !DIRECTORY(m.tcDirectory, 1)
		TRY
			* СОЗДАДИМ КАТАЛОГ
			MKDIR (m.tcDirectory)
		CATCH
			* ОШИБКА СОЗДАНИЯ КАТАЛОГА
			lcMessage = MSG_FOLDERMAKEERROR + CHR_CR + m.tcDirectory
		ENDTRY
	ENDIF
RETURN m.lcMessage

ENDPROC
PROCEDURE makedirectorytree
* СОЗДАНИЕ ЦЕПОЧКИ ВЛОЖЕННЫХ КАТАЛОГОВ (ОБЕРТКА ДЛЯ MKDIR)
* ВСТРОЕННАЯ ФУНКЦИЯ VFP MKDIR ВЫДАЕТ ОШИБКУ - "КАТАЛОГ УЖЕ СУЩЕСТВУЕТ",
* ЕСЛИ ВНУТРИ ЦЕПОЧКИ ПАПОК ЕСТЬ СКРЫТЫЙ КАТАЛОГ И НАДО СОЗДАТЬ ПОСЛЕ НЕГО
* БОЛЕЕ ОДНОГО ВЛОЖЕННОГО ПОДКАТАЛОГА
LPARAMETERS tcDirectory AS String
LOCAL llSuccess AS Logical, lcDirectory AS String, lnCount AS Integer
	ASSERT VARTYPE(m.tcDirectory) = 'C'

	IF !DIRECTORY(m.tcDirectory, 1)
		llSuccess = .T.
		lcDirectory = ''

		FOR lnCount = 1 TO GETWORDCOUNT(m.tcDirectory, '\')
			lcDirectory = m.lcDirectory + GETWORDNUM(m.tcDirectory, m.lnCount, '\') + '\'

			IF !DIRECTORY(m.lcDirectory, 1)
				TRY
					MKDIR (m.lcDirectory)
				CATCH
					llSuccess = .F.
				ENDTRY

				IF !m.llSuccess
					RETURN .F.
				ENDIF
			ENDIF
		ENDFOR
	ENDIF
ENDPROC
PROCEDURE monthbetween
* КОЛИЧЕСТВО МЕСЯЦЕВ МЕЖДУ ДВУМЯ ДАТАМИ
LPARAMETERS tdBegin AS Date, tdEnd AS Date
RETURN 12 * (YEAR(m.tdEnd) - YEAR(m.tdBegin)) + MONTH(m.tdEnd) - MONTH(m.tdBegin)

ENDPROC
PROCEDURE pixeltofoxel
* ПРЕОБРАЗ=НИЕ ПИКСЕЛЕЙ В ФОКСЕЛИ : This.PixelToFoxel(@lnRow, @lnColumn)
* КОЛИЧЕСТВО ПИКСЕЛЕЙ НА ФОКСЕЛЬ ЗАВИСИТ ОТ РАЗРЕШЕНИЯ ЭКРАНА И НАСТРОЕК WINDOWS
* Foxels (A Visual FoxPro term. Equivalent to the maximum height and average width of a character in the current font.)
* Pixels (smallest unit of monitor or printer resolution)
LPARAMETERS tnPix AS Integer, tlY AS Integer
* РЕШЕНИЕ=РОПОРЦИИ ОПРЕДЕЛИМ СКОЛЬКИ ФОКСЕЛЯМ РАВНЫ tnRow И tnColumn ПИКСЕЛЕЙ
	IF m.tlY
		RETURN m.tnPix / FONTMETRIC(1, _Screen.FontName, _Screen.FontSize)
	ELSE
		RETURN m.tnPix / FONTMETRIC(6, _Screen.FontName, _Screen.FontSize)
	ENDIF
ENDPROC
PROCEDURE pixeltotwip
#DEFINE LOGPIXELSX 88 && Logical PIXELS/inch IN X  
#DEFINE LOGPIXELSY 90 && Logical PIXELS/inch IN Y  
LPARAMETERS tсParam
LOCAL lhDC, lnRetVal  
	lnRetVal = 0  

	IF VARTYPE(m.tсParam) = "C" AND !EMPTY(m.tсParam);
	   AND (UPPER(m.tсParam) == "X" OR UPPER(m.tсParam) == "Y")
		tсParam = UPPER(m.tсParam)
	ELSE
		RETURN 0
	ENDIF

	lhDC = THIS.oWinApi.GetDC(_VFP.hWnd)

	IF m.tсParam == "X"
		lnRetVal = 1440 / THIS.oWinApi.GetDeviceCaps(m.lhDC, LOGPIXELSX) &&*(13/FONTMETRIC(1,"MS Sans Serif",8,""))
	ENDIF

	IF m.tсParam == "Y"
		lnRetVal = 1440 / THIS.oWinApi.GetDeviceCaps(m.lhDC, LOGPIXELSY) &&*(11/FONTMETRIC(7,"MS Sans Serif",8,""))
	ENDIF

	THIS.oWinApi.ReleaseDC(_VFP.hWnd, m.lhDC)
RETURN m.lnRetVal
ENDPROC
PROCEDURE playwav
* ПРОИГРАТЬ WAV-ФАЙЛ

LPARAMETERS tcSoundFile
	ASSERT FILE(m.tcSoundFile)
	SET BELL TO (m.tcSoundFile)
	?? CHR(7)

ENDPROC
PROCEDURE pointertolong
* RETURN NUMBER FROM A POINTER TO DWORD
LPARAMETERS tnPointer
LOCAL lcStrDWORD
	lcStrDWORD = REPLICATE(CHR(0), 4)
	* Moves memory either forward or backward, aligned or unaligned, in 4-byte blocks, followed by any remaining bytes
	DECLARE RtlMoveMemory IN Kernel32 STRING @, INTEGER, INTEGER
	RtlMoveMemory(@lcStrDWORD, m.tnPointer, 4)
	CLEAR DLLS 'RtlMoveMemory'
RETURN This.StringToLong(m.lcStrDWORD)
ENDPROC
PROCEDURE pointertostring
* POINTE=O STRING
LPARAMETERS tnPointer
LOCAL lcResult, lnLPStr, lnSLen
	lnLPStr = PointerToLong(m.tnPointer)
	* Moves memory either forward or backward, aligned or unaligned, in 4-byte blocks, followed by any remaining bytes
	DECLARE RtlMoveMemory IN Kernel32 STRING @, INTEGER, INTEGER
	* Retrieves the length of the specified wide string
	DECLARE INTEGER lstrlenW IN Kernel32 INTEGER
	lnSLen = lstrlenW(m.lnLPStr) * 2
	lcResult = REPLICATE(CHR(0), m.lnSLen)
	RtlMoveMemory(@lcResult, m.lnLPStr, m.lnSLen)

	CLEAR DLLS 'lstrlenW', 'RtlMoveMemory'
RETURN STRCONV(STRCONV(m.lcResult, 6), 2)

ENDPROC
PROCEDURE removedirectory
* УДАЛЕНИЕ КАТАЛОГА
* РЕЗУЛЬТАТ : ПУСТАЯ СТРОКА ИЛИ СТРОКА С СООБЩЕНИЕМ ОБ ОШИБКЕ
LPARAMETERS tcDirectory AS String
LOCAL lcMessage AS String
	ASSERT VARTYPE(m.tcDirectory) = 'C'
	lcMessage = ''
	* ЕСЛИ КАТАЛОГ СУЩЕСТВУЕТ
	IF DIRECTORY(m.tcDirectory, 1)
		* ВЫСТАВИМ АТРИБУТ NORMAL (RMDIR НЕ УДАЛЯЕТ READONLY КАТАЛОГИ)
		IF This.Parent.oWinAPI.setAttributes(m.tcDirectory)
			TRY
				* УДАЛИМ КАТАЛОГ
				RMDIR (m.tcDirectory)
			CATCH
				* ОШИБКА УДАЛЕНИЯ КАТАЛОГА
				lcMessage = MSG_FOLDERREMOVEERROR + CHR_CR + m.tcDirectory
			ENDTRY
		ELSE
			* ОШИБКА УСТАНОВКИ АТРИБУТОВ КАТАЛОГА
			lcMessage = MSG_FOLDERSETATTRERROR + CHR_CR + m.tcDirectory
		ENDIF
	ENDIF
RETURN m.lcMessage

ENDPROC
PROCEDURE removefolder
* УДАЛЕНИЕ КАТАЛОГА ВМЕСТЕ СО ВСЕМ СОДЕРЖИМЫМ
* РЕЗУЛЬТАТ : ПУСТАЯ СТРОКА ИЛИ СТРОКА С СООБЩЕНИЕМ ОБ ОШИБКЕ
LPARAMETERS tcPath AS String
LOCAL lcMessage AS String, lnCount AS Integer
LOCAL ARRAY laPathFile[1, 5]
	lcMessage=''
	tcPath=ADDBS(m.tcPath)

	FOR lnCount=1 TO ADIR(laPathFile, m.tcPath + '*.*', 'DHS')
		IF laPathFile[m.lnCount, 1]<>'.' AND laPathFile[m.lnCount, 1]<>'..'
			IF 'D' $ laPathFile[m.lnCount, 5]
				* КАТАЛОГ
				lcMessage = This.removeFolder(m.tcPath + laPathFile(m.lnCount, 1))
			ELSE
				* ФАЙЛ
				lcMessage = This.eraseFile(m.tcPath + laPathFile(m.lnCount, 1))
			ENDIF

			IF !EMPTY(m.lcMessage)
				RETURN m.lcMessage
			ENDIF
		ENDIF
	ENDFOR

	lcMessage = This.removeDirectory(m.tcPath)
RETURN m.lcMessage

ENDPROC
PROCEDURE resourcetopath
* ПЕРЕВОД ПУТИ В ВИДЕ РЕСУРСА В СТАНДАРТНУЮ НОТАЦИЮ ИМЕНИ КАТАЛОГА
* (НАПРИМЕР В MICROSOFT WEBBROWSER CONTROL ПРИ ПРОСМОТРЕ КАТАЛОГОВ)
LPARAMETERS tcResource AS String
ASSERT VARTYPE(tcResource)='C'
* 'FILE:///C:/DOCUMENTS%20AND%20SETTINGS/ADMINISTRATOR/MY%20DOCUMENTS'
	IF LEFT(m.tcResource, 8) = 'FILE:///'
		tcResource = SUBSTR(m.tcResource, 9)
		tcResource = CHRTRAN(m.tcResource, '/','\')
		tcResource = STRTRAN(m.tcResource, '%20', ' ')
	ENDIF
RETURN m.tcResource
ENDPROC
PROCEDURE secondtotime
* ПЕРЕВОД СЕКУНД В СТРОКУ 'HH:MM:SS'
LPARAMETERS tnSecond
LOCAL lnHour, lnMinute, lnSecond
	lnHour = INT(m.tnSecond/ 60 / 60)
	lnMinute = m.tnSecond - m.lnHour * 60 * 60
	lnMinute = INT(m.lnMinute / 60)
	lnSecond = m.tnSecond - m.lnHour * 60 * 60 - m.lnMinute * 60
RETURN TRANSFORM(m.lnHour, '@L 99') + ':';
	   + TRANSFORM(m.lnMinute, '@L 99') + ':';
	   + TRANSFORM(m.lnSecond, '@L 99')
ENDPROC
PROCEDURE showerrdlg
*показать диалог сообщение о событии и его расширенное описание
LPARAMETERS tcMsg as String, tcExtMsg as String
	MESSAGEBOX(m.tcMsg, 16, IIF(TYPE("THIS.Parent.oVars.cTaskCaption") = 'C',;
				   				THIS.Parent.oVars.cTaskCaption,;
				   				''))
ENDPROC
PROCEDURE showerrmsg
LPARAMETERS toExc as Exception
LOCAL lcErrMsg as String, lcExtErrMsg as String, lnI as Integer, lcTmpFileName as String,;
	  lcStackVars as String
LOCAL ARRAY laStackCall[1]
	IF VARTYPE(m.toExc) = 'C'
	*передали просто строку
		lcErrMsg = "Error: " + LTRIM(m.toExc) + CRLF;
				   + SYS(2018)
		lcExtErrMsg = ''

		lnStackLevel = 0
	ELSE
		lcErrMsg = "Error: " + LTRIM(TRANSFORM(m.toExc.ErrorNo)) + CRLF;
				   + "Procedure: " + m.toExc.Procedure + CRLF;
				   + "LineNo: " + LTRIM(TRANSFORM(m.toExc.LineNo)) + " LineContent: ";
				   + m.toExc.LineContents + CRLF;
				   + "Message: " + m.toExc.Message + CRLF;
			       + "Details: " + m.toExc.Details

		lnStackLevel = m.toExc.StackLevel
	ENDIF
	*стэк вызовов
*!*		Array Element  Description  
*!*		1 Call Stack Level 
*!*		2 Current program filename 
*!*		3 Module or Object name 
*!*		4 Module or Object Source filename 
*!*		5 Line number in the object source file
*!*		6 Source line contents
	ASTACKINFO(laStackCall)

	lcExtErrMsg = "Programm call stack list: "

	IF m.lnStackLevel > ALEN(laStackCall, 1)
		FOR lnI = 1 TO m.lnStackLevel
			lcExtErrMsg = m.lcExtErrMsg + PROGRAM(m.lnI) + '.'
		ENDFOR

		lcExtErrMsg = LEFT(m.lcExtErrMsg, LEN(m.lcExtErrMsg) - 1)
	ELSE
		FOR lnI = 1 TO ALEN(laStackCall, 1)
			lcExtErrMsg = m.lcExtErrMsg;
						  + TRANSFORM(laStackCall[m.lnI, 1], "99") + ' ';
						  + laStackCall[m.lnI, 2] + ' ';
						  + laStackCall[m.lnI, 3] + ' ';
						  + laStackCall[m.lnI, 4] + ' ';
						  + TRANSFORM(laStackCall[m.lnI, 5], "9999") + ' ';
						  + laStackCall[m.lnI, 6] + ' ';
						  + CRLF
		ENDFOR

		lcExtErrMsg = LEFT(m.lcExtErrMsg, LEN(m.lcExtErrMsg) - 2)
	ENDIF
	*дополнить списком переменных
	lcTmpFileName = THIS.Parent.oVars.cAppCurPaths + SYS(3) + ".txt"

	DISPLAY MEMORY TO FILE (m.lcTmpFileName) NOCONSOLE

	lcStackVars = "Variables list: " + FILETOSTR(m.lcTmpFileName)
	*удалить временный файл
	DELETE FILE (m.lcTmpFileName)

	IF THIS.Parent.oVars.lDisplayErrMsg
		*показать диалог с сообщением
		THIS.showErrDlg(m.lcErrMsg, m.lcExtErrMsg)
	ENDIF
	*запись в лог
	THIS.writeLog(m.lcErrMsg + CRLF + m.lcExtErrMsg + CRLF + m.lcStackVars)
ENDPROC
PROCEDURE spelling
* СУММА В РУБЛЯХ ПРОПИСЬЮ
LPARAMETERS tnSumma
ASSERT VARTYPE(tnSumma)='N'
LOCAL lcSumma
	IF tnSumma >= 10 ** 12
		RETURN ALLTRIM(STR(m.tnSumma,20,2))
	ENDIF
	* k-копейки, t-тысячи, m-милионы, M-миллиарды, e-единицы, d-десятки, c-сотни
	lcSumma = TRANSFORM(m.tnSumma, '9c9d9eM9c9d9em9c9d9et9c9d9e.99k')
	lcSumma = STRTRAN(m.lcSumma, ' c d et', '')
	lcSumma = STRTRAN(m.lcSumma, ' c d em', '')
	lcSumma = STRTRAN(m.lcSumma, ' c d eM', '')

	lcSumma = STRTRAN(m.lcSumma, '0c0d0et', '')
	lcSumma = STRTRAN(m.lcSumma, '0c0d0em', '')
	lcSumma = STRTRAN(m.lcSumma, '0c0d0eM', '')

	lcSumma = STRTRAN(m.lcSumma, ' c', '')
	lcSumma = STRTRAN(m.lcSumma, '0c', '')
	lcSumma = STRTRAN(m.lcSumma, '1c', 'сто ')
	lcSumma = STRTRAN(m.lcSumma, '2c', 'двести ')
	lcSumma = STRTRAN(m.lcSumma, '3c', 'триста ')
	lcSumma = STRTRAN(m.lcSumma, '4c', 'четыреста ')
	lcSumma = STRTRAN(m.lcSumma, '5c', 'пятьсот ')
	lcSumma = STRTRAN(m.lcSumma, '6c', 'шестьсот ')
	lcSumma = STRTRAN(m.lcSumma, '7c', 'семьсот ')
	lcSumma = STRTRAN(m.lcSumma, '8c', 'восемьсот ')
	lcSumma = STRTRAN(m.lcSumma, '9c', 'девятьсот ')

	lcSumma = STRTRAN(m.lcSumma, '1d0e', 'десять ')
	lcSumma = STRTRAN(m.lcSumma, '1d1e', 'одиннадцать ')
	lcSumma = STRTRAN(m.lcSumma, '1d2e', 'двенадцать ')
	lcSumma = STRTRAN(m.lcSumma, '1d3e', 'тринадцать ')
	lcSumma = STRTRAN(m.lcSumma, '1d4e', 'четырнадцать ')
	lcSumma = STRTRAN(m.lcSumma, '1d5e', 'пятнадцать ')
	lcSumma = STRTRAN(m.lcSumma, '1d6e', 'шестнадцать ')
	lcSumma = STRTRAN(m.lcSumma, '1d7e', 'семьнадцать ')
	lcSumma = STRTRAN(m.lcSumma, '1d8e', 'восемнадцать ')
	lcSumma = STRTRAN(m.lcSumma, '1d9e', 'девятнадцать ')

	lcSumma = STRTRAN(m.lcSumma, ' d', '')
	lcSumma = STRTRAN(m.lcSumma, '0d', '')
	lcSumma = STRTRAN(m.lcSumma, '2d', 'двадцать ')
	lcSumma = STRTRAN(m.lcSumma, '3d', 'тридцать ')
	lcSumma = STRTRAN(m.lcSumma, '4d', 'сорок ')
	lcSumma = STRTRAN(m.lcSumma, '5d', 'пятьдесят ')
	lcSumma = STRTRAN(m.lcSumma, '6d', 'шестьдесят ')
	lcSumma = STRTRAN(m.lcSumma, '7d', 'семьдесят ')
	lcSumma = STRTRAN(m.lcSumma, '8d', 'восемьдесят ')
	lcSumma = STRTRAN(m.lcSumma, '9d', 'девяносто ')

	lcSumma = STRTRAN(m.lcSumma, '0e', '')
	lcSumma = STRTRAN(m.lcSumma, '5e', 'пять ')
	lcSumma = STRTRAN(m.lcSumma, '6e', 'шесть ')
	lcSumma = STRTRAN(m.lcSumma, '7e', 'семь ')
	lcSumma = STRTRAN(m.lcSumma, '8e', 'восемь ')
	lcSumma = STRTRAN(m.lcSumma, '9e', 'девять ')

	lcSumma = STRTRAN(m.lcSumma, '1e.', 'один рубль ')
	lcSumma = STRTRAN(m.lcSumma, '2e.', 'два рубля ')
	lcSumma = STRTRAN(m.lcSumma, '3e.', 'три рубля ')
	lcSumma = STRTRAN(m.lcSumma, '4e.', 'четыре рубля ')

	lcSumma = STRTRAN(m.lcSumma, '1et', 'одна тысяча ')
	lcSumma = STRTRAN(m.lcSumma, '2et', 'две тысячи ')
	lcSumma = STRTRAN(m.lcSumma, '3et', 'три тысячи ')
	lcSumma = STRTRAN(m.lcSumma, '4et', 'четыре тысячи ')

	lcSumma = STRTRAN(m.lcSumma, '1em', 'один миллион ')
	lcSumma = STRTRAN(m.lcSumma, '2em', 'два миллиона ')
	lcSumma = STRTRAN(m.lcSumma, '3em', 'три миллиона ')
	lcSumma = STRTRAN(m.lcSumma, '4em', 'четыре миллиона ')

	lcSumma = STRTRAN(m.lcSumma, '1eM', 'один милиард ')
	lcSumma = STRTRAN(m.lcSumma, '2eM', 'два милиарда ')
	lcSumma = STRTRAN(m.lcSumma, '3eM', 'три милиарда ')
	lcSumma = STRTRAN(m.lcSumma, '4eM', 'четыре милиарда ')

	lcSumma = STRTRAN(m.lcSumma, '11k', '11 копеек')
	lcSumma = STRTRAN(m.lcSumma, '12k', '12 копеек')
	lcSumma = STRTRAN(m.lcSumma, '13k', '13 копеек')
	lcSumma = STRTRAN(m.lcSumma, '14k', '14 копеек')

	lcSumma = STRTRAN(m.lcSumma, '1k', '1 копейка')
	lcSumma = STRTRAN(m.lcSumma, '2k', '2 копейки')
	lcSumma = STRTRAN(m.lcSumma, '3k', '3 копейки')
	lcSumma = STRTRAN(m.lcSumma, '4k', '4 копейки')

	lcSumma = STRTRAN(m.lcSumma, ' .', ' рублей ')
	lcSumma = STRTRAN(m.lcSumma, '.', '')
	lcSumma = STRTRAN(m.lcSumma, 't', 'тысяч ')
	lcSumma = STRTRAN(m.lcSumma, 'm', 'миллионов ')
	lcSumma = STRTRAN(m.lcSumma, 'M', 'милиардов ')
	lcSumma = STRTRAN(m.lcSumma, 'k', ' копеек')
RETURN UPPER(LEFT(m.lcSumma, 1)) + SUBSTR(m.lcSumma, 2)

ENDPROC
PROCEDURE stringtolong
* CONVERT A BINARY LONG INTEGER INTO A NUMBER
LPARAMETERS tcLong
RETURN BITLSHIFT(ASC(SUBSTR(m.tcLong, 4, 1)), 24);
	   + BITLSHIFT(ASC(SUBSTR(m.tcLong, 3, 1)), 16);
	   + BITLSHIFT(ASC(SUBSTR(m.tcLong, 2, 1)), 8);
	   + ASC(SUBSTR(m.tcLong, 1, 1))
ENDPROC
PROCEDURE timestumptodatetime
* VFP TIMESTAMP FIELD TO DATETIME
LPARAMETERS tnStamp
#DEFINE Secondsmasks	0x0000001F
#DEFINE MinutesMasks	0x000
#DEFINE HoursMasks		0x0000F800
#DEFINE DaysMasks		0x001F0000
#DEFINE MonthsMasks		0x01E00000
#DEFINE YearsMasks		0x3E000000

#DEFINE SecondsOffset	1
#DEFINE MinutesOffset	5
#DEFINE HoursOffset		11
#DEFINE SysOffset		16
#DEFINE MonthsOffset	21
#DEFINE YearsOffset		25

#DEFINE t2Month			BITRSHIFT(BITAND(tnStamp, MonthsMasks), MonthsOffset)
#DEFINE t2Day			BITRSHIFT(BITAND(tnStamp, DaysMasks), DaysOffset)
#DEFINE t2Year  		1980 + BITRSHIFT(BITAND(tnStamp, YearsMasks), YearsOffset)
#DEFINE t2Hour			BITRSHIFT(BITAND(tnStamp, HoursMasks), HoursOffset)
#DEFINE t2Min			BITRSHIFT(BITAND(tnStamp, MinutesMasks), MinutesOffset)
#DEFINE t2Sec			BITRSHIFT(BITAND(tnStamp, Secondsmasks), SecondsOffset)
RETURN DATETIME(t2Year, t2Month, t2Day, t2Hour, t2Min, t2Sec)

*!*	********************************************************************
*!*	* Program....: STAMP2T6.PRG
*!*	* Version....: 1.0
*!*	* Author.....: Ted Roche
*!*	* Date.......: May 31, 1998
*!*	* Notice.....: Copyright й 1998 Ted Roche, All Rights Reserved.
*!*	* Compiler...: Visual FoxPro 06.00.8093.00 for Windows
*!*	* Abstract...: VERSION SIX AND LATER ONLY!!!
*!*	* ...........: Simpler version of Stamp2DT written for HackFox3 and
*!*	* ...........: also published in FoxPro Advisor magazine
*!*	* Changes....:
*!*	********************************************************************

*!*	LPARAMETERS tnStamp

*!*	#DEFINE SecondsMask 15  && 00001111
*!*	#DEFINE MinutesMask 63  && 00111111
*!*	#DEFINE HoursMask   31  && 00011111
*!*	#DEFINE DaysMask    31  && 00011111
*!*	#DEFINE MonthsMask  15  && 00001111
*!*	#DEFINE YearsMask   63  && 00111111

*!*	#DEFINE SecondsOff= 1  && Note this is a LEFT shift, not RIGHT
*!*	#DEFINE MinutesOffset 5
*!*	#DEFINE HoursOffset   11
*!*	#DEFINE DaysOffset    16
*!*	#DEFINE MonthsOffset  21
*!*	#DEFINE YearsOffset   25

*!*	#DEFINE fMonth       BITAND(bitrshift(tnStamp,MONTHSOFFSET ),MONTHSMASK)
*!*	#DEFINE fDay         BITAND(bitrshift(tnStamp,DAYSOFFSET   ),DAYSMASK)
*!*	#DEFINE fYear   1980+BITAND(bitrshift(tnStamp,YEARSOFFSET  ),YEARSMASK)
*!*	#DEFINE fHour        BITAND(bitrshift(tnStamp,HOURSOFFSET  ),HOURSMASK)
*!*	#DEFINE fMinute     =TAND(bitrshift(tnStamp,MINUTESOFFSET),MINUTESMASK)
*!*	#DEFINE fSecond      BITAND(bitLshift(tnStamp,SECONDSOFFSET),SECONDSMASK)

*!*	IF TYPE("VERSION(5)") = "U" 
*!*	  = MESSAGEBOX("This routine only works with Visual FoxPro 6.x or later.")
*!*	  RETURN .F.
*!*	ENDIF

*!*	LOCAL ltReturn
*!*	ltReturn = IIF(tnStamp = 0, {//::}, ;
*!*	               DATETIME(fYear, fMonth, fDay, fHour, fMinute, fSecond)) 
*!*	return ltReturn

ENDPROC
PROCEDURE timetostring
* ПЕРЕВОД DATETIME В СТРОКУ FILETIME FORMAT C УЧЕТОМ ЧАСОВОГО ПОЯСА
LPARAMETERS ttDateTime AS Datetime
LOCAL lnTime, lcTime, lnCount, lnTemp
	lnTime = (m.ttDateTime - {^1601/01/01 0:0:0} + This.GetBias() * 60) * 10 ^ 7
	lcTime = ''

	FOR lnCount = 56 TO 0 STEP -8
		lnTemp = INT(m.lnTime / (2 ^ m.lnCount))
		lnTime = (m.lnTime - m.lnTemp * (2 ^ m.lnCount))
		lcTime = CHR(m.lnTemp) + m.lcTime
	ENDFOR
RETURN m.lcTime
ENDPROC
PROCEDURE transform_my
LPARAMETERS tnnum
LOCAL lcstr as String, lnpoint as Integer, lnpos as Integer
	lcstr = LTRIM(TRANSFORM(m.tnnum, "@Z"))
	
	lnpoint = RATC('.', m.lcstr)
	
	IF m.lnpoint > 0
		lnpos = LENC(m.lcstr)

		DO WHILE m.lnpos >= m.lnpoint
			IF INLIST(SUBSTRC(m.lcstr, m.lnpos, 1), '0', '.', ' ')
				lcstr = LEFTC(m.lcstr, m.lnpos - 1)
			ELSE
				EXIT
			ENDIF

			lnpos = m.lnpos - 1
		ENDDO
	ENDIF
RETURN m.lcstr
ENDPROC
PROCEDURE transliterate
* РУССКО-АНГЛИЙСКАЯ ТРАНСЛИТЕРАЦИЯ 'Людмила'->'Lyudmila'
LPARAMETERS tcString
	ASSERT VARTYPE(m.tcString) = 'C'
	tcString = CHRTRAN(m.tcString, 'абвгдеёзийклмнопрстуфъыэ', 'abvgdeeziiklmnoprstuf"ye')
	tcString = CHRTRAN(m.tcString, 'АБВГДЕЁЗИЙКЛМНОПРСТУФЪЫЭ', 'ABVGDEEZIIKLMNOPRSTUF"YE')
	tcString = STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(CHRTRAN(m.tcString,;
					   'ь',"'"),'ж','zh'),'х','kh'),'ц','ts'),'ч','ch'),'ш','sh'),'щ','shch'),'ю','yu'),'я','ya')
	tcString = STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(CHRTRAN(m.tcString,;
					   'Ь',"'"),'Ж','Zh'),'Х','Kh'),'Ц','Ts'),'Ч','Ch'),'Ш','Sh'),'Щ','Shch'),'Ю','Yu'),'Я','Ya')
RETURN m.tcString

ENDPROC
PROCEDURE trimarray
* ОТСЕЧЕНИЕ ПРОБЕЛОВ У ЭЛЕМЕНТОВ N - МЕРНОГО МАССИВА
* This.TrimArray(@MyArray)
LPARAMETERS taSource
LOCAL lnCount
EXTERNAL ARRAY taSource
	FOR lnCount = 1 TO ALEN(taSource)
		IF VARTYPE(taSource(m.lnCount)) = 'C'
			taSource(m.lnCount) = ALLTRIM(taSource(m.lnCount))
		ENDIF
	ENDFOR
ENDPROC
PROCEDURE writelog
* ВЕДЕНИЕ ФАЙЛА-ПРОТОКОЛА
LPARAMETERS tcMessage as String, tcFile as String
	IF VARTYPE(m.tcMessage) = 'C'
		IF EMPTY(m.tcFile)
			tcFile = THIS.Parent.oVars.cAppCurPaths + THIS.Parent.oVars.cTaskName
		ENDIF

		STRTOFILE(CRLF + DTOC(DATE()) + '-' + TIME() + ':' + m.tcMessage,;
				  FORCEEXT(m.tcFile, "LOG"),;
				  1)
	ENDIF
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addprinter 
*arraypointer 
*closeallwindows 
*colortorgb 
*complexperc 
*copyfile 
*copyproperties 
*cryptkey 
*cryptxor 
*datetostring Дата строкой
*dectohex 
*directorytoarray 
*div 
*divmat 
*erasefile 
*fddformat 
*getbias 
*getfileattributes 
*getfilesize 
*getfont 
*getgdiguiddescription 
*getimageinformation 
*getnextfilename 
*getrandomnumber 
*gettagstring 
*gettempfile 
*gettempname 
*gettextstringwidth Returns the width of a text string as it would be printed in the current font.
*getwordcount 
*getwordnum 
*hextodec 
*isdirectoryreadonly 
*isfileequal 
*isfileused 
*isinternetconnected 
*ispicturevalid 
*longtostring 
*makedirectory 
*makedirectorytree 
*monthbetween 
*pixeltofoxel 
*pixeltotwip 
*playwav 
*pointertolong 
*pointertostring 
*removedirectory 
*removefolder 
*resourcetopath 
*secondtotime 
*showerrdlg 
*showerrmsg 
*spelling 
*stringtolong 
*timestumptodatetime 
*timetostring 
*transform_my Расширяет возможности transform - убирает не значащие нули из дробной части.
*transliterate Русско-английская транслитерация 'Людмила'->'Lyudmila'
*trimarray 
*writelog Сделать запись в лог
_memberdata XML Metadata for customizable properties
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\cstfunction.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\cstfunction.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Общие функции программы[END RESERVED7]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] cstfunction

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1YB0ZDG8R
[CLASS] base_custom
[CLASSLOC] base_gui.vcx
[BASECLASS] custom
[OBJNAME] cstvars
[START PROPERTIES]

Name = "cstvars"
_memberdata =     3825<VFPData><memberdata name="islock" type="method" display="IsLock"/><memberdata name="lockobject" type="property" display="LockObject"/><memberdata name="clistvars" type="property" display="cListVars"/><memberdata name="cappcurpaths" type="property" display="cAppCurPaths"/><memberdata name="cappexename" type="property" display="cAppExeName"/><memberdata name="cappname" type="property" display="cAppName"/><memberdata name="cdbname" type="property" display="cDBName"/><memberdata name="cdbpath" type="property" display="cDBPath"/><memberdata name="ctaskcaption" type="property" display="cTaskCaption"/><memberdata name="ctaskdesktoppicture" type="property" display="cTaskDesktopPicture"/><memberdata name="ctaskicon" type="property" display="cTaskIcon"/><memberdata name="ctaskname" type="property" display="cTaskName"/><memberdata name="eventloaded" type="property" display="eventLoaded"/><memberdata name="lcleanalldlls" type="property" display="lCleanAllDlls"/><memberdata name="lkeepdlls" type="property" display="lKeepDlls"/><memberdata name="lscreenhwnd" type="property" display="lScreenHwnd"/><memberdata name="ltaskbar" type="property" display="lTaskBar"/><memberdata name="ltoolbar" type="property" display="lToolBar"/><memberdata name="ndbtype" type="property" display="nDBType"/><memberdata name="ocurrenttask" type="property" display="oCurrentTask"/><memberdata name="odbconnect" type="property" display="oDBConnect"/><memberdata name="otaskbar" type="property" display="oTaskbar"/><memberdata name="otoolbar" type="property" display="oToolbar"/><memberdata name="timeterminate" type="property" display="timeTerminate"/><memberdata name="wndproc" type="property" display="wndProc"/><memberdata name="ctaskcaption_assign" type="method" display="cTaskCaption_Assign"/><memberdata name="ctaskdesktoppicture_assign" type="method" display="cTaskDesktopPicture_Assign"/><memberdata name="ctaskicon_assign" type="method" display="cTaskIcon_Assign"/><memberdata name="ocurrenttask_assign" type="method" display="oCurrentTask_Assign"/><memberdata name="asavedlls" type="property" display="aSaveDlls"/><memberdata name="dfltdatebegin" type="property" display="dFltDateBegin"/><memberdata name="dfltdateend" type="property" display="dFltDateEnd"/><memberdata name="lactive" type="property" display="lActive"/><memberdata name="cdbschema" type="property" display="cDBSchema"/><memberdata name="omenu" type="property" display="oMenu"/><memberdata name="astorexmlvars" type="property" display="aStoreXmlVars"/><memberdata name="cdbtype" type="property" display="cDBType"/><memberdata name="cver" type="property" display="cVer"/><memberdata name="cdbtype_assign" type="method" display="cDBType_Assign"/><memberdata name="lstorepassword" type="property" display="lStorePassword"/><memberdata name="lstorestatewindows" type="property" display="lStoreStateWindows"/><memberdata name="cusername" type="property" display="cUserName"/><memberdata name="cuserpassword" type="property" display="cUserPassword"/><memberdata name="lmenubar" type="property" display="lMenuBar"/><memberdata name="lsuo" type="property" display="lSuo"/><memberdata name="cdbpath_assign" type="method" display="cDBPath_Assign"/><memberdata name="cpop3_host" type="property" display="cPop3_Host"/><memberdata name="cpop3_log" type="property" display="cPop3_Log"/><memberdata name="cpop3_port" type="property" display="cPop3_Port"/><memberdata name="cpop3_pwd" type="property" display="cPop3_Pwd"/><memberdata name="csmtp_host" type="property" display="cSmtp_Host"/><memberdata name="csmtp_port" type="property" display="cSmtp_Port"/><memberdata name="lsearchmode" type="property" display="lSearchMode"/><memberdata name="ldisplayerrmsg" type="property" display="lDisplayErrMsg"/><memberdata name="loncestart" type="property" display="lOnceStart"/></VFPData>
cappcurpaths = 
cappexename = 
cappname = GLOBAL
cdbname = 
cdbpath = 
cdbschema = 
cdbtype = 
cpop3_host = 
cpop3_log = 
cpop3_port = "110"
cpop3_pwd = 
csmtp_host = 
csmtp_port = "25"
ctaskcaption = "СУО:"
ctaskdesktoppicture = 
ctaskicon = ..\bmp\components.ico
ctaskname = GLOBAL
cusername = 
cuserpassword = 
cver = 0
dfltdatebegin = (DATE())
dfltdateend = (DATE())
eventloaded = .F.
lactive = .F.
lcleanalldlls = .F.
ldisplayerrmsg = .T.
lkeepdlls = .F.
lmenubar = .T.
loncestart = .F.
lscreenhwnd = .F.
lsearchmode = .F.
lstorepassword = .F.
lstorestatewindows = .F.
lsuo = .F.
ltoolbar = .T.
ndbtype = 0
ocurrenttask = .NULL.
odbconnect = .NULL.
timeterminate = .NULL.
wndproc = 0
[END PROPERTIES]
[START PROTECTED]
Picture^
lsuo^
[END PROTECTED]
[START METHODS]
PROCEDURE Init
*!*	Custom::AddObject("oMenu", "SFMenu_app", "m.goApp.oVars.oMenu")
*добавить список полей которые надо читать/сохранять в xml
WITH THIS
	DIMENSION .aStoreXmlVars[20, 3]
	*имя задачи
	.aStoreXmlVars[1, 1] = "cTaskName"
	.aStoreXmlVars[1, 2] = "Name"
	.aStoreXmlVars[1, 3] = "c"
	*картинка задачи
	.aStoreXmlVars[2, 1] = "cTaskIcon"
	.aStoreXmlVars[2, 2] = "Icon"
	.aStoreXmlVars[2, 3] = "c"
	*путь к базе/сетевой адрес
	.aStoreXmlVars[3, 1] = "cDBPath"
	.aStoreXmlVars[3, 2] = "database_path"
	.aStoreXmlVars[3, 3] = "c"
	*имя базы
	.aStoreXmlVars[4, 1] = "cDBName"
	.aStoreXmlVars[4, 2] = "database_name"
	.aStoreXmlVars[4, 3] = "c"
	*имя схемы в базе
	.aStoreXmlVars[5, 1] = "cDBSchema"
	.aStoreXmlVars[5, 2] = "database_schema"
	.aStoreXmlVars[5, 3] = "c"
	*тип базы
	.aStoreXmlVars[6, 1] = "cDBType"
	.aStoreXmlVars[6, 2] = "database_type"
	.aStoreXmlVars[6, 3] = "c"
	*как хранить настройки окон - идивидуально для задачи или использовать глобальные
	.aStoreXmlVars[7, 1] = "lStoreStateWindows"
	.aStoreXmlVars[7, 2] = "store_statewin"
	.aStoreXmlVars[7, 3] = "l"
	*имя пользователя - последний удачно залогинившийся
	.aStoreXmlVars[8, 1] = "cUserName"
	.aStoreXmlVars[8, 2] = "login"
	.aStoreXmlVars[8, 3] = "c"
	*пароль
	.aStoreXmlVars[9, 1] = "cUserPassword"
	.aStoreXmlVars[9, 2] = "password"
	.aStoreXmlVars[9, 3] = "c"
	*хранить пароль?
	.aStoreXmlVars[10, 1] = "lStorePassword"
	.aStoreXmlVars[10, 2] = "store_password"
	.aStoreXmlVars[10, 3] = "l"
	*активная задача
	.aStoreXmlVars[11, 1] = "lActive"
	.aStoreXmlVars[11, 2] = "last_connected"
	.aStoreXmlVars[11, 3] = "l"
	*начало периода
	.aStoreXmlVars[12, 1] = "dFltDateBegin"
	.aStoreXmlVars[12, 2] = "work_interval_begin"
	.aStoreXmlVars[12, 3] = "d"
	*окончание периода
	.aStoreXmlVars[13, 1] = "dFltDateEnd"
	.aStoreXmlVars[13, 2] = "work_interval_end"
	.aStoreXmlVars[13, 3] = "d"
	*smtp_host
	.aStoreXmlVars[14, 1] = "csmtp_host"
	.aStoreXmlVars[14, 2] = "smtp_host"
	.aStoreXmlVars[14, 3] = "c"
	*smtp_port
	.aStoreXmlVars[15, 1] = "csmtp_port"
	.aStoreXmlVars[15, 2] = "smtp_port"
	.aStoreXmlVars[15, 3] = "c"
	*pop3_host
	.aStoreXmlVars[16, 1] = "cpop3_host"
	.aStoreXmlVars[16, 2] = "pop3_host"
	.aStoreXmlVars[16, 3] = "c"
	*pop3_port
	.aStoreXmlVars[17, 1] = "cpop3_port"
	.aStoreXmlVars[17, 2] = "pop3_port"
	.aStoreXmlVars[17, 3] = "c"
	*pop3_log
	.aStoreXmlVars[18, 1] = "cpop3_log"
	.aStoreXmlVars[18, 2] = "pop3_log"
	.aStoreXmlVars[18, 3] = "c"
	*pop3_pwd
	.aStoreXmlVars[19, 1] = "cpop3_pwd"
	.aStoreXmlVars[19, 2] = "pop3_pwd"
	.aStoreXmlVars[19, 3] = "c"
	*режим поиска по подстроке
	.aStoreXmlVars[20, 1] = "lSearchMode"
	.aStoreXmlVars[20, 2] = "SearchMode"
	.aStoreXmlVars[20, 3] = "l"
ENDWITH
ENDPROC
PROCEDURE cdbpath_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
	THIS.cDBPath = m.vNewVal
	*переконнектиться
	IF TYPE("m.goApp") = 'O'
		m.goApp.login()
	ENDIF
ENDPROC
PROCEDURE cdbtype_assign
LPARAMETERS tcNewVal
*To do: Modify this routine for the Assign method
	WITH THIS
		.cDBType = m.tcNewVal

		DO CASE
		CASE m.tcNewVal = "FoxPro"
			.nDBType = DB_FoxPro
		CASE m.tcNewVal = "PostgreSQL"
			.nDBType = DB_PostgreSQL
		CASE m.tcNewVal = "MSSQL"
			.nDBType = DB_MSSQL
		CASE m.tcNewVal = "Oracle"
			.nDBType = DB_Oracle
		CASE m.tcNewVal = "Access"
			.nDBType = DB_Access
		OTHERWISE
			.nDBType = DB_None
		ENDCASE
	ENDWITH
ENDPROC
PROCEDURE ctaskcaption_assign
LPARAMETERS tvNewVal
	THIS.cTaskCaption = IIF(VARTYPE(m.tvNewVal) <> 'C', '', m.tvNewVal)

	IF VARTYPE(_Screen) = 'O'
		_Screen.Caption = IIF(THIS.lSuo, "СУО: ", '') + m.tvNewVal
	ENDIF
ENDPROC
PROCEDURE ctaskdesktoppicture_assign
LPARAMETERS tvNewVal
	THIS.cTaskDesktopPicture = m.tvNewVal

	IF VARTYPE(_Screen) = 'O'
		_Screen.Picture = m.tvNewVal
	ENDIF
ENDPROC
PROCEDURE ctaskicon_assign
LPARAMETERS tvNewVal
	THIS.cTaskIcon = m.tvNewVal

	IF VARTYPE(_Screen) = 'O'
		_Screen.Icon = m.tvNewVal
	ENDIF
ENDPROC
PROCEDURE ltaskbar_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
	THIS.lTaskBar = m.vNewVal

	IF PEMSTATUS(THIS.Parent, "loadEvent", 5)
		IF m.vNewVal			
		*перехват оконных событий пока только если нужен таск бар
		*для report окон fox падает
			THIS.Parent.loadEvent()
		ELSE
			THIS.Parent.releaseEvent()
		ENDIF
	ENDIF
ENDPROC
PROCEDURE ocurrenttask_assign
LPARAMETERS tvNewVal as tasklist of ..\lib.9\base_app
*To do: Modify this routine for the Assign method
	WITH THIS
		.oCurrentTask = m.tvNewVal

*!*			IF VARTYPE(_Screen) = 'O' AND VARTYPE(m.tvNewVal) = 'O' AND !ISNULL(m.tvNewVal)
		IF VARTYPE(m.tvNewVal) = 'O' AND !ISNULL(m.tvNewVal)
			.cTaskName = m.tvNewVal.oVars.cTaskName
			.cTaskCaption = m.tvNewVal.oVars.cTaskCaption
			.cTaskDesktopPicture = m.tvNewVal.oVars.cTaskDesktopPicture
			.cTaskIcon = m.tvNewVal.oVars.cTaskIcon

			.cDBName = m.tvNewVal.oVars.cDBName
			.cDBPath = m.tvNewVal.oVars.cDBPath
			.nDBType = m.tvNewVal.oVars.nDBType
			.cUserName = m.tvNewVal.oVars.cUserName
			.cUserPassword = m.tvNewVal.oVars.cUserPassword

			.dFltDateBegin = m.tvNewVal.oVars.dFltDateBegin
			.dFltDateEnd = m.tvNewVal.oVars.dFltDateEnd

			_Screen.Caption = m.tvNewVal.oVars.cTaskCaption
			_Screen.Picture = m.tvNewVal.oVars.cTaskDesktopPicture
			_Screen.Icon = m.tvNewVal.oVars.cTaskIcon
		ENDIF
	ENDWITH
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*cdbpath_assign 
*cdbtype_assign 
*ctaskcaption_assign 
*ctaskdesktoppicture_assign 
*ctaskicon_assign 
*ltaskbar_assign 
*ocurrenttask_assign 
^asavedlls[1,0] 
^astorexmlvars[1,3] 1-имя перем 2-имя в xml 3-тип
cappcurpaths
cappexename
cappname
cdbname
cdbpath
cdbschema
cdbtype тип базы - строкой
cpop3_host
cpop3_log
cpop3_port
cpop3_pwd
csmtp_host
csmtp_port
ctaskcaption
ctaskdesktoppicture
ctaskicon
ctaskname
cusername
cuserpassword
cver
dfltdatebegin
dfltdateend
eventloaded
lactive
lcleanalldlls
ldisplayerrmsg Показывать мессаги об ошибках
lkeepdlls
lmenubar
loncestart
lscreenhwnd
lsearchmode
lstorepassword
lstorestatewindows
lsuo
ltaskbar
ltoolbar
ndbtype тип базы - число
ocurrenttask
odbconnect
timeterminate
wndproc
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Глобальные переменные[END RESERVED7]
[START RESERVED8]
base_idb.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] cstvars

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0SZ0L98A3
[CLASS] custom
[BASECLASS] custom
[OBJNAME] cstwinapi
[START PROPERTIES]

Name = "cstwinapi"
Width = 20
_memberdata =     3853<VFPData><memberdata name="activatewindow" type="method" display="activateWindow"/><memberdata name="beep" type="method" display="beep"/><memberdata name="createmutex" type="method" display="createMutex"/><memberdata name="deletedc" type="method" display="deleteDC"/><memberdata name="deleteobject" type="method" display="deleteObject"/><memberdata name="exitprocess" type="method" display="exitProcess"/><memberdata name="exitwindowsex" type="method" display="exitWindowsEx"/><memberdata name="findwindow" type="method" display="findWindow"/><memberdata name="freelibrary" type="method" display="freeLibrary"/><memberdata name="gdipatblt" type="method" display="gDIPatBlt"/><memberdata name="getapppath" type="method" display="getAppPath"/><memberdata name="getcursorpos" type="method" display="getCursorPos"/><memberdata name="getdatetime" type="method" display="getDatetime"/><memberdata name="getdc" type="method" display="getDC"/><memberdata name="getdevicecaps" type="method" display="getDeviceCaps"/><memberdata name="getfocus" type="method" display="getFocus"/><memberdata name="getguid" type="method" display="getGuid"/><memberdata name="getkeyboardlayoutname" type="method" display="getKeyboardLayoutName"/><memberdata name="getlasterror" type="method" display="getLastError"/><memberdata name="getsyscolor" type="method" display="getSysColor"/><memberdata name="getwindow" type="method" display="getWindow"/><memberdata name="getwindowlong" type="method" display="getWindowLong"/><memberdata name="getwindowrect" type="method" display="getWindowRect"/><memberdata name="globalmemorystatus" type="method" display="globalMemoryStatus"/><memberdata name="ischild" type="method" display="isChild"/><memberdata name="loadicon" type="method" display="loadIcon"/><memberdata name="loadimage" type="method" display="loadImage"/><memberdata name="loadkeyboardlayout" type="method" display="loadKeyboardLayout"/><memberdata name="loadlibrary" type="method" display="loadLibrary"/><memberdata name="messagebeep" type="method" display="messageBeep"/><memberdata name="openfile" type="method" display="openFile"/><memberdata name="releasecapture" type="method" display="releaseCapture"/><memberdata name="releasedc" type="method" display="releaseDC"/><memberdata name="releasemutex" type="method" display="releaseMutex"/><memberdata name="selectobject" type="method" display="selectObject"/><memberdata name="sendmessage" type="method" display="sendMessage"/><memberdata name="shellexecute" type="method" display="shellExecute"/><memberdata name="showcursor" type="method" display="showCursor"/><memberdata name="shutdownwindows" type="method" display="shutdownWindows"/><memberdata name="sleep" type="method" display="sleep"/><memberdata name="terminateprocess" type="method" display="terminateProcess"/><memberdata name="windowfrompoint" type="method" display="windowFromPoint"/><memberdata name="winexec" type="method" display="winExec"/><memberdata name="getuserdefaultlcid" type="method" display="getUserDefaultLCID"/><memberdata name="getfolderpath" type="method" display="getFolderPath"/><memberdata name="loadlibraryex" type="method" display="loadLibraryEx"/><memberdata name="isloaded" type="method" display="isLoaded"/><memberdata name="adeclareddll" type="property" display="aDeclaredDLL"/><memberdata name="createdirectory" type="method" display="createDirectory"/><memberdata name="createsemaphore" type="method" display="createSemaphore"/><memberdata name="getmessagepos" type="method" display="getMessagePos"/><memberdata name="getwindowsdirectory" type="method" display="getWindowsDirectory"/><memberdata name="opensemaphore" type="method" display="openSemaphore"/><memberdata name="getlogicaldrive" type="method" display="getLogicalDrive"/><memberdata name="getvolumeinformation" type="method" display="getVolumeInformation"/></VFPData>
[END PROPERTIES]
[START METHODS]
PROCEDURE activatewindow
* АКТИВИЗАЦИЯ И ВЫТАСКИВАНИЕ ОКНА ПО ХЭНДЛУ
* УДОБНО ИСПОЛЬЗОВАТЬ В ПАРЕ С THIS.FINDWINDOW()
* IF ActivateWindow(FindWindow(tcCaption)) ...
LPARAMETERS tnWindowHandle				
	IF m.tnWindowHandle = 0
		RETURN .F.
	ENDIF

	WITH THIS
		IF !.isLoaded("SetForegroundWindow")
			DECLARE INTEGER SetForegroundWindow IN WIN32API INTEGER
		ENDIF

		IF !.isLoaded("IsIconic")
			DECLARE INTEGER IsIconic IN WIN32API INTEGER
		ENDIF

		IF !.isLoaded("ShowWindow")
			DECLARE INTEGER ShowWindow IN WIN32API INTEGER,INTEGER
		ENDIF
	ENDWITH
	* ВЫТАЩИМ НА ПОВЕРХНОСТЬ
	SetForegroundWindow(m.tnWindowHandle)
	* ЕСЛИ СВЕРНУТО, ТО ВОССТАНОВИМ ПРЕЖНИЙ РАЗМЕР SW_RESTORE = 9
	IF IsIconic(m.tnWindowHandle) <> 0
		ShowWindow(m.tnWindowHandle, 9)
	ENDIF
ENDPROC
PROCEDURE beep
* ПОД WNT/W2K ВЫДАЕТСЯ СИГНАЛ ДЛИТЕЛЬНОСТЬЮ DURATION С ЧАСТОТОЙ FREQUENCY
* ПОД W9X/WME ВЫДАЕТСЯ BEEP НА СПИКЕР - ПРИ ОТСУТСТВИИ ЗВУКОВУХИ, ИНАЧЕ ЗВУК ПО УМОЛЧАНИЮ
* P.S. СМ. THIS.MESSAGEBEEP()
LPARAMETERS tnFrequency AS Integer, tnDuration AS Integer
LOCAL lnSuccess AS Integer
	tnFrequency=IIF(VARTYPE(m.tnFrequency)='N', m.tnFrequency, 400)
	tnDuration=IIF(VARTYPE(m.tnDuration)='N', m.tnDuration, 100)

	IF !THIS.isLoaded("Beep")
		DECLARE INTEGER Beep IN WIN32API  LONG, LONG
	ENDIF

	lnSuccess=Beep(m.tnFrequency, m.tnDuration)
RETURN m.lnSuccess<>0

ENDPROC
PROCEDURE bitblt
* TRANSFERS BITS FROM A RECTANGLE ON A SOURCE DEVICE TO A RECTANGLE THAT HAS THE SAME DIMENSIONS ON A DESTINATION DEVICE
* P.S. В ОПИСАНИИ ПОРЯДКА ПАРАМЕТРОВ В MSDN ПОХОЖЕ ОШИБКА

LPARAMETERS tnDestDC, tnX, tnY, tnWidth, tnHeight, tnSrcDC, tnXSrc, tnYSrc, tnRop && tPBrush, tDrawMode
DECLARE LONG BitBlt IN Win32API LONG, LONG, LONG, LONG, LONG, LONG, LONG, LONG, LONG
BitBlt(tnDestDC, tnX, tnY, tnWidth, tnHeight, tnSrcDC, tnXSrc, tnYSrc, tnRop)
CLEAR DLLS 'BitBlt'

ENDPROC
PROCEDURE blockinput
* BLOCK / UNBLOCK MOUSE AND KEYBOARD INPUT

LPARAMETERS tlBlock
LOCAL lnBlock
lnBlock=IIF(tlBlock, 1, 0)
DECLARE INTEGER BlockInput IN WIN32API INTEGER
BlockInput(lnBlock)
CLEAR DLLS 'BlockInput'
RETURN

ENDPROC
PROCEDURE cddoor
* ОТКРЫТЬ / ЗАКРЫТЬ ЧЕЛЮСТЬ СИДЮКА
LPARAMETERS tcDriveLetter AS Character, tlCloseDoor AS Logical
LOCAL llSuccess AS Logical
	llSuccess=.F.
	tcDriveLetter=LEFT(LTRIM(m.tcDriveLetter), 1)
	*
	IF DRIVETYPE(m.tcDriveLetter)=DRIVE_CDROM
		IF !THIS.isLoaded("mciSendString")
			DECLARE LONG mciSendString IN WINMM STRING, LONG, LONG, LONG
		ENDIF
		* ОТКРОЕМ УСТРОЙСТВО И ПРИСВОИМ АЛИАС 'CD'
		IF mciSendString('open '+m.tcDriveLetter+': type cdaudio alias cd', 0, 0, 0)=0
			llSuccess=mciSendString('set cd door '+IIF(m.tlCloseDoor, 'closed', 'open'), 0, 0, 0)=0
			mciSendString('close cd', 0, 0, 0)
		ENDIF
	ENDIF
RETURN m.llSuccess

ENDPROC
PROCEDURE checkinstance
* ПРОВЕРКА : ЗАПУЩЕНО ЛИ УЖЕ ПРИЛОЖЕНИЕ ?
* > 0 - ПЕРВЫЙ ЗАПУСК ПРИЛОЖЕНИЯ
* = 0 - ОШИБКА СОЗДАНИЯ СЕМАФОРА
* < 0 - ПРИЛОЖЕНИЕ УЖЕ ЗАПУЩЕНО
LPARAMETERS tcUnique as String
LOCAL lnReturnValue AS Integer
	IF !THIS.isLoaded("CreateSemaphore")
		DECLARE INTEGER CreateSemaphore IN WIN32API INTEGER, INTEGER, INTEGER, STRING
	ENDIF

	IF !THIS.isLoaded("OpenSemaphore")
		DECLARE INTEGER OpenSemaphore IN WIN32API INTEGER, INTEGER, STRING
	ENDIF

	lnReturnValue = OpenSemaphore (983040, 0, m.tcUnique)
	lnReturnValue = IIF(m.lnReturnValue = 0, CreateSemaphore (0, 1, 1, m.tcUnique), -1)
RETURN m.lnReturnValue

ENDPROC
PROCEDURE clienttoscreen
* КООРДИНАТЫ ФОРМЫ ОТНОСИТЕЛЬНО ДЭСКТОПА (АБСОЛЮТНЫЕ КООРДИНАТЫ ФОРМЫ)
* ThisForm.ClientToScreen() - LEFT, ThisForm.ClientToScreen(ThisForm, .T.) - TOP
* НАПРИМЕР АБСОЛЮТНЫЕ КООРДИНАТЫ КОНТРОЛА НА ФОРМЕ МОЖНО ПОЛУЧИТЬ ТАК :
* MESSAGEBOX('Left='+TRANSFORM(This.ClientToScreen(ThisForm,.F.)+OBJTOCLIENT(This,2))+;
*			' Top='+This.ClientToScreen(ThisForm,.T.)+TRANSFORM(OBJTOCLIENT(This,1)))
* P.S. СМ. This.GetMessagePos(.T./.F.) - ПОЛУЧЕНИЕ КООРДИНАТ КОНТРОЛА, ПОЛУЧИВШЕГО ПОСЛЕДНЕЕ СООБЩЕНИЕ
LPARAMETERS toForm AS Form, tlTop AS Logical
LOCAL lcPoint AS String
	lcPoint=REPLICATE(CHR(0), 8)
	*
	IF !THIS.isLoaded("ClientToScreen")
		DECLARE INTEGER ClientToScreen IN WIN32API INTEGER, STRING @
	ENDIF
	*
	ClientToScreen(m.toForm.HWnd, @lcPoint)
	*
	WITH This.Parent.oFunction
		RETURN IIF(m.tlTop,;
			.StringToLong(RIGHT(m.lcPoint, 4)), .StringToLong(LEFT(m.lcPoint, 4)))
	ENDWITH
	
ENDPROC
PROCEDURE closehandle
LPARAMETERS tnHandle AS Integer
	IF !THIS.isLoaded("CloseHandle")
		DECLARE INTEGER CloseHandle IN WIN32API	INTEGER
	ENDIF
	*
	CloseHandle(m.tnHandle)
ENDPROC
PROCEDURE colorbitsperpixel
* ГЛУБИНА ЦВЕТА В БИТАХ НА ПИКСЕЛ (СМ.COLORCOMBINATION)
LOCAL lnDeviceHandle AS Integer, lnIndexOfItem AS Integer,;
	lcDriverName AS String, lnBitsPerPixel AS Integer
	IF !THIS.isLoaded("CreateDC")
		DECLARE INTEGER CreateDC IN WIN32API STRING @, STRING @, STRING @, STRING @
	ENDIF
	*
	IF !THIS.isLoaded("GetDeviceCaps")
		DECLARE INTEGER GetDeviceCaps IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	IF !THIS.isLoaded("DeleteDC")
		DECLARE INTEGER DeleteDC IN WIN32API INTEGER @
	ENDIF
	*
	lcDriverName='DISPLAY'+CHR(0)
	lnBitsPerPixel=0
	lnDeviceHandle=CreateDC(@lcDriverName, '', '', .NULL.)
	*
	IF m.lnDeviceHandle>0
		lnIndexOfItem=BITSPIXEL	&& 12
		* КОЛИЧЕСТВО БИТ НА ПИКСЕЛЬ
		lnBitsPerPixel=GetDeviceCaps(@lnDeviceHandle, @lnIndexOfItem)
		DeleteDC(@lnDeviceHandle)
	ENDIF
RETURN m.lnBitsPerPixel

ENDPROC
PROCEDURE colorcombination
* КОЛИЧЕСТВО КОМБИНАЦИЙ ЦВЕТОВ (СМ.COLORBITSPERPIXEL)
* В СЛУЧАЕ ОДНОЙ ЦВЕТОВОЙ ПЛОСКОСТИ :
* 2^(1 ColorPlane * 08 BPS) = 256
* 2^(1 ColorPlane * 16 BPS) = 65536
* 2^(1 ColorPlane * 24 BPS) = 16777216
* 2^(1 ColorPlane * 32 BPS) = 4294967296

LOCAL lnDeviceHandle AS Integer, lnIndexOfItem AS Integer, lcDriverName AS String,;
	lnNumberBPixels AS Integerm, lnNumberPlanes AS Integer, lnColorCombination AS Integer
	IF !THIS.isLoaded("CreateDC")
		DECLARE INTEGER CreateDC IN WIN32API STRING @, STRING @, STRING @, STRING @
	ENDIF
	*
	IF !THIS.isLoaded("GetDeviceCaps")
		DECLARE INTEGER GetDeviceCaps IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	IF !THIS.isLoaded("DeleteDC")
		DECLARE INTEGER DeleteDC IN WIN32API INTEGER @
	ENDIF
	*
	lnColorCombination=0
	lcDriverName='DISPLAY'+CHR(0)
	lnDeviceHandle=CreateDC(@lcDriverName, '', '', .NULL.)
	*
	IF m.lnDeviceHandle>0
		lnIndexOfItem=PLANES		&& 14
		* КОЛИЧЕСТВО ЦВЕТОВЫХ ПЛОСКОСТЕЙ
		lnNumberPlanes=GetDeviceCaps(@lnDeviceHandle, @lnIndexOfItem)
		lnIndexOfItem=BITSPIXEL	&& 12
		* КОЛИЧЕСТВО БИТ НА ПИКСЕЛЬ
		lnNumberBPixels=GetDeviceCaps(@lnDeviceHandle, @lnIndexOfItem)
		DeleteDC(@lnDeviceHandle)
		* КОЛИЧЕСТВО ЦВЕТОВЫХ КОМБИНАЦИЙ
		lnColorCombination=2^(m.lnNumberPlanes*m.lnNumberBPixels)
	ENDIF
RETURN m.lnColorCombination

ENDPROC
PROCEDURE copyfile
* КОПИРОВАНИЕ ФАЙЛА ВМЕСТЕ С АТРИБУТАМИ R/S/H
* КОМПЕНСИРУЕТ НЕДОСТАТКИ ВСТРОЕННОЙ КОМАНДЫ COPY FILE ... TO ... КОТОРАЯ :
* 1) НЕ ВИДИТ СКРЫТЫЙ ИЛИ СИСТЕМНЫЙ ФАЙЛ-ИСТОЧНИК
* 2) НЕ ПРИСВАИВАЕТ АТРИБУТЫ ФАЙЛА ИСТОЧНИКА ФАЙЛУ ПРИЕМНИКУ
* 3) НЕ КОПИРУЕТ ОТКРЫТЫЙ НА ЗАПИСЬ ФАЙЛ-ИСТОЧНИК
* 4) АВТОМАТИЧЕСКИ СТАВИМ АТРИБУТ ARCHIVE ФАЙЛУ-ПРИЕМНИКУ
* 5) СОЗДАЕТ ФАЙЛЫ В LOWERCASE

* P.S.
* ВОЗМОЖНЫ РАСХОЖДЕНИЯ ВО ВРЕМЕНИ МОДИФИКАЦИИ SOURCE И TARGET ФАЙЛОВ
* ПРИ КОПИРОВАНИИ С FAT16/32 НА NTFS И НАОБОРОТ ДО 2-Х СЕКУНД
* (ТОЧНОСТЬ ХРАНЕНИЯ ВРЕМЕРИ МОДИФИФИКАЦИИ ФАЙЛА В FAT 1 СЕКУНДА, В NTFS 1 МИЛЛИСЕКУНДА)

* АЛЬТЕРНАТИВА FSO :
* oFSO = CreateObject('Scripting.FileSystemObject')
* oFSO.CopyFile('SourceFile','DestinationFile',.T.)
* ИЛИ КОПИРОВАНИЕ КАТАЛОГА ЦЕЛИКОМ :
* oFSO  =  CREATEOBJECT("Scripting.FileSystemObject")
* oFSO.СopyFolder('SourceFolder', 'DestinationFolder', .F.)
* ПРИЧЕМ ОШИБКИ ОТЛАВЛИВАТЬ COMRETURNERROR()
LPARAMETERS tcSource AS String, tcTarget AS String, tlOverwrite AS Logical
LOCAL lnSuccess AS Integer, lnOverwrite AS Integer
	lnSuccess = 0

	IF FILE(m.tcSource, 1)
		lnOverwrite = IIF(m.tlOverwrite, 0, 1)

		IF !THIS.isLoaded("CopyFile")
			DECLARE INTEGER CopyFile IN WIN32API STRING, STRING, INTEGER
		ENDIF

		lnSuccess = CopyFile(m.tcSource, m.tcTarget, m.lnOverwrite)
	ENDIF
RETURN m.lnSuccess <> 0
ENDPROC
PROCEDURE createcompatiblebitmap
* CREATE A BITMAP COMPATIBLE WITH THE DEVICE ASSOCIATED WITH THE SPECIFIED DEVICE CONTEXT

LPARAMETERS tnDC, tnWidth, tnHeight
LOCAL lnBitMap AS Integer
	IF !THIS.isLoaded("CreateCompatibleBitmap")
		DECLARE LONG CreateCompatibleBitmap IN Win32API LONG, LONG, LONG
	ENDIF
	*
	lnBitMap=CreateCompatibleBitmap(m.tnDC, m.tnWidth, m.tnHeight)
RETURN m.lnBitMap
ENDPROC
PROCEDURE createcompatibledc
* CREATE A MEMORY DEVICE CONTEXT (DC) COMPATIBLE WITH THE SPECIFIED DEVICE
LPARAMETERS tnDC
LOCAL lnDC AS Integer
	IF !THIS.isLoaded("CreateCompatibleDC")
		DECLARE LONG CreateCompatibleDC	IN Win32API LONG
	ENDIF
	*
	lnDC=CreateCompatibleDC(m.tnDC)
RETURN m.lnDC
ENDPROC
PROCEDURE createdirectory
* СОЗДАНИЕ КАТАЛОГА
* P.S. НИКАКИХ ПРЕИМУЩЕСТВ ПЕРЕД ВСТРОЕННОЙ MKDIR,
* ТОЛЬКО НЕДОСТАТОК - НЕ СОЗДАЕТ ЦЕПОЧКУ ВЛОЖЕННЫХ КАТАЛОГОВ.
LPARAMETERS tcFolder AS String
LOCAL lnSuccess AS Integer
	lnSuccess = 0

	IF !DIRECTORY(m.tcFolder, 1)
		IF !THIS.isLoaded("CreateDirectory")
			DECLARE INTEGER CreateDirectory IN WIN32API STRING ,INTEGER @
		ENDIF
		* 0 - DEFAULT SECURITY DESCRIPTOR
		lnSuccess = CreateDirectory(m.tcFolder, 0)
	ENDIF
RETURN m.lnSuccess <> 0
ENDPROC
PROCEDURE createellipticrgn
* СОЗДАНИЕ ЭЛИПТИЧЕСКОЙ ОБЛАСТИ В ОКНЕ
LPARAMETERS tnXUpperLeft AS Integer, tnYUpperLeft AS Integer,;
	tnXLowerRight AS Integer, tnYLowerRight AS Integer
LOCAL lnRegionHandle AS Integer
	IF !THIS.isLoaded("CreateEllipticRgn")
		DECLARE INTEGER CreateEllipticRgn IN WIN32API INTEGER, INTEGER, INTEGER, INTEGER
	ENDIF

	lnRegionHandle=CreateEllipticRgn(m.tnXUpperLeft, m.tnYUpperLeft, m.tnXLowerRight, m.tnYLowerRight)
RETURN m.lnRegionHandle

ENDPROC
PROCEDURE createmutex
* СОЗДАНИЕ МЬЮТЕКСА С УНИКАЛЬНЫМ ИДЕНТИФИКАТОРОМ TCUNIQUE
* MUTEX - ОБЪЕКТ СИНХРОНИЗАЦИИ БЕЗ СЧЁТЧИКА, SEMAPHORE - СО СЧЕТЧИКОМ
* РЕЗУЛЬТАТ - УСПЕХ СОЗДАНИЯ
LPARAMETERS tcUnique AS String
LOCAL lnError AS Integer, lnHandle AS Integer
* TCUNIQUE IS LIMITED TO MAX_PATH CHARACTERS AND CAN CONTAIN ANY
* CHARACTER EXCEPT THE BACKSLASH PATH-SEPARATOR CHARACTER (\)
* NAME COMPARISON IS CASE SENSITIVE
	tcUnique = CHRTRAN(tcUnique, '\', '_')

	IF !THIS.isLoaded("CreateMutex")
		DECLARE INTEGER CreateMutex IN WIN32API INTEGER, INTEGER, STRING
	ENDIF
	* ХЭНДЛ ОБЪЕКТА СИНХРОНИЗАЦИИ
	lnHandle = CreateMutex(0, 1, m.tcUnique)
*!*		lnError = This.GetLastError()
RETURN m.lnHandle &&lnError <> ERROR_ALREADY_EXISTS AND m.lnError <> ERROR_INVALID_HANDLE

ENDPROC
PROCEDURE createrectrgn
* СОЗДАНИЕ ПРЯМОУГОЛЬНОЙ ОБЛАСТИ В ОКНЕ
LPARAMETERS tnXUpperLeft AS Integer, tnYUpperLeft AS Integer,;
	tnXLowerRight AS Integer, tnYLowerRight AS Integer
LOCAL lnRegionHandle AS Integer
	IF !THIS.isLoaded("CreateRectRgn")
		DECLARE INTEGER CreateRectRgn IN WIN32API INTEGER, INTEGER, INTEGER, INTEGER
	ENDIF
	*
	lnRegionHandle=CreateRectRgn(m.tnXUpperLeft, m.tnYUpperLeft, m.tnXLowerRight, m.tnYLowerRight)
RETURN m.lnRegionHandle

ENDPROC
PROCEDURE createsemaphore
* СОЗДАНИЕ СЕМАФОРА С УНИКАЛЬНЫМ ИДЕНТИФИКАТОРОМ TCUNIQUE
* СЕМАФОР - ОБЪЕКТ СИНХРОНИЗАЦИИ СО СЧЁТЧИКОМ, MUTEX - БЕЗ
* РЕЗУЛЬТАТ - НЕНУЛЕВОЙ УКАЗАТЕЛЬ НА СОЗДАННЫЙ СЕМАФОР ИЛИ 0, ЕСЛИ СОЗДАТЬ НЕ УДАЛОСЬ
LPARAMETERS tcUnique AS String
LOCAL lnHandle AS Integer
* TCUNIQUE IS LIMITED TO MAX_PATH CHARACTERS AND CAN CONTAIN ANY
* CHARACTER EXCEPT THE BACKSLASH PATH-SEPARATOR CHARACTER (\)
* NAME COMPARISON IS CASE SENSITIVE
	tcUnique=CHRTRAN(m.tcUnique, '\', '_')

	IF !THIS.isLoaded("CreateSemaphore")
		DECLARE INTEGER CreateSemaphore IN WIN32API INTEGER, INTEGER, INTEGER, STRING
	ENDIF

	lnHandle = CreateSemaphore (0, 1, 1, m.tcUnique)
RETURN m.lnHandle

#IF .F.
	* ПЕРВЫЙ ВАРИАНТ ПРОВЕРКИ ПОВТОРНОГО ЗАПУСКА ПРИЛОЖЕНИЯ НА СЕМАФОРЕ
FUNCTION AlreadyRunning
LPARAMETERS tcUnique
	LOCAL lcUnique, lnHandle
	tcUnique = CHRTRAN(tcUnique, '\', '_')
	DECLARE INTEGER OpenSemaphore IN WIN32API INTEGER, INTEGER, STRING
	lnHandle = OpenSemaphore(STANDARD_RIGHTS_REQUIRED, 0, tcUnique)
	CLEAR DLLS 'OpenSemaphore'
	IF lnHandle = 0
		DECLARE INTEGER CreateSemaphore IN WIN32API INTEGER, INTEGER, INTEGER, STRING
		lnHandle = CreateSemaphore (0, 1, 1, tcUnique)
		CLEAR DLLS 'CreateSemaphore'
		IF lnHandle = 0
		    DECLARE INTEGER GetLastError IN WIN32API
			* ОШИБКА СОЗДАНИЯ СЕМАФОРА
			MESSAGEBOX(MSG_ERR_SEMAPHORE + ' : ' + TRANSFORM(GetLastError()), 64, MAIN_CAPTION)
			* ТОЛЬКО ПРЕДУПРЕДИМ И ПРОДОЛЖИМ ВЫПОЛНЕНИЕ
			CLEAR DLLS 'GetLastError'
		ENDIF
		RETURN .F.
	ENDIF
	RETURN

	* ВТОРОЙ ВАРИАНТ ПРОВЕРКИ ПОВТОРНОГО ЗАПУСКА ПРИЛОЖЕНИЯ НА СЕМАФОРЕ
	FUNCTION AlreadyRunning1
	LPARAMETERS tcUnique
	LOCAL lnError
	tcUnique = CHRTRAN(tcUnique, '\', '_')
	DECLARE INTEGER GetLastError IN WIN32API
	DECLARE INTEGER CreateSemaphore IN WIN32API INTEGER, INTEGER, INTEGER, STRING
	CreateSemaphore(0, 1, 1, tcUnique)
	lnError = GetLastError()
	CLEAR DLLS 'GetLastError', 'CreateSemaphore'
	RETURN lnError # 0

	* ТРЕТИЙ И ПОСЛЕДНИЙ ВАРИАНТ ПЕРЕПИСАН НА МЬЮТЕКСЕ ;)

#ENDIF

ENDPROC
PROCEDURE deletedc
* DELETES THE SPECIFIED DEVICE CONTEXT
LPARAMETERS tnDCHandle AS Integer
	IF !THIS.isLoaded("DeleteDC")
		DECLARE LONG DeleteDC IN Win32API LONG
	ENDIF

	DeleteDC(m.tnDCHandle)
ENDPROC
PROCEDURE deletefile
* УДАЛЕНИЕ ФАЙЛА
* 1) КАК И ВСТРОЕННАЯ КОМАНДА ERASE НЕ УМЕЕТ УДАЛЯТЬ READONLY ФАЙЛЫ
* 2) ЗАТО УДАЛЯЕТ ФАЙЛЫ SYSTEM И HIDDEN, КОТОРЫЕ ERASE НЕ ВИДИТ
LPARAMETERS tcPathFileName AS String
LOCAL lnSuccess AS Integer
	lnSuccess = 0

	IF FILE(m.tcPathFileName, 1)
		IF !THIS.isLoaded("DeleteFile")
			DECLARE INTEGER DeleteFile IN WIN32API STRING
		ENDIF

		lnSuccess = DeleteFile(m.tcPathFileName)
	ENDIF
RETURN m.lnSuccess <> 0

ENDPROC
PROCEDURE deleteobject
* DELETES A LOGICAL PEN, BRUSH, FONT, BITMAP, REGION, OR PALETTE, FREEING ALL SYSTEM RESOURCES ASSOCIATED WITH THE OBJECT
* ПРИМЕНЯЕТСЯ, НАПРИМЕР, ДЛЯ УДАЛЕНИЯ This.CreateEllipticRgn()
LPARAMETERS tnHandle AS Integer
	IF !THIS.isLoaded("DeleteObject")
		DECLARE INTEGER DeleteObject IN WIN32API INTEGER
	ENDIF

	DeleteObject(m.tnHandle)


ENDPROC
PROCEDURE dllregisterserver
* РЕГИСТРАЦИЯ ACTIVEX OCX == DLL БИБЛИОТЕКИ В РЕЕСТРЕ
* ПАРАМЕТР : ПУТЬ И ИМЯ OCX ФАЙЛА
* РЕЗУЛЬТАТ : 0 В СЛУЧАЕ УСПЕХА ИЛИ КОД ОШИБКИ
* СМ. This.RegSvr32()

LPARAMETERS tcOcxFileName AS String
LOCAL lnError AS Integer
	tcOcxFileName=ALLTRIM(m.tcOcxFileName)
	*
	IF ' '$m.tcOcxFileName
		tcOcxFileName='"'+m.tcOcxFileName+'"'
	ENDIF
	*
	IF !THIS.isLoaded("DllRegisterServer")
		DECLARE INTEGER DllRegisterServer IN m.&tcOcxFileName
	ENDIF
	*
	lnError=DllRegisterServer()
RETURN m.lnError

ENDPROC
PROCEDURE dllunregisterserver
* УДАЛЕНИЕ РЕГИСТРАЦИИ ACTIVEX OCX == DLL БИБЛИОТЕКИ ИЗ РЕЕСТРА
* ПАРАМЕТР : ПУТЬ И ИМЯ OCX ФАЙЛА
* РЕЗУЛЬТАТ : 0 В СЛУЧАЕ УСПЕХА ИЛИ КОД ОШИБКИ
* СМ. This.RegSvr32()
LPARAMETERS tcOcxFileName AS String
LOCAL lnError AS Integer
	tcOcxFileName=ALLTRIM(m.tcOcxFileName)
	IF ' '$m.tcOcxFileName
		tcOcxFileName='"'+m.tcOcxFileName+'"'
	ENDIF
	*
	IF !THIS.isLoaded("DllUnregisterServer")
		DECLARE INTEGER DllUnregisterServer IN m.&tcOcxFileName
	ENDIF
	*
	lnError=DllUnregisterServer()
RETURN m.lnError

ENDPROC
PROCEDURE drawicon
* РИСУЕМ ИКОНКУ tnIconHandle НА УСТРОЙСТВЕ tnDCHandle
* ИСПОЛЬЗОВАТЬ В СВЯЗКЕ GetDC->LoadIcon->DrawIcon->ReleaseDC
* This.DrawIcon(tnDCHandle, tnIconHandle, 40, 20)
LPARAMETERS tnDCHandle AS Integer, tnIconHandle AS Integer,;
	tnLeft AS Integer, tnTop AS Integer
	IF !THIS.isLoaded("DrawIcon")
		DECLARE SHORT DrawIcon IN WIN32API INTEGER, INTEGER, INTEGER, INTEGER
	ENDIF
	*
	DrawIcon(m.tnDCHandle, m.tnLeft, m.tnTop, m.tnIconHandle)
ENDPROC
PROCEDURE drawiconresource
* РИСУЕМ ИКОНКУ tnIconId НА ФОРМЕ tnHWnd В КООРДИНАТАХ tnLeft, tnTop
* P.S. : СМ. WINAPI.H РАЗДЕЛ ICON
LPARAMETERS tnHWnd AS Integer, tnIconId AS Integer,;
	tnLeft AS Integer, tnTop AS Integer
LOCAL lnDCHandle AS Integer, lnIconHandle AS Integer, llSuccess AS Logical
	llSuccess=.F.
	lnDCHandle=This.GetDC(m.tnHWnd)
	*
	IF m.lnDCHandle<>0
		lnIconHandle=This.LoadIcon(m.tnIconId)
		*
		IF m.lnIconHandle>0
			llSuccess=This.DrawIcon(m.lnDCHandle, m.lnIconHandle, m.tnLeft, m.tnTop)
		ENDIF
		*
		This.ReleaseDC(m.tnHWnd, m.lnDCHandle)
	ENDIF
RETURN m.llSuccess

*!*	Удобно для самопального MESSAGEBOX() пользовать,a не грузить бээмпэшки,
*!* но видимо придется перерисовывать форму в ThisForm.Paint(), иначе исчезают,
*!* зато можно их накладывать друг на друга ;)))

*!*	w=CREATEOBJECT('Form')
*!*	w.Visible = .T.
*!*	o=NEWOBJECT('cntProc','c:\vfp\main\prog\custom')
*!*	o.Api.DrawIconResource(w.Hwnd, 32513, 40, 40)
*!*	MESSAGEBOX('')
*!*	RELEASE o, w

ENDPROC
PROCEDURE exitprocess
* THE EXITPROCESS FUNCTION ENDS A PROCESS AND ALL ITS THREADS.
* EXITPROCESS IS THE PREFERRED METHOD OF ENDING A PROCESS.
* THIS FUNCTION PROVIDES A CLEAN PROCESS SHUTDOWN.
LPARAMETERS tnExitCode AS Integer
	tnExitCode=IIF(VARTYPE(m.tnExitCode)='N', m.tnExitCode, 0)

	IF !THIS.isLoaded("ExitProcess")
		DECLARE ExitProcess IN WIN32API INTEGER uExitCode 
	ENDIF

	ExitProcess(m.tnExitCode)
ENDPROC
PROCEDURE exitwindowsex
* ЗАВЕРШЕНИЕ РАБОТЫ WINDOWS
* ДЛЯ WINNT BASED OS НЕОБХОДИМО ДОБАВИТЬ РАБОТУ С ПРАВАМИ КАК ЗДЕСЬ :
* HTTP://SUPPORT.MICROSOFT.COM/DEFAULT.ASPX?SCID=KB;EN-US;Q251310
LPARAMETERS tnFlag AS Integer, tnReason AS Integer
	tnFlag=IIF(VARTYPE(m.tnFlag)='N', m.tnFlag, EWX_SHUTDOWN)
	tnReason=IIF(VARTYPE(m.tnReason)='N', m.tnReason, 0)

	IF !THIS.isLoaded("ExitWindowsEx")
		DECLARE INTEGER ExitWindowsEx IN WIN32API INTEGER, INTEGER
	ENDIF

	ExitWindowsEx(m.tnFlag, m.tnReason)
ENDPROC
PROCEDURE fatalappexit
* АВАРИЙНОЕ ЗАВЕРШЕНИЕ РАБОТЫ ПРИЛОЖЕНИЯ.
* ВЫДАЕТ ОКНО С ЗАГОЛОВКОМ 'Fatal Application Exit',
* ОДНОСТРОЧНЫМ СООБЩЕНИЕМ И КНОПКОЙ 'OK'.
* ПАРАМЕТР - ОДНОСТРОЧНОЕ СООБЩЕНИЕ С РЕКОМЕНДУЕМОЙ ДЛИННОЙ НЕ БОЛЕЕ 35 СИМВОЛОВ
* ВНИМАНИЕ ! MAY NOT ALWAYS FREE AN APPLICATION'S MEMORY OR CLOSE ITS FILES,
*			 AND IT MAY CAUSE A GENERAL FAILURE OF THE SYSTEM
LPARAMETERS tcMessage AS String
	DECLARE FatalAppExit IN WIN32API INTEGER, STRING
	*
	FatalAppExit(0, m.tcMessage)
	CLEAR DLLS 'FatalAppExit'

ENDPROC
PROCEDURE findwindow
* ВОЗВРАЩАЕТ ХЭНДЛ WINDOWS ОКНА ПО ПОДСТРОКЕ В ЗАГОЛОВКЕ
* УДОБНО ИСПОЛЬЗОВАТЬ В ПАРЕ С THIS.ACTIVATEWINDOW()
* IF ActivateWindow(FindWindow(tcCaption)) ...
LPARAMETER tcCaption
LOCAL lnHandle, lcCaption
	IF !THIS.isLoaded("GetActiveWindow")
		DECLARE INTEGER GetActiveWindow	IN WIN32API
	ENDIF

	IF !THIS.isLoaded("GetWindow")
		DECLARE INTEGER GetWindow IN WIN32API INTEGER, INTEGER
	ENDIF

	IF !THIS.isLoaded("GetWindowText")
		DECLARE INTEGER GetWindowText IN WIN32API INTEGER, STRING, INTEGER
	ENDIF
	* ПОЛУЧИМ ХЭНДЛ АКТИВНОГО ОКНА
	lnHandle = GetActiveWindow()
	* ПЕРЕБЕРЕМ ВСЕ ОКНА
	DO WHILE m.lnHandle <> 0
		* СЛЕДУЮЩЕЕ ОКНО
		lnHandle = GetWindow(m.lnHandle, 2)
		lcCaption = REPLICATE(CHR(0), 80)
		* ПОЛУЧИМ ЗАГОЛОВОК
		GetWindowText(m.lnHandle, @lcCaption, 80)
		* ПРОВЕРИМ ВХОЖДЕНИЕ ПОДСТРОКИ В ЗАГОЛОВОК
		IF UPPER(ALLTRIM(m.tcCaption)) $ UPPER(m.lcCaption)
			EXIT
		ENDIF
	ENDDO
RETURN m.lnHandle
ENDPROC
PROCEDURE flashwindow
* МИГНУТЬ ЗАГОЛОВКОМ ОКНА В ТАСК-БАРЕ
* P.S. TYPICALLY, A WINDOW IS FLASHED TO INFORM THE USER THAT THE WINDOW
*      REQUIRES ATTENTION BUT THAT IT DOES NOT CURRENTLY HAVE THE KEYBOARD FOCUS
* DO WHILE Form.WindowState = 1
*	This.FlashWindow(HWnd)
*	This.Sleep(500)  
*	DOEVENTS
* ENDDO  
LPARAMETERS tnWindowHandle AS Integer
	IF !THIS.isLoaded("FlashWindow")
		DECLARE INTEGER FlashWindow IN WIN32API INTEGER, INTEGER
	ENDIF

	FlashWindow(m.tnWindowHandle, 1)

*!*	"Когда программа требует ввода данных, она может либо выскочить на передний план,
*!*	либо начать мигать кнопкой на панели задач. Вы можете установить время,в течении
*!*	которого программа будет сигнализиоровать перед этим выходом"
*!*	В HKEY_CURRENT_USER\Control Panel\Desktop - параметр ForegroundLockTimeout
*!*	типа DWORD = время задержки до "перехвата" фокуса в миллисекундах:
*!*	0 — окно сразу выскакивает вперед.
*!*	Там же: DWORD-параметр ForegroundFlashCount = нужное число миганий.
*!*	Значения устанавливаются в десятичной системе:
*!*	0 заставит кнопку мигать бесконечно.
*!*	(из справочника - "Реестр Windows" А.Климов, И. Чеботарев)

*!*	Если надо чтоб МИГАЛ постоянно (не просто мигнул и выделил кнопку)
*!*	то есть ещё FlashWindowEx - там задаётся и число миганий, и интервал, и ещё много чего.
*!*	DECLARE INTEGER FlashWindowEx IN WIN32API STRING pfwi  
*!*	  #DEFINE FLASHW_STOP         0  
*!*	  #DEFINE FLASHW_CAPTION      0x00000001  
*!*	  #DEFINE FLASHW_TRAY         0x00000002  
*!*	  #DEFINE FLASHW_ALL          BITOR(FLASHW_CAPTION, FLASHW_TRAY)  
*!*	  #DEFINE FLASHW_TIMER        0x00000004  
*!*	  #DEFINE FLASHW_TIMERNOFG    0x0000000C  
*!*	    
*!*	 *_SCREEN.WindowState=1  
*!*	 * Можно и не минимизировать окно для данной комбинации параметров!  
*!*	    
*!*	 * Укажем моргнуть 5 раз с интервалом по умолчанию - как моргает курсор ввода  
*!*	  lcFI = n2dword(20) + n2dword(_VFP.hWnd) + n2dword(FLASHW_ALL) + n2dword(5) + n2dword(0)  
*!*	  ? FlashWindowEx(m.lcfi)  
*!*	    
*!*	    
*!*	 * Укажем моргать бесконечно, "редко" (интервал 2 секунды), и только кнопкой на панели...  
*!*	  INKEY(10) && Дабы узреть паузу между первым и вторым запусками  
*!*	  lcFI = n2dword(20) + n2dword(_VFP.hWnd) + n2dword(BITOR(FLASHW_TRAY, FLASHW_TIMER)) + n2dword(0) + n2dword(2000)  
*!*	  ? FlashWindowEx(m.lcfi)  
*!*	    
*!*	 * Можно в любой момент прекратить моргание, зададим останов через 15 секунд  
*!*	  INKEY(15)  
*!*	  lcFI = n2dword(20) + n2dword(_VFP.hWnd) + n2dword(FLASHW_STOP) + n2dword(0) + n2dword(0)  
*!*	  ? FlashWindowEx(m.lcfi)  
*!*	    
*!*	  FUNCTION n2dword (tnNum)  
*!*	    lcRes = CHR(m.tnNum%256)  
*!*	    m.tnNum = INT(m.tnNum/256)  
*!*	    lcRes = m.lcRes + CHR(m.tnNum%256)  
*!*	    m.tnNum = INT(m.tnNum/256)  
*!*	    lcRes = m.lcRes + CHR(m.tnNum%256)  
*!*	    m.tnNum = INT(m.tnNum/256)  
*!*	    lcRes = m.lcRes + CHR(m.tnNum%256)  
*!*	  RETURN m.lcRes
ENDPROC
PROCEDURE freelibrary
* ОСВОБОЖДЕНИЕ ACTIVEX OCX == DLL БИБЛИОТЕКИ
* ПАРАМЕТР : ХЭНДЛ ЗАГРУЖЕННОЙ БИБЛИОТЕКИ
* РЕЗУЛЬТАТ : УСПЕХ ОПЕРАЦИИ
* The FreeLibrary function decrements the reference count of the loaded dynamic-link
* library (DLL). When the reference count reaches zero, the module is unmapped from
* the address space of the calling process and the handle is no longer valid. 
* СМ. This.RegSvr32()
LPARAMETERS tnHandle AS Integer
LOCAL lnError AS Integer
	IF !THIS.isLoaded("FreeLibrary")
		DECLARE INTEGER FreeLibrary IN WIN32API INTEGER
	ENDIF

	lnError=FreeLibrary(m.tnHandle)
RETURN m.lnError<>0

ENDPROC
PROCEDURE gdicreatebitmap
LPARAMETERS tnWidth as Integer, tnHeight as Integer,;
			tlPlanes as UINT, tlBitsPerPel as UINT, tlpvBits as String
LOCAL llHandleBmp as HANDLE
	IF !THIS.isLoaded("CreateBitmap")
		DECLARE HANDLE CreateBitmap IN GDI32 INTEGER nWidth, INTEGER nHeight,;
				UINT cPlanes, UINT cBitsPerPel, PSTR lpvBits
	ENDIF
	*
	llHandleBmp=CreateBitmap(m.tnWidth, m.tnHeight, m.tlPlanes, m.tlBitsPerPel, @tlpvBits)
RETURN m.llHandleBmp
ENDPROC
PROCEDURE gdicreatepatternbrush
LPARAMETERS thBitmap AS HANDLE
LOCAL llHandleBr as Long
	IF !THIS.isLoaded("CreatePatternBrush")
		DECLARE HANDLE CreatePatternBrush IN GDI32 HANDLE hBitmap
	ENDIF
	*
	llHandleBr=CreatePatternBrush(m.thBitmap)
RETURN m.llHandleBr
ENDPROC
PROCEDURE gdicreatepen
LPARAMETERS tnPenStyle AS Integer, tnWidth as Integer, tlColor as Long
LOCAL llHandlePen as Long
	IF !THIS.isLoaded("CreatePen")
		DECLARE HANDLE CreatePen IN GDI32 INTEGER fnPenStyle, INTEGER nWidth, COLORREF crColor
	ENDIF
	*
	llHandlePen=CreatePen(m.tnPenStyle, m.tnWidth, m.tlColor)
RETURN m.llHandlePen
ENDPROC
PROCEDURE gdigetstockobject
LPARAMETERS tnfnObject as Integer
LOCAL llHandleObj as HANDLE
	IF !THIS.isLoaded("GetStockObject")
		DECLARE HANDLE GetStockObject IN GDI32 INTEGER fnObject
	ENDIF
	*
	llHandlePen=GetStockObject(m.tnfnObject)
RETURN m.llHandleObj

ENDPROC
PROCEDURE gdipatblt
LPARAMETERS thDC AS Integer, tnXLeft as Integer, tnYLeft as Integer,;
			tnWidth as Integer, tnHeight as Integer, tndwRop as Integer
LOCAL llRetVal as Boolean
	IF !THIS.isLoaded("PatBlt")
		DECLARE BOOL PatBlt IN GDI32 HANDLE hDC, INTEGER nXLeft, INTEGER nYLeft,;
				INTEGER nWidth, INTEGER nHeight, INTEGER dwRop
	ENDIF

	llRetVal=PatBlt(m.thDC, m.tnXLeft, m.tnYLeft, m.tnWidth, m.tnHeight, m.tndwRop)
RETURN m.llRetVal
ENDPROC
PROCEDURE gdipdisposeimage
* DESTROY IMAGE
LPARAMETERS tnImage AS Integer
	IF !THIS.isLoaded("GdipDisposeImage")
		DECLARE LONG GdipDisposeImage IN GDIPLUS.DLL LONG
	ENDIF
	*
	GdipDisposeImage(m.tnImage)
ENDPROC
PROCEDURE gdipgetimageheight
* ВЕТИКАЛЬНЫЙ РАЗМЕР КАРТИНКИ В ПИКСЕЛАХ
* ВОЗВРАЩАЕТ -1 ПРИ НЕУДАЧЕ
* ПАРАМЕТР = ИМЯ ФАЙЛА
LPARAMETERS tcFileName AS String
LOCAL lnHeight AS Integer, lnToken AS Integer, lnImage AS Integer
	lnHeight=-1
	*
	IF FILE(m.tcFileName)
		* GDIPLUS INIT
		lnToken=This.GdiplusStartup()
		IF m.lnToken<>0
			* CREATE IMAGE FROM FILE
			lnImage=This.GdipLoadImageFromFile(m.tcFileName)
			*
			IF m.lnImage<>0
				IF !THIS.isLoaded("GdipGetImageHeight")
					DECLARE LONG GdipGetImageHeight IN GDIPLUS.DLL LONG, LONG @ WIDTH
				ENDIF
				*
				GdipGetImageHeight(m.lnImage, @lnHeight)
				* DESTROY IMAGE
				This.GdipDisposeImage(m.lnImage)
			ENDIF
			* GDIPLUS DESTROY
			This.GdiplusShutdown(m.lnToken)
		ENDIF
	ENDIF
RETURN m.lnHeight

ENDPROC
PROCEDURE gdipgetimagerawformat
* ВОЗВРАЩАЕТ GDI+ GUID ФОРМАТА ИЗОБРАЖЕНИЯ
* В ФОРМАТЕ СТРОКИ VARBINARY 16 ИЛИ ''
* ПАРАМЕТР : ИМЯ ФАЙЛА
* СМ. THIS.PARENT.oFUNCTION.GETGDIGUIDDESCRIPTION()
LPARAMETERS tcFileName AS String
LOCAL lnToken AS Integer, lnImage AS Integer, lcGUID AS String, lnStatus AS Integer
	lnStatus = -1
	IF FILE(m.tcFileName)
		* GDIPLUS INIT
		lnToken = This.GdiplusStartup()
		IF m.lnToken<>0
			* CREATE IMAGE FROM FILE
			lnImage = This.GdipLoadImageFromFile(m.tcFileName)

			IF lnImage<>0
				lcGUID = REPLICATE(CHR(0), 16)

				IF !THIS.isLoaded("GdipGetImageRawFormat")
					DECLARE INTEGER GdipGetImageRawFormat IN GDIPLUS.DLL INTEGER, STRING @
				ENDIF

				lnStatus = GdipGetImageRawFormat(m.lnImage, @lcGUID)
				* DESTROY IMAGE
				This.GdipDisposeImage(m.lnImage)
			ENDIF
			* GDIPLUS DESTROY
			This.GdiplusShutdown(m.lnToken)
		ENDIF
	ENDIF
RETURN IIF(m.lnStatus = 0, CAST(m.lcGUID AS Q(16)), '')


ENDPROC
PROCEDURE gdipgetimagewidth
* ГОРИЗОНТАЛЬНЫЙ РАЗМЕР КАРТИНКИ В ПИКСЕЛАХ
* ВОЗВРАЩАЕТ -1 ПРИ НЕУДАЧЕ
* ПАРАМЕТР = ИМЯ ФАЙЛА
LPARAMETERS tcFileName AS String
LOCAL lnWidth AS Integer, lnToken AS Integer, lnImage AS Integer
	lnWidth=-1
	*
	IF FILE(m.tcFileName)
		* GDIPLUS INIT
		lnToken=THIS.GdiplusStartup()
		*
		IF m.lnToken<>0
			* CREATE IMAGE FROM FILE
			lnImage=THIS.GdipLoadImageFromFile(m.tcFileName)
			*
			IF m.lnImage<>0
				IF !THIS.isLoaded("GdipGetImageWidth")
					DECLARE LONG GdipGetImageWidth IN GDIPLUS.DLL LONG, LONG @
				ENDIF
				*
				GdipGetImageWidth(m.lnImage, @lnWidth)
				* DESTROY IMAGE
				THIS.GdipDisposeImage(m.lnImage)
			ENDIF
			* GDIPLUS DESTROY
			THIS.GdiplusShutdown(m.lnToken)
		ENDIF
	ENDIF
RETURN m.lnWidth
ENDPROC
PROCEDURE gdiploadimagefromfile
* CREATE IMAGE FROM FILE
LPARAMETERS tcFileName AS String
LOCAL lnImage AS Integer
	lnImage=0
	* CONVERTS DOUBLE-BYTE CHARACTERS TO UNICODE (WIDE CHARACTERS).
	tcFileName=STRCONV(m.tcFileName+CHR(0), 5)
	* BUG : БЕЗ .DLL НЕ ПАШЕТ ПОД W98 И W2K
	IF !THIS.isLoaded("GdipLoadImageFromFile")
		DECLARE INTEGER GdipLoadImageFromFile IN GDIPLUS.DLL STRING, INTEGER @
	ENDIF
	*
	GdipLoadImageFromFile(m.tcFileName, @lnImage)
RETURN m.lnImage

ENDPROC
PROCEDURE gdiplusshutdown
* GDIPLUS DESTROY
LPARAMETERS tnToken
	IF !THIS.isLoaded("GdiplusShutdown")
		DECLARE LONG GdiplusShutdown IN GDIPLUS.DLL LONG
	ENDIF
	*
	GdiplusShutdown(m.tnToken)
ENDPROC
PROCEDURE gdiplusstartup
* GDIPLUS INIT
LOCAL lcStart AS String, lnToken AS Integer
	IF !THIS.isLoaded("GdiplusStartup")
		DECLARE LONG GdiplusStartup IN GDIPLUS.DLL LONG @, STRING @, LONG @
	ENDIF
	* GDIPLUSSTARTUPINPUT STRUCTURE SIZE = 16
	lcStart=CHR(1)+REPLICATE(CHR(0), 15)
	lnToken=0
	GdiplusStartup(@lnToken, @lcStart, 0)
	* БЕЗ ЗАДЕРЖКИ ПАДАЛО ПОД W98 И W2K,
	* ПОКА ВЕЗДЕ НЕ ДОБАВИЛ .DLL К IN GDIPLUS
	* This.Sleep(100)
RETURN m.lnToken

ENDPROC
PROCEDURE gdirectangle
LPARAMETERS thDC AS HANDLE, tnLeftRect as Integer, tnTopRect as Integer,;
			tnRightRect as Integer, tnBottomRect as Integer
LOCAL llRetVal as BOOL
	IF !THIS.isLoaded("Rectangle")
		DECLARE BOOL Rectangle IN GDI32 ;
				HANDLE hDC, INTEGER nLeftRect, INTEGER nTopRect,;
				INTEGER nRightRect, INTEGER nBottomRect
	ENDIF
	*
	llRetVal=Rectangle(m.thDC, m.tnLeftRect, m.tnTopRect, m.tnRightRect, m.tnBottomRect)
RETURN m.llRetVal

ENDPROC
PROCEDURE gdisetrop2
LPARAMETERS thDC as HANDLE, tnfnDrawMode as Integer
LOCAL llRetVal as INTEGER
	IF !THIS.isLoaded("SetROP2")
		DECLARE INTEGER SetROP2 IN GDI32 HANDLE hDC, INTEGER fnDrawMode
	ENDIF
	*
	llRetVal=SetROP2(m.thDC, m.tnfnDrawMode)
RETURN m.llRetVal


ENDPROC
PROCEDURE getapppath
* ПОЛНЫЙ ПУТЬ К ПРИЛОЖЕНИЮ ПО РАСШИРЕНИЮ ИМЕНИ ФАЙЛА
* This.GetAppPath('DOC') = 'C:\Program Files\Microsoft Office\Office10\WINWORD.EXE'
* This.GetAppPath('TIF') = 'C:\PROGRA~1\CORELD~1\programs\photopnt.exe'
LPARAMETERS tcExtention AS String
	* ПРИВЕДЕМ РАСШИРЕНИЕ К ВИДУ, НАПРИМЕР : '.DOC', '.TIF'
	lcExtention=ALLTRIM(m.tcExtention)
	lcExtention=IIF(LEFT(m.lcExtention, 1)<>'.', '.', '') + m.lcExtention
	* ЧИТАЕМ ВЕТКУ ВИДА HKEY_CLASSES_ROOT + '.DOC' ИЛИ HKEY_CLASSES_ROOT+'.TIF'
	lcKeyValue=This.RegGetKey(REG_HKEY_CLASSES_ROOT, m.lcExtention)
	* ПОЛУЧАЕМ СТРОКИ ТИПА : 'Word.Document.8' ИЛИ 'CorelPhotoPaint.Image.7'
	* P.S.: ХОРОШИМ ТОНОМ СЧИТАЕТСЯ В КОНЦЕ УКАЗЫВАТЬ ВЕРСИЮ ПРИЛОЖЕНИЯ, НАПРИМЕР '.7' ИЛИ '.8'
	IF !EMPTY(m.lcKeyValue)
		* ДОБАВЛЯЕМ СТРОКУ '\Shell\Open\Command'
		lcKeyValue=m.lcKeyValue+REG_KEY_APPPATH
		* И ЧИТАЕМ ТАМ-ЖЕ ЗНАЧЕНИЕ ВЕТКИ ВИДА :
		* HKEY_CLASSES_ROOT+'Word.Document.8\Shell\Open\Command' ИЛИ
		* HKEY_CLASSES_ROOT+'CorelPhotoPaint.Image.7\Shell\Open\Command'
		lcKeyValue=This.RegGetKey(REG_HKEY_CLASSES_ROOT, m.lcKeyValue)
		* ПОЛУЧАЕМ СТРОКИ ВИДА :
		* "C:\Program Files\Microsoft Office\Office10\WINWORD.EXE" /n /dde
		* C:\PROGRA~1\CORELD~1\programs\photopnt.exe /dde
		IF !EMPTY(m.lcKeyValue)
			* УБЕРЕМ ДВОЙНЫЕ КАВЫЧКИ ДЛИННОГО ИМЕНИ ФАЙЛА
			lcKeyValue=CHRTRAN(m.lcKeyValue, '"', '')

			IF '.EXE'$UPPER(m.lcKeyValue)
				* ОТБРОСИМ КЛЮЧИ
				lcKeyValue=LEFT(m.lcKeyValue, ATC('.EXE', m.lcKeyValue)+3)
			ENDIF

			RETURN m.lcKeyValue
		ENDIF
	ENDIF
RETURN ''
ENDPROC
PROCEDURE getclientrect
* RETRIEVES THE COORDINATES OF A WINDOW'S CLIENT AREA
* РАЗМЕРЫ КЛИЕНТСКОЙ ЧАСТИ ОКНА
* This.GetClientRect(o.Hwnd, @lnWidth, @lnHeight)
* P.S. : ДЭСКТОПНЫЕ КООРДИНАТЫ МОЖНО ПОЛУЧИТЬ ЧЕРЕЗ GetWindowRect()
LPARAMETERS tnWindowHandle AS Integer, vnWidth AS Integer, vnHeight AS Integer
LOCAL lcString AS String
	IF !THIS.isLoaded("GetClientRect")
		DECLARE SHORT GetClientRect IN WIN32API INTEGER, STRING @
	ENDIF
	*
	lcString=SPACE(16) 
	GetClientRect(m.tnWindowHandle, @lcString) 
	*
	vnWidth=CTOBIN(SUBSTR(m.lcString, 9, 4), "4RS")
	vnHeight=CTOBIN(RIGHT(m.lcString, 4), "4RS")
ENDPROC
PROCEDURE getcpuspeed
* ТАКТОВАЯ ЧАСТОТА CPU В MHZ
LOCAL lnCpuSpeed as Integer
	IF !THIS.isLoaded("GetCPUSpeed")
		DECLARE INTEGER GetCPUSpeed IN CPUSPEED.DLL
	ENDIF

	lnCpuSpeed = GetCPUSpeed()
RETURN m.lnCpuSpeed
ENDPROC
PROCEDURE getcursorpos
* X И Y КООРДИНАТЫ КУРСОРА НА ДЭСКТОПЕ ?
LPARAMETERS tlY AS Logical
LOCAL lcBuffer AS String
	IF !THIS.isLoaded("GetCursorPos")
		DECLARE INTEGER GetCursorPos IN WIN32API STRING @
	ENDIF

	lcBuffer=SPACE(40)
	GetCursorPos(@lcBuffer)

	IF m.tlY
		RETURN CTOBIN(SUBSTR(m.lcBuffer, 5, 2), "2RS")
		*VAL(ALLTRIM(STR(ASC(SUBSTR(m.lcBuffer, 6))*256+ASC(SUBSTR(m.lcBuffer, 5)))))
	ELSE
		RETURN CTOBIN(SUBSTR(m.lcBuffer, 1, 2), "2RS")
		*VAL(ALLTRIM(STR(ASC(SUBSTR(m.lcBuffer, 2))*256+ASC(SUBSTR(m.lcBuffer, 1)))))
	ENDIF

ENDPROC
PROCEDURE getdatetime
* ПОЛУЧИТЬ ДАТУ И ВРЕМЯ С СЕРВЕРА (W9X - Unsupported?)
* This.GetDateTime('\\ntserver')
LPARAMETERS tcServerName
LOCAL ltDateTime, lnBufferPointer,;
	lnHour, lnMin, lnSec, lnMove, lnDay, lnMonth, lnYear
	* Returns the time of day information from a specified server. Windows 95/98/Me: Unsupported!
	IF !THIS.isLoaded("NetRemoteTOD")
		DECLARE INTEGER NetRemoteTOD IN NETAPI32 STRING, INTEGER @
	ENDIF
	* Call NetApiBufferFree to free the memory that other network management functions return.
	IF !THIS.isLoaded("NetApiBufferFree")
		DECLARE INTEGER NetApiBufferFree IN NETAPI32 INTEGER Pointer
	ENDIF

	tcServerName=STRCONV(STRCONV(ALLTRIM(m.tcServerName)+CHR(0), 1), 5)
	lnBufferPointer=0
	* ЕСЛИ ОШИБОК НЕТ
	WITH This.Parent.oFunction
		IF NetRemoteTOD(m.tcServerName, @lnBufferPointer)=0
			lnHour=.PointerToLong(lnBufferPointer+8)	&& Часы
			lnMin=.PointerToLong(lnBufferPointer+12)	&& Минуты
			lnSec=.PointerToLong(lnBufferPointer+16)	&& Секунды
			lnMove=.PointerToLong(lnBufferPointer+24)	&& Смещение
			lnDay=.PointerToLong(lnBufferPointer+32) 	&& День
			lnMonth=.PointerToLong(lnBufferPointer+36)	&& Месяц
			lnYear=.PointerToLong(lnBufferPointer+40)	&& Год
			ltDateTime=CTOT(PADL(ALLTRIM(STR(lnDay)), 2, '0')+'/'+;
				PADL(ALLTRIM(STR(lnMonth)), 2, '0')+'/'+;
				PADL(ALLTRIM(STR(lnYear)), 4, '0')+' '+;
				PADL(ALLTRIM(STR(lnHour)), 2, '0')+':'+;
				PADL(ALLTRIM(STR(lnMin)), 2, '0')+':'+; 
				PADL(ALLTRIM(STR(lnSec)), 2, '0'))-(60*lnMove)
		ENDIF
	ENDWITH

	NetApiBufferFree(m.lnBufferPointer)
RETURN m.ltDateTime

ENDPROC
PROCEDURE getdc
* RETRIEVES A HANDLE TO A DISPLAY DEVICE CONTEXT (DC)
* FOR THE CLIENT AREA OF THE SPECIFIED WINDOW
* РЕЗУЛЬТАТ : УСПЕШНО, ЕСЛИ DC # 0
* IF This.GetDC(ThisForm.Hwnd) # 0
LPARAMETERS tnHWnd AS Integer
LOCAL lnDCHandle as Integer
	IF !THIS.isLoaded("GetDC")
		DECLARE INTEGER GetDC IN WIN32API INTEGER
	ENDIF

	lnDCHandle=GetDC(m.tnHWnd)
RETURN m.lnDCHandle
ENDPROC
PROCEDURE getdevicecaps
LPARAMETERS tnDC as Integer, tnPix as Integer
LOCAL lnCap as Integer
	IF !THIS.isLoaded("GetDeviceCaps")
		DECLARE INTEGER GetDeviceCaps IN WIN32API INTEGER, INTEGER  
	ENDIF

	lnCap = GetDeviceCaps(m.tnDC, m.tnPix)
RETURN m.lnCap
ENDPROC
PROCEDURE getfocus
* HANDLE ОКНА, СВЯЗАННОГО С ПОТОКОМ СООБЩЕНИЙ КЛАВИАТУРЫ  
LOCAL lnHandle AS Integer
	IF !THIS.isLoaded("GetFocus")
		DECLARE INTEGER GetFocus IN WIN32API
	ENDIF

	lnHandle=GetFocus()
RETURN m.lnHandle
ENDPROC
PROCEDURE getfolderpath
* TAKES THE CSIDL OF A FOLDER AND RETURNS THE PATH
LPARAMETERS tnFolderId AS Integer, tlCreateNewFolder AS Logical, tlReturnDefaultPath AS Logical
LOCAL lnCreate, lnCurrent, lcFolder, lnReturnValue
	IF !THIS.isLoaded("SHGetFolderPath")
		DECLARE INTEGER SHGetFolderPath IN SHFOLDER INTEGER, INTEGER, INTEGER, INTEGER, STRING
	ENDIF

	lnCreate = IIF(m.tlCreateNewFolder, CSIDL_FLAG_CREATE, 0)
	lnCurrent = IIF(m.tlReturnDefaultPath, SHGFP_TYPE_DEFAULT, SHGFP_TYPE_CURRENT)
	lcFolder = SPACE(512)		&& 260
	lnReturnValue = SHGetFolderPath(0, m.tnFolderId+m.lnCreate, 0, m.lnCurrent, @lcFolder)
RETURN IIF(m.lnReturnValue = 0, ALLTRIM(CHRTRAN(m.lcFolder , CHR(0), '')) + '\', '')

#IF .F.

	РЕЗУЛЬТАТ ПОД РАЗНЫМИ OS :					WIN98-SE2 (RUS)					WINXP-PROF (ENG)
	 =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  = 
	This.GetFolderPath(CSIDL_WINDOWS)			C:\WINDOWS\						C:\WINNT\			- результаты аналогичны GetWindowsDirectory()
	This.GetFolderPath(CSIDL_PERSONAL)			C:\Мои документы\				C:\Documents and Settings\USER\My Documents\
	This.GetFolderPath(CSIDL_PROGRAM_FILES)		C:\Program Files\				C:\Program Files\
	This.GetFolderPath(CSIDL_SYSTEM)			C:\WINDOWS\SYSTEM\				C:\WINNT\System32\	- результаты аналогичны GetSystemDirectory()
	This.GetFolderPath(CSIDL_APPDATA)			C:\WINDOWS\Application Data\	C:\Documents and Settings\USER\Application Data\
	This.GetFolderPath(CSIDL_MYPICTURES)		C:\Мои документы\Мои рисунки\	C:\Documents and Settings\USER\My Documents\My Pictures\
	This.GetFolderPath(CSIDL_MYMUSIC)			НЕТ								C:\Documents and Settings\USER\My Documents\My Music\
	This.GetFolderPath(CSIDL_MYVIDEO)			НЕТ								НЕТ
	This.GetFolderPath(CSIDL_DESKTOPDIRECTORY)	C:\WINDOWS\Рабочий стол\		C:\Documents and Settings\USER\Desktop\
	This.GetFolderPath(CSIDL_FAVORITES)			C:\WINDOWS\Избранное\			C:\Documents and Settings\USER\Favorites\
	This.GetFolderPath(CSIDL_STARTUP)			C:\WINDOWS\Главное меню\Программы\Автозагрузка\ C:\Documents and Settings\USER\Start Menu\Programs\Startup\
	This.GetFolderPath(CSIDL_RECENT)			C:\WINDOWS\Recent\				C:\Documents and Settings\USER\Recent\
	This.GetFolderPath(CSIDL_SENDTO)			C:\WINDOWS\SendTo\				C:\Documents and Settings\USER\SendTo\
	This.GetFolderPath(CSIDL_PROGRAM_FILES_COMMON)	 =  ПОД W98 НЕ ПРОВЕРЯЛ  = 		C:\Program Files\Common Files\

	P.S.: You can use SHGetFolderPath function on earlier systems by including the redistributable ShFolder.dll

	CSIDL_DESKTOP					 =  0x0000
	CSIDL_INTERNET					 =  0x0001
	CSIDL_PROGRAMS					 =  0x0002
	CSIDL_CONTROLS					 =  0x0003
	CSIDL_PRINTERS					 =  0x0004
	CSIDL_PERSONAL					 =  0x0005
	CSIDL_FAVORITES					 =  0x0006
	CSIDL_STARTUP					 =  0x0007
	CSIDL_RECENT					 =  0x0008
	CSIDL_SENDTO					 =  0x0009
	CSIDL_BITBUCKET					 =  0x000A
	CSIDL_STARTMENU					 =  0x000B
	CSIDL_MYDOCUMENTS				 =  0x000C
	CSIDL_MYMUSIC					 =  0x000D
	CSIDL_MYVIDEO					 =  0x000E
	CSIDL_DESKTOPDIRECTORY			 =  0x0010
	CSIDL_DRIVES					 =  0x0011
	CSIDL_NETWORK					 =  0x0012
	CSIDL_NETHOOD					 =  0x0013
	CSIDL_FONTS						 =  0x0014
	CSIDL_TEMPLATES					 =  0x0015
	CSIDL_COMMON_STARTMENU			 =  0x0016
	CSIDL_COMMON_PROGRAMS			 =  0x0017
	CSIDL_COMMON_STARTUP			 =  0x0018
	CSIDL_COMMON_DESKTOPDIRECTORY	 =  0x0019
	CSIDL_APPDATA					 =  0x001A
	CSIDL_PRINTHOOD					 =  0x001B
	CSIDL_LOCAL_APPDATA				 =  0x001C
	CSIDL_ALTSTARTUP				 =  0x001D
	CSIDL_COMMON_ALTSTARTUP			 =  0x001E
	CSIDL_COMMON_FAVORITES			 =  0x001F
	CSIDL_INTERNET_CACHE			 =  0x0020
	CSIDL_COOKIES					 =  0x0021
	CSIDL_HISTORY					 =  0x0022
	CSIDL_COMMON_APPDATA			 =  0x0023
	CSIDL_WINDOWS					 =  0x0024
	CSIDL_SYSTEM					 =  0x0025
	CSIDL_PROGRAM_FILES				 =  0x0026
	CSIDL_MYPICTURES				 =  0x0027
	CSIDL_PROFILE					 =  0x0028
	CSIDL_SYSTEMX86					 =  0x0029
	CSIDL_PROGRAM_FILESX86			 =  0x002A
	CSIDL_PROGRAM_FILES_COMMON		 =  0x002B
	CSIDL_PROGRAM_FILES_COMMONX86	 =  0x002C
	CSIDL_COMMON_TEMPLATES			 =  0x002D
	CSIDL_COMMON_DOCUMENTS			 =  0x002E
	CSIDL_COMMON_ADMINTOOLS			 =  0x002F
	CSIDL_ADMINTOOLS				 =  0x0030
	CSIDL_CONNECTIONS				 =  0x0031
	CSIDL_COMMON_MUSIC				 =  0x0035
	CSIDL_COMMON_PICTURES			 =  0x0036
	CSIDL_COMMON_VIDEO				 =  0x0037
	CSIDL_RESOURCES					 =  0x0038
	CSIDL_RESOURCES_LOCALIZED		 =  0x0039
	CSIDL_COMMON_OEM_LINKS			 =  0x003A
	CSIDL_CDBURN_AREA				 =  0x003B
	CSIDL_COMPUTERSNEARME			 =  0x003D
	CSIDL_FLAG_PER_USER_INIT		 =  0x0800
	CSIDL_FLAG_NO_ALIAS				 =  0x1000
	CSIDL_FLAG_DONT_VERIFY			 =  0x4000
	CSIDL_FLAG_CREATE				 =  0x8000
	CSIDL_FLAG_MASK					 =  0xFF00

	CSIDL_DESKTOP
	Windows desktop—virtual folder that is the root of the name space. 
	CSIDL_INTERNET
	Virtual folder that represents the Internet. 
	CSIDL_PROGRAMS
	File system directory that contains the user's program groups (which are also file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs. 
	CSIDL_CONTROLS
	Virtual folder that contains icons for Control Panel applications. 
	CSIDL_PRINTERS
	Virtual folder that contains installed printers. 
	CSIDL_PERSONAL
	File system directory that serves as a common repository for documents. A typical path is C:\Documents and Settings\username\My Documents. This is different from the My Documents virtual folder in the name space. To access that virtual folder, use the technique described in Managing the File System . 
	CSIDL_FAVORITES
	File system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites. 
	CSIDL_STARTUP
	File system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Microsoft® Windows NT® or starts Microsoft Windows® 98. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup. 
	CSIDL_RECENT
	File system directory that contains the user's most recently used documents. A typical path is C:\Documents and Settings\username\Recent. To create a shortcut in this folder, use SHAddToRecentDocs . In addition to creating the shortcut, this function updates the Shell's list of recent documents and adds the shortcut to the Documents submenu of the Start menu. 
	CSIDL_SENDTO
	File system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo. 
	CSIDL_BITBUCKET
	Virtual folder that contains the objects in the user's Recycle Bin. 
	CSIDL_STARTMENU
	File system directory that contains Start Menu items. A typical path is C:\Documents and Settings\username\Start Menu. 
	CSIDL_MYDOCUMENTS
	Virtual folder that contains the objects in the user's My Documents folder.
	CSIDL_MYMUSIC
	File system directory that serves as a common repository for music files. A typical path is C:\My Music. 
	CSIDL_MYVIDEO
	File system directory that serves as a common repository for video files. 
	CSIDL_DESKTOPDIRECTORY
	File system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop 
	CSIDL_DRIVES
	My Computer—virtual folder that contains everything on the local computer: storage devices, printers, and Control Panel. The folder can also contain mapped network drives. 
	CSIDL_NETWORK
	Network Neighborhood—virtual folder that represents the root of the network namespace hierarchy. 
	CSIDL_NETHOOD
	A file system folder that contains the link objects that can exist in the My Network Places virtual folder. It is not the same as CSIDL , which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood. 
	CSIDL_FONTS
	Virtual folder that contains fonts. A typical path is C:\WINNT\Fonts. 
	CSIDL_TEMPLATES
	File system directory that serves as a common repository for document templates. 
	CSIDL_COMMON_STARTMENU
	File system directory that contains the programs and folders that appear on the Start Menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu. Valid only for Windows NT systems. 
	CSIDL_COMMON_PROGRAMS
	File system directory that contains the directories for the common program groups that appear in the Start Menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs. Valid only for Windows NT systems. 
	CSIDL_COMMON_STARTUP
	File system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup. Valid only for Windows NT systems. 
	CSIDL_COMMON_DESKTOPDIRECTORY
	File system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop. Valid only for Windows NT systems. 
	CSIDL_APPDATA
	Version 4.71 . File system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\username\Application Data. This CSIDL is supported by the redistributable ShFolder.dll for systems that do not have the Microsoft Internet Explorer 4.0 integrated Shell installed. 
	CSIDL_PRINTHOOD
	File system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood. 
	CSIDL_LOCAL_APPDATA
	Version 5.0 . File system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data. 
	CSIDL_ALTSTARTUP
	File system directory that corresponds to the user's nonlocalized Startup program group. 
	CSIDL_COMMON_ALTSTARTUP
	File system directory that corresponds to the nonlocalized Startup program group for all users. Valid only for Windows NT systems. 
	CSIDL_COMMON_FAVORITES
	File system directory that serves as a common repository for all user's favorite items. Valid only for Windows NT systems. 
	CSIDL_INTERNET_CACHE
	Version 4.72 . File system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Temporary Internet Files. 
	CSIDL_COOKIES
	File system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies. 
	CSIDL_HISTORY
	File system directory that serves as a common repository for Internet history items. 
	CSIDL_COMMON_APPDATA
	Version 5.0 . Application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data. 
	CSIDL_WINDOWS
	Version 5.0 . Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\WINNT. 
	CSIDL_SYSTEM
	Version 5.0 . System folder. A typical path is C:\WINNT\SYSTEM32. 
	CSIDL_PROGRAM_FILES
	Version 5.0 . Program Files folder. A typical path is C:\Program Files. 
	CSIDL_MYPICTURES
	Version 5.0 . My Pictures folder. A typical path is C:\Documents and Settings\username\My Documents\My Pictures. 
	CSIDL_PROFILE
	Version 5.0 . User's profile folder. 
	CSIDL_SYSTEMX86
	The x86 system directory on Reduced Instruction Set Computer (RISC) systems. 
	CSIDL_PROGRAM_FILESX86
	The x86 Program Files folder on RISC systems. 
	CSIDL_PROGRAM_FILES_COMMON
	Version 5.0 . A folder for components that are shared across applications. A typical path is C:\Program Files\Common. Valid only for Windows NT and Windows 2000 systems. 
	CSIDL_PROGRAM_FILES_COMMONX86
	The x86 Program Files Common folder on RISC systems. 
	CSIDL_COMMON_TEMPLATES
	File system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates. Valid only for Windows NT systems. 
	CSIDL_COMMON_DOCUMENTS
	File system directory that contains documents that are common to all users. Typical paths are C:\Documents and Settings\All Users\Documents. Valid for Windows NT systems and Windows 95 and Windows 98 systems with Shfolder.dll installed. 
	CSIDL_COMMON_ADMINTOOLS
	Version 5.0 . File system directory that contains administrative tools for all users. 
	CSIDL_ADMINTOOLS
	Version 5.0 . File system directory used to store administrative tools for an individual user. The Microsoft Management Console (MMC) saves customized consoles to this directory, and it roams with the user. 
	CSIDL_CONNECTIONS
	Virtual folder that contains network and dial-up connections. 
	CSIDL_COMMON_MUSIC
	My Music folder for all users. For more information, see CSIDL . 
	CSIDL_COMMON_PICTURES
	My Pictures folder for all users. For more information, see CSIDL . 
	CSIDL_COMMON_VIDEO
	My Video folder for all users. For more information, see CSIDL . 
	CSIDL_RESOURCES
	System resource directory. A typical path is C:\WINNT\Resources. 
	CSIDL_RESOURCES_LOCALIZED
	Localized resource directory. For more information, see CSIDL . 
	CSIDL_COMMON_OEM_LINKS
	Folder containing links to OEM specific applications for all users. 
	CSIDL_CDBURN_AREA
	File system folder used to hold data for burning to a CD. Typically [User Profile Folder]\Local Settings\Applications Data\Microsoft\CD Burning. 
	CSIDL_COMPUTERSNEARME
	Computers Near Me folder. Virtual folder that contains links to nearby computers on the network. Nearness it is established by common work group membership. 
	CSIDL_FLAG_PER_USER_INIT
	Combine this flag with the desired CSIDL_ value to indicate per-user initialization. 
	CSIDL_FLAG_NO_ALIAS
	Combine this flag with the desired CSIDL_ value to force a non-alias version of the PIDL. 
	CSIDL_FLAG_DONT_VERIFY
	Combine this flag with the desired CSIDL_ value to return an unverified folder path. 
	CSIDL_FLAG_CREATE
	Combine this flag with the desired CSIDL_ value to force the creation of the associated folder. 
	CSIDL_FLAG_MASK
	Mask for all possible CSIDL flag values

#ENDIF
ENDPROC
PROCEDURE getguid
* GUID - GLOBALLY UNIQUE IDENTIFIER
* УНИКАЛЬНАЯ СТРОКА ВИДА '{96C1E335-B6C2-41C7-9602-295CD99988E3}'
* ИСПОЛЬЗУЕТСЯ, НАПРИМЕР, ДЛЯ ФОРМИРОВАНИЯ ВЕТОК CLSID В РЕЕСТРЕ WINDOWS
* СТРОКА ДЛИННОЙ 38 БАЙТ
LOCAL lcGuid AS String, lcResult AS String
	IF !THIS.isLoaded("CoCreateGuid")
		DECLARE INTEGER CoCreateGuid IN OLE32.DLL STRING @
	ENDIF

	IF !THIS.isLoaded("StringFromGuid2")
		DECLARE INTEGER StringFromGUID2	IN OLE32.DLL STRING, STRING @, INTEGER
	ENDIF

	lcGuid = SPACE(16)
	CoCreateGuid(@lcGuid)

	DO WHILE ASC(LEFT(m.lcGuid,1)) = 0
		CoCreateGuid(@lcGuid)
	ENDDO

	lcResult = SPACE(0076)

	StringFromGuid2(m.lcGuid, @lcResult, LEN(m.lcResult))
RETURN STRCONV(m.lcResult, 6)
ENDPROC
PROCEDURE getipaddress
* IP АДРЕС МАШИНЫ ИЛИ МАСКА ПОДСЕТИ В ВИДЕ СТРОКИ : '999.999.999.999'
* ПО НОМЕРУ ВХОЖДЕНИЯ КОНКРЕТНОГО IP АДРЕСА В ТАБЛИЦЕ АДРЕСОВ
* И ЖЕЛАЕМОМУ ТИПУ РЕЗУЛЬТАТА (IPADDRESS OR SUBNETMASK)
* ИСПОЛЬЗОВАТЬ В ПАРЕ C THIS.GETIPENTRIES()
* ДРУГОЙ ВАРИАНТ ЧЕРЕЗ MSWINSOCK :
* o = CREATEOBJECT('mswinsock.winsock')
* MESSAGEBOX(o.LocalIP)
LPARAMETER tnEntry AS Integer, tlSubNetMask AS Logical
LOCAL lnIpSize AS Integer, lcIpTable AS String, lcAddress AS String
	* ПРОТОКОЛ НЕ УСТАНОВЛЕН
	IF m.tnEntry=0
		RETURN '000.000.000.000'
	ENDIF
	* ЗАРЕЗЕРВИРУЕМ МЕСТО ПОД СТРУКТУРУ
	lnIpSize=1024 && Обычно 300 ?
	lcIpTable=SPACE(m.lnIpSize)
	* ПОЛУЧИМ СТРУКТУРУ С IP АДРЕСАМИ
	IF !THIS.isLoaded("GetIpAddrTable")
		DECLARE INTEGER GetIpAddrTable IN IPHLPAPI STRING @, INTEGER @, INTEGER
	ENDIF
	*
	GetIpAddrTable(@lcIpTable, @lnIpSize, 1)
	* ПОЛУЧИМ СТРОКИ IP АДРЕСА ИЛИ МАСКИ ПОДСЕТИ
	lcAddress=SUBSTR(m.lcIpTable, 24*(m.tnEntry-1)+5+IIF(m.tlSubNetMask, 8, 0), 4)
	* ПЕРЕВЕДЕМ В ТОЧЕЧНУЮ НОТАЦИЮ ВИДА : '999.999.999.999'
RETURN TRANSFORM(ASC(m.lcAddress), '@L 999')+'.'+;
   TRANSFORM(ASC(SUBSTR(m.lcAddress, 2, 1)), '@L 999')+'.'+;
   TRANSFORM(ASC(SUBSTR(m.lcAddress, 3, 1)), '@L 999')+'.'+;
   TRANSFORM(ASC(SUBSTR(m.lcAddress, 4, 1)), '@L 999')


* Convert LongInt to IP Address string
* PROCEDURE Int32ToIPStrFast(nIP)
* RETURN LTRIM(STR(BITAND(nIP, 0xFF))) + "." + ;
	LTRIM(STR(BITAND(BITRSHIFT(nIP, 8 * 1), 0xFF))) + "." + ;
	LTRIM(STR(BITAND(BITRSHIFT(nIP, 8 * 2), 0xFF))) + "." + ;
	LTRIM(STR(BITRSHIFT(nIP, 8 * 3)))


ENDPROC
PROCEDURE getipentries
* КОЛИЧЕСТВО IP АДРЕСОВ НА МАШИНЕ
* ИСПОЛЬЗОВАТЬ В ПАРЕ С THIS.GETIPADDRESS()
LOCAL lnIpSize AS Integer, lcIpTable AS String, lcAddress AS String
	* ЗАРЕЗЕРВИРУЕМ МЕСТО ПОД СТРУКТУРУ
	lnIpSize=1024 && Обычно 300 ?
	lcIpTable=SPACE(m.lnIpSize)
	* ПОЛУЧИМ СТРУКТУРУ С IP АДРЕСАМИ
	IF !THIS.isLoaded("GetIpAddrTable")
		DECLARE INTEGER GetIpAddrTable IN IPHLPAPI STRING @, INTEGER @, INTEGER
	ENDIF
	*
	TRY
		GetIpAddrTable(@lcIpTable, @lnIpSize, 1)
		lnEntries=CTOBIN(LEFT(m.lcIpTable, 4), '4RS')
	CATCH
		* ПРОТОКОЛ НЕ УСТАНОВЛЕН
		lnEntries=0
	ENDTRY
RETURN m.lnEntries

ENDPROC
PROCEDURE getkeyboardlayoutname
* ВОЗВРАЩАЕТ ТЕКУЩУЮ РАСКЛАДКУ КЛАВИАТУРЫ
* IF This.GetKeyboardLayoutName()  =  LANGID_RUS ... '00000419'  =  Russian
LOCAL lcLayout AS String
	lcLayout = SPACE(8)

	IF !THIS.isLoaded("GetKeyboardLayoutName")
		DECLARE GetKeyboardLayoutName IN WIN32API STRING @
	ENDIF

	GetKeyboardLayoutName(@lcLayout)
RETURN m.lcLayout
ENDPROC
PROCEDURE getlastactivepopup
* НАЙДЕМ УКАЗАТЕЛЬ НА ПОСЛЕДНЕЕ АКТИВНОЕ ДОЧЕРНЕЕ ОКНО В ОКНЕ С tnHWnd
* DETERMINES WHICH POP-UP WINDOW OWNED BY THE SPECIFIED WINDOW WAS MOST RECENTLY ACTIVE
* РЕЗУЛЬТАТ РАВЕН tnHWnd, ЕСЛИ :
* 1) tnWnd и есть последнее активное окно
* 2) tnWnd не содержит дочерних окон
* 3) tnWnd не toplevel-окно или само является дочерним
* This.GetLastActivePopup(goApp.oVars.HWnd)
LPARAMETERS tnHWnd AS Integer
LOCAL lnHandle as Integer
	IF !THIS.isLoaded("GetLastActivePopup")
		DECLARE INTEGER GetLastActivePopup IN WIN32API INTEGER
	ENDIF

	lnHandle = GetLastActivePopup(m.tnHWnd)
RETURN m.lnHandle

ENDPROC
PROCEDURE getlasterror
* THE GETLASTERROR FUNCTION RETRIEVES THE CALLING THREAD"S LAST-ERROR CODE VALUE.
	IF !THIS.isLoaded("GetLastError")
		DECLARE INTEGER GetLastError IN WIN32API
	ENDIF

	lnError=GetLastError()
RETURN m.lnError
ENDPROC
PROCEDURE getlogicaldrive
* СПИСОК ДИСКОВ С УКАЗАНИЕМ ИХ ТИПА
* This. GetLogicalDriveStrings('С')
LPARAMETERS taListDrivers
LOCAL lnI, lnbuflen, lcbuf
	IF !THIS.isLoaded("GetLogicalDriveStrings")
		DECLARE INTEGER GetLogicalDriveStrings IN WIN32API Integer, String @
	ENDIF

	IF !THIS.isLoaded("GetDriveType")
		DECLARE INTEGER GetDriveType IN WIN32API String
	ENDIF
	
	lnbuflen = 104 
	lcbuf = REPLICATE(CHR(0), m.lnbuflen)

	GetLogicalDriveStrings(m.lnbuflen, @lcbuf)
	lcbuf = ALLTRIM(CHRTRAN(m.lcbuf, CHR(0) + "\:", ""))
	
	DIMENSION taListDrivers[LEN(m.lcbuf), 2]

	FOR lnI = 1 TO LEN(m.lcbuf)
		taListDrivers[m.lnI, 1] = SUBSTR(m.lcbuf, m.lnI, 1) + ":\"
		taListDrivers[m.lnI, 2] = GetDriveType(taListDrivers[m.lnI, 1])
	ENDFOR
RETURN
ENDPROC
PROCEDURE getmessagepos
* КООРДИНАТЫ ОБЪЕКТА (ОТНОСИТЕЛЬНО ДЭСКТОПА), ПОЛУЧИВШЕГО ПОСЛЕДНЕЕ СООБЩЕНИЕ
* This.GetMessagePos() - LEFT, This.GetMessagePos(.T.) - TOP
* НАПРИМЕР АБСОЛЮТНЫЕ КООРДИНАТЫ КЛИКА ПО НЕКОМУ КОНТРОЛУ НА ФОРМЕ
* МОЖНО ПОЛУЧИТЬ, ЕСЛИ В ЕГО GOTFOCUS() ПОЛОЖИТЬ КОД :
* MESSAGEBOX('Left = '+TRANSFORM(This.GetMessagePos(.F.))+;
* 	' Top = '+TRANSFORM(This.GetMessagePos(.T.)))
* P.S.1 VFP КОНТРОЛЫ - РИСОВАННЫЕ БИТМАПЫ, А НЕ ОКНА, НО НЕ ВСЕГДА
* НАПРИМЕР COMBOBOX - РИСУНОК, А ЕГО ВЫПАДАЮЩИЙ СПИСОК - ОКНО !
* (ИНАЧЕ СПИСОК НЕВОЗМОЖНО БЫЛО БЫ ПОКАЗАТЬ ЗА ПРЕДЕЛАМИ ФОРМЫ)
* P.S.2 СМ. ПОЛУЧЕНИЕ АБСОЛЮТНЫХ КООРДИНАТ ФОРМЫ This.ClientToScreen(...)
LPARAMETERS tlTop AS Logical
LOCAL lnPosition AS Integer
	IF !THIS.isLoaded("GetMessagePos")
		DECLARE LONG GetMessagePos IN WIN32API
	ENDIF

	lnPosition = GetMessagePos()
RETURN IIF(m.tlTop, INT(m.lnPositio / 65536), BITAND(m.lnPosition, 4095))

ENDPROC
PROCEDURE getprocaddress
* ПОИСК АДРЕСА ТОЧКИ ВХОДА ПРОЦЕДУРЫ В ACTIVEX OCX == DLL БИБЛИОТЕКЕ
* ПАРАМЕТР : ХЭНДЛ БИБЛИОТЕКИ, ИМЯ ПРОЦЕДУРЫ
* РЕЗУЛЬТАТ : АДРЕС ТОЧКИ ВХОДА ПРОЦЕДУРЫ В БИБЛИОТЕКЕ ИЛИ 0
* СМ. This.RegSvr32()
LPARAMETERS tnHandle AS Integer, tcProcedure AS String
LOCAL lnAddress AS Integer
	IF !THIS.isLoaded("GetProcAddress")
		DECLARE INTEGER GetProcAddress IN WIN32API INTEGER, STRING
	ENDIF
	*
	lnAddress=GetProcAddress(m.tnHandle, m.tcProcedure)
RETURN m.lnAddress
ENDPROC
PROCEDURE getshortfilename
* КОНВЕРТАЦИЯ ДЛИННОГО ПУТИ И ИМЕНИ ФАЙЛА В КОРОТКОЕ
* ФАЙЛ, С ПЕРЕДАВАЕМЫМ В КАЧЕСТВЕ ПАРАМЕТРА ИМЕНЕМ, ДОЛЖЕН СУЩЕСТВОВАТЬ
* РЕЗУЛЬТАТ : ИМЯ В ФОРМАТЕ 8.3 ИЛИ '' В СЛУЧАЕ ОШИБКИ 
* This.GetShortFileName('C:\МОИ ДОКУМЕНТЫ')  =  'С:\МОИДОК~1'
LPARAMETERS tcInputString as String
LOCAL lcOutputString, lnStringLength
	IF !THIS.isLoaded("GetShortPathName")
		DECLARE INTEGER GetShortPathName IN WIN32API STRING, STRING, INTEGER
	ENDIF

	lcOutputString = SPACE(255)
	lnStringLength = GetShortPathName(@tcInputString, @lcOutputString, 255) 
RETURN IIF(m.lnStringLength = 0, '', LEFT(m.lcOutputString, m.lnStringLength))
ENDPROC
PROCEDURE getsyscolor
* ЦВЕТА СИСТЕМНЫХ ЭЛЕМЕНТОВ
* This.GetSysColor(COLOR_ACTIVECAPTION)				= 6956042	= COLOR_FORM_TITLEBAR_GOTFOCUS_LEFT		= RGB(010, 036, 106)
* This.GetSysColor(COLOR_GRADIENTACTIVECAPTION)		= 15780518	= COLOR_FORM_TITLEBAR_GOTFOCUS_RIGHT	= RGB(166, 202, 240)
* This.GetSysColor(COLOR_INACTIVECAPTION)			= 8421504	= COLOR_FORM_TITLEBAR_LOSTFOCUS_LEFT	= RGB(128, 128, 128)
* This.GetSysColor(COLOR_GRADIENTINACTIVECAPTION)	= 12632256	= COLOR_FORM_TITLEBAR_LOSTFOCUS_RIGHT	= RGB(192, 192, 192)
* This.GetSysColor(COLOR_DESKTOP)					= ЦВЕТ РАБОЧЕГО СТОЛА
LPARAMETERS tnIndex
LOCAL lnReturnValue AS Integer
	IF !THIS.isLoaded("GetSysColor")
		DECLARE INTEGER GetSysColor IN WIN32API INTEGER  
	ENDIF
	*
	lnReturnValue=GetSysColor(m.tnIndex)
RETURN m.lnReturnValue

ENDPROC
PROCEDURE getsystemdirectory
* ВОЗВРАЩАЕТ СИСТЕМНЫЙ КАТАЛОГ, НАПРИМЕР 
* 'C:\WINDOWS\SYSTEM\' ДЛЯ W9X И
* 'C:\WINDOWS\SYSTEM32\' ДЛЯ WNT
LOCAL lcPath as String, lnSize as Integer
	IF !THIS.isLoaded("GetSystemDirectory")
		DECLARE INTEGER GetSystemDirectory IN WIN32API STRING, INTEGER
	ENDIF

	lcPath = SPACE(512)
	lnSize = GetSystemDirectory(@lcPath, 512)
RETURN LEFT(m.lcPath, m.lnSize) + '\'
ENDPROC
PROCEDURE getsystemmetrics
* WIDTHS AND HEIGHTS OF DISPLAY ELEMENTS AND SYSTEM CONFIGURATION SETTINGS
*						Параметр Результат
* SM_CXVSCROLL			= 02	->	16 Ширина вертикального скролбара, например кнопок спиннера
* SM_CMOUSEBUTTONS		= 43	->	05 Количество кнопок мышки или 0, если мышки нет.
* SM_MOUSEWHEELPRESENT	= 75	->	01 (WNT,W98,WME) TRUE or nonzero if a mouse with a wheel is installed; FALSE or zero otherwise
* SM_CLEANBOOT			= 67	->	00 0:Normal boot / 1:Safe-mode / 2:Safe-mode with network support
* See Also : SYSMETRIC(nScreenElement)
LPARAMETERS tnMetricIndex AS Integer
LOCAL luReturnValue AS Variant
	IF !THIS.isLoaded("GetSystemMetrics")
		DECLARE INTEGER GetSystemMetrics IN WIN32API INTEGER
	ENDIF
	*
	luReturnValue=GetSystemMetrics(m.tnMetricIndex)
RETURN m.luReturnValue

ENDPROC
PROCEDURE gettempfilename
* СОЗДАЕТ УНИКАЛЬНЫЙ .TMP ФАЙЛ В КАТАЛОГЕ TCPATH C ПРЕФИКСОМ TCPREFIX
* ПРЕФИКС - ПЕРВЫЕ 3 СИМВОЛА ИМЕНИ ФАЙЛА - ПО УМОЛЧАНИЮ 'tmp'
* РЕЗУЛЬТАТ ПУТЬ + ИМЯ_ФАЙЛА + '.tmp' ИЛИ ПУСТАЯ СТРОКА
LPARAMETERS tcPath, tcPrefix
LOCAL lcPath, lcPrefix, lcName
	lcPath=IIF(VARTYPE(m.tcPath)='C' AND !EMPTY(m.tcPath), m.tcPath, SYS(2023))
	lcPrefix=IIF(VARTYPE(m.tcPrefix)='C' AND !EMPTY(m.tcPrefix), m.tcPrefix, 'tmp')
	lcName=SPACE(576)
	*
	IF !THIS.isLoaded("GetTempFileName")
		DECLARE LONG GetTempFileName IN WIN32API STRING, STRING, LONG, STRING
	ENDIF
	*
	GetTempFileName(m.lcPath, m.lcPrefix, 0, @lcName)
RETURN STRTRAN(TRIM(m.lcName), CHR(0))
ENDPROC
PROCEDURE gettemppath
* КАТАЛОГ ВРЕМЕННЫХ ФАЙЛОВ WINDOWS
* WIN98-SE2  (RUS) : 'C:\WINDOWS\TEMP\'
* WINXP-PROF (ENG) : 'C:\DOCUME~1\USER\LOCALS~1\Temp\'
LOCAL lcTempPath AS String
	IF !THIS.isLoaded("GetTempPath")
		DECLARE INTEGER	GetTempPath IN WIN32API	LONG, STRING
	ENDIF
	*
	lcTempPath=SPACE(512)
	GetTempPath(512, @lcTempPath)
RETURN STRTRAN(ALLTRIM(m.lcTempPath), CHR(0))
ENDPROC
PROCEDURE gettickcount
* КОЛИЧЕСТВО МИЛИСЕКУНД (ИЛИ СЕКУНД, ЕСЛИ TLRETURNSECONDS = .T.),
* ПРОШЕДШИХ С МОМЕНТА СТАРТА ОПЕРАЦИОННОЙ СИСТЕМЫ = SYSTEM UP TIME
* УДОБНО ДЛЯ ТОЧНОГО ЗАМЕРА МАЛЫХ ИНТЕРВАЛОВ ВРЕМЕНИ
* НАПРИМЕР - ДЛЯ ПРОФИЛИРОВАНИЯ ВЫПОЛНЕНИЯ ПРОГРАММЫ
* P.S. МИНИМАЛЬНЫЙ ИНТЕРВАЛ ВРЕМЕНИ В WINDOWS - ОКОЛО 55 МИЛЛИСЕКУНД
LPARAMETERS tlReturnSeconds AS Logical
LOCAL lnMilliseconds AS Integer
	IF !THIS.isLoaded("GetTickCount")
		DECLARE LONG GetTickCount IN WIN32API
	ENDIF
	*
	lnMilliseconds=GetTickCount()
RETURN IIF(m.tlReturnSeconds, ROUND(m.lnMilliseconds/1000, 0), m.lnMilliseconds)
ENDPROC
PROCEDURE gettimezoneinformation
* ВОЗВРАЩАЕТ СТРОКУ С ОПИСАНИЕМ ВРЕМЕННОЙ ЗОНЫ
* (ПЕРВЫЕ 4 БАЙТА = BIAS)
LOCAL lcTimeZone AS String
	lcTimeZone=REPLICATE(CHR(0), TIME_ZONE_SIZE)
	*
	IF !THIS.isLoaded("GetTimeZoneInformation")
		DECLARE INTEGER GetTimeZoneInformation IN WIN32API STRING @
	ENDIF
	*
	GetTimeZoneInformation(@lcTimeZone)
RETURN m.lcTimeZone
ENDPROC
PROCEDURE getuserdefaultlcid
LOCAL lnLCID as Integer
	IF !THIS.isLoaded("GetUserDefaultLCID")
		DECLARE Integer GetUserDefaultLCID IN Win32Api
	ENDIF
	*
	lnLCID=GetUserDefaultLCID()
	*1049- Russian
RETURN m.lnLCID
ENDPROC
PROCEDURE getvolumeinformation
* СЕРИЙНЫЙ НОМЕР ЛОГИЧЕСКОГО ДИСКА
* This.GetVolumeInformation('С')  =  '0000000F'
* P.S. :	SUBSTR(TRANSFORM(15, '@0'), 3)  =  '0000000F'
*			EVALUATE('0x0000000F')  =  15
LPARAMETERS tcDriveName
LOCAL lnSerialNumber AS Integer, lcDriveName AS String
	IF !THIS.isLoaded("GetVolumeInformation")
		DECLARE INTEGER GetVolumeInformation IN WIN32API;
			STRING, STRING, INTEGER, INTEGER @, INTEGER, INTEGER, STRING
	ENDIF
	* ПОЛУЧИМ 10-РИЧНЫЙ СЕРИЙНЫЙ НОМЕР (ВОЗМОЖНО ОТРИЦАТЕЛЬНЫЙ)
	lnSerialNumber = 0
	lcDriveName = LEFT(LTRIM(m.tcDriveName), 1) + ':\'
	GetVolumeInformation(m.lcDriveName, 0, 0, @lnSerialNumber, 0, 0, 0)
	* КОНВЕРТИРУЕМ В 16-РИЧНЫЙ ФОРМАТ
RETURN THIS.Parent.oFunction.decToHex(m.lnSerialNumber)

* ВАРИАНТ ЧЕРЕЗ FSO
* LPARAMETERS tcDriveName
* LOCAL loFileSytem, loDrive
* tcDriveName  =  IIF(VARTYPE(tcDriveName) # 'C', 'C:', LEFT(LTRIM(tcDriveName), 1) + ':')
* loFileSytem  =  CreateObject("Scripting.FileSystemObject")
* loDrive  =  loFileSytem.GetDrive(loFileSytem.GetDriveName(loFileSytem.GetAbsolutePathName(tcDriveName)))
* RETURN RIGHT(TRANSFORM(loDrive.SerialNumber, "@0"), 8)

* ВАРИАНТ WMI
* lcComputer  =  "."
* loWMIService  =  GetObject("winmgmts:" ;
* + "{impersonationLevel = impersonate}!\\" + lcComputer + "\root\cimv2")
* colDisks  =  loWMIService.ExecQuery ;
* ("Select * from Win32_LogicalDisk")
* For each loDisk in colDisks
* ?"Compressed: " + chr(9) +  TRANSFORM(loDisk.Compressed)
* ?"Description: " + chr(9) +  loDisk.Description
* ?"DeviceID: " + chr(9) +  loDisk.DeviceID
* ?"DriveType: " + chr(9) +  TRANSFORM(loDisk.DriveType)
* ?"FileSystem: " + chr(9) +  loDisk.FileSystem
* ?"FreeSpace: " + chr(9) +  loDisk.FreeSpace
* * ?"MediaType: " + chr(9) +  TRANSFORM(loDisk.MediaType)
* ?"Name: " + chr(9) +  loDisk.Name
* * ?"QuotasDisabled: " + chr(9) +  loDisk.QuotasDisabled
* ?"QuotasIncomplete: " + chr(9) +  loDisk.QuotasIncomplete
* ?"QuotasRebuilding: " + chr(9) +  loDisk.QuotasRebuilding
* ?"Size: " + chr(9) +  loDisk.Size
* ?"SupportsDiskQuotas: " + chr(9) + ;
* TRANSFORM(loDisk.SupportsDiskQuotas)
* ?"SupportsFileBasedCompression: " + chr(9) + ;
* TRANSFORM(loDisk.SupportsFileBasedCompression)
* ?"SystemName: " + chr(9) +  loDisk.SystemName
* ?"VolumeDirty: " + chr(9) +  TRANSFORM(loDisk.VolumeDirty)
* ?"VolumeName: " + chr(9) +  loDisk.VolumeName
* ?"VolumeSerialNumber: " + chr(9) +  ;
* loDisk.VolumeSerialNumber
* Next

* ВАРИАНТ WINAPI
* FUNCTION GetVolumeSerial(tcDrive)
* IF PCOUNT()  =  0
* 	tcDrive  =  "C:\"
* ELSE
* 	tcDrive  =  STRTRAN(tcDrive, ":\", "") + ":\"
* ENDIF
* LOCAL lcName, lcFSName, lnVolumeSerial, lnFMaxLen, lnFSFlags, lcVolumeSerial,;
* 	lnNameLen, lnFSNameLen
* STORE SPACE(255) TO lcName, lcFSName
* STORE 0 TO lnVolumeSerial, lnFMaxLen, lnFSFlags
* STORE 255 TO lnNameLen, lnFSNameLen
* DECLARE GetVolumeInformation IN win32api STRING, STRING @, INTEGER, INTEGER @,;
* 	INTEGER @, INTEGER @, STRING @, INTEGER
* GetVolumeInformation(tcDrive, @lcName, lnNameLen, @lnVolumeSerial, @lnFMaxLen,;
* 	@lnFSFlags, @lcFSName, lnFSNameLen)
* CLEAR DLLS GetVolumeInformation
* IF EMPTY(lnVolumeSerial)
* 	RETURN ''
* ELSE
* 	IF lnVolumeSerial < 0
* 		lnVolumeSerial  =  4294967296 + lnVolumeSerial
* 	ENDIF
* 		lcVolumeSerial  =  SUBSTR(TRANSFORM(lnVolumeSerial,"@0"), 3)
* 		RETURN lcVolumeSerial
* 	ENDIF
* ENDFUNC
ENDPROC
PROCEDURE getwindow
* RETRIEVES A HANDLE TO A WINDOW THAT HAS THE SPECIFIED RELATIONSHIP (Z ORDER OR OWNER) TO THE SPECIFIED WINDOW
LPARAMETERS tnHWindow AS Integer, tnRelationship AS Integer
LOCAL lnWHandle AS Integer
	IF !THIS.isLoaded("GetWindow")
		DECLARE INTEGER GetWindow IN WIN32API INTEGER, INTEGER
	ENDIF
	* DECLARE INTEGER GetWindowLong IN WIN32API INTEGER, INTEGER
	lnWHandle = GetWindow(m.tnHWindow, m.tnRelationship)
RETURN m.lnWHandle

ENDPROC
PROCEDURE getwindowlong
* RETRIEVES INFORMATION ABOUT THE SPECIFIED WINDOW
LPARAMETERS tnHWnd AS Integer, tnIndex AS Integer
LOCAL lnResult AS String
	IF !THIS.isLoaded("GetWindowLong")
		DECLARE LONG GetWindowLong IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	lnResult=GetWindowLong(m.tnHWnd, m.tnIndex)
RETURN m.lnResult
ENDPROC
PROCEDURE getwindowrect
* RETRIEVES THE DIMENSIONS OF THE BOUNDING RECTANGLE OF THE SPECIFIED WINDOW
* КООРДИНАТЫ ОКНА НА ДЭСКТОПЕ (РЕАЛЬНЫЕ РАЗМЕРЫ ОКНА, А НЕ КЛИЕНТСКОЙ ЧАСТИ)
* This.GetWindowRect(o.Hwnd, @lnXUpperLeft, @lnYUpperLeft, @lnXLowerRight, @lnYLowerRight)
* P.S. : РАЗМЕРЫ КЛИЕНТСКОЙ ЧАСТИ МОЖНО ПОЛУЧИТЬ ЧЕРЕЗ GetClientRect()
LPARAMETERS tnWindowHandle AS Integer,;
	vnXUpperLeft AS Integer, vnYUpperLeft AS Integer,;
	vnXLowerRight AS Integer, vnYLowerRight AS Integer
LOCAL lcString AS String
	IF !THIS.isLoaded("GetWindowRect")
		DECLARE SHORT GetWindowRect IN WIN32API INTEGER, STRING @
	ENDIF
	*
	lcString=SPACE(16) 
	GetWindowRect(m.tnWindowHandle, @lcString) 
	*
	vnXUpperLeft=CTOBIN(LEFT(m.lcString, 4), "4RS")
	vnYUpperLeft=CTOBIN(SUBSTR(m.lcString, 5, 4), "4RS")
	vnXLowerRight=CTOBIN(SUBSTR(m.lcString, 9, 4), "4RS")
	vnYLowerRight=CTOBIN(RIGHT(m.lcString, 4), "4RS")

ENDPROC
PROCEDURE getwindowsdirectory
* ВОЗВРАЩАЕТ КОРНЕВОЙ КАТАЛОГ WINDOWS, НАПРИМЕР 'C:\WINDOWS\'
LOCAL lcPath as String, lnSize as Integer
	IF !THIS.isLoaded("GetWindowsDirectory")
		DECLARE INTEGER GetWindowsDirectory IN WIN32API STRING, INTEGER
	ENDIF

	lcPath = SPACE(512)
	lnSize = GetWindowsDirectory(@lcPath, 512)
RETURN LEFT(m.lcPath, m.lnSize) + '\'
ENDPROC
PROCEDURE globalmemorystatus
* ИНФОРМАЦИЯ О ПАМЯТИ
* 1 - ПРОЦЕНТ ИСПОЛЬЗОВАННОЙ ПАМЯТИ
* 2	- РАЗМЕР ФИЗИЧЕСКОЙ ПАМЯТИ В БАЙТАХ
* 3	- СВОБОДНАЯ ФИЗИЧЕСКАЯ ПАМЯТЬ В БАЙТАХ (СМ. SYS(3050,1,THISVALUE))
* 4	- РАЗМЕР ФАЙЛА ПОДКАЧКИ В БАЙТАХ
* 5	- СВОБОДНЫХ БАЙТ В ФАЙЛЕ ПОДКАЧКИ
* 6 - ВИРТУАЛЬНАЯ ПАМЯТЬ, ИСПОЛЬЗУЕМАЯ ПРОЦЕССОМ
* 7 - СВОБОДНАЯ ВИРТУАЛЬНАЯ ПАМЯТЬ
LPARAMETERS tnWhatInfo as Integer
LOCAL lcRamStatus as String
	tnWhatInfo=IIF(VARTYPE(m.tnWhatInfo)<>'N', 2, m.tnWhatInfo)
	*
	IF !THIS.isLoaded("GlobalMemoryStatus")
		DECLARE GlobalMemoryStatus IN WIN32API STRING @lcRamStatus
	ENDIF
	*
	lcRamStatus=REPLICATE(CHR(0), 32)
	GlobalMemoryStatus(@lcRamStatus)
	*
	DO CASE
	CASE m.tnWhatInfo=1
		* ПРОЦЕНТ ИСПОЛЬЗОВАННОЙ ПАМЯТИ
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 5, 4), '4RS')
	CASE m.tnWhatInfo=2
		* РАЗМЕР ФИЗИЧЕСКОЙ ПАМЯТИ В БАЙТАХ
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 9, 4), '4RS')
	CASE m.tnWhatInfo=3
		* СВОБОДНАЯ ФИЗИЧЕСКАЯ ПАМЯТЬ В БАЙТАХ
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 13, 4), '4RS')
	CASE m.tnWhatInfo=4
		* РАЗМЕР ФАЙЛА ПОДКАЧКИ В БАЙТАХ
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 17, 4), '4RS')
	CASE m.tnWhatInfo=5
		* СВОБОДНО ВИРТУАЛЬНОЙ ПАМЯТИ
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 21, 4), '4RS')
	CASE m.tnWhatInfo=6
		* ВИРТУАЛЬНАЯ ПАМЯТЬ, ИСПОЛЬЗУЕМАЯ ПРОЦЕССОМ
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 25, 4), '4RS')
	CASE m.tnWhatInfo=7
		* СВОБОДНАЯ ВИРТУАЛЬНАЯ ПАМЯТЬ
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 29, 4), '4RS')
	ENDCASE
RETURN -1
ENDPROC
PROCEDURE hideprocess
* СПРЯТАТЬ ИЛИ ПОКАЗАТЬ ТЕКУЩИЙ ПРОЦЕСС В СПИСКЕ ЗАДАЧ ПО CTRL+ALT+DEL
LPARAMETERS tlShow as Logical
LOCAL lnSuccess AS Integer. lnShow AS Integer
	lnShow=IIF(m.tlShow, 0, 1)
	*
	IF !THIS.isLoaded("GetCurrentProcessId")
		DECLARE INTEGER GetCurrentProcessId	IN WIN32API
	ENDIF
	*
	IF !THIS.isLoaded("RegisterServiceProcess")
		DECLARE INTEGER RegisterServiceProcess IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	lnSuccess=RegisterServiceProcess(GetCurrentProcessId(), m.lnShow)
RETURN m.lnSuccess=1
ENDPROC
PROCEDURE internetgetconnectedstate
* СОСТОЯНИЕ СОЕДИНЕНИЯ С ИНТЕРНЕТОМ
* РЕЗУЛЬТАТ ЧИСЛО В ДИАПОЗОНЕ 1-127,
* 00 - ПОДКЛЮЧЕНИЕ ОТСУТСТВУЕТ
* 16 - RAS УСТАНОВЛЕН
* 32 - РАБОТАЕМ OFFLINE
LOCAL lnFlags AS Integer
	IF !THIS.isLoaded("InternetGetConnectedState")
		DECLARE SHORT InternetGetConnectedState IN WININET LONG @, LONG
	ENDIF
	*
	lnFlags=0
	InternetGetConnectedState(@lnFlags, 0)
RETURN m.lnFlags

*!*	РЕЗУЛЬТАТ МОЖНО РАЗОБРАТЬ ТАК :

*!*	?INTERNET_CONNECTION_CONFIGURED = BITAND(lnFlags, INTERNET_CONNECTION_CONFIGURED)
*!*	?INTERNET_CONNECTION_OFFLINE = BITAND(lnFlags, INTERNET_CONNECTION_OFFLINE)
*!*	?INTERNET_RAS_INSTALLED = BITAND(lnFlags, INTERNET_RAS_INSTALLED)
*!*	?INTERNET_CONNECTION_PROXY = BITAND(lnFlags, INTERNET_CONNECTION_PROXY)
*!*	?INTERNET_CONNECTION_LAN = BITAND(lnFlags, INTERNET_CONNECTION_LAN)
*!*	?INTERNET_CONNECTION_MODEM = BITAND(lnFlags, INTERNET_CONNECTION_MODEM)

*!* ИЛИ НАПРИМЕР ДЕДОВСКИМ СПОСОБОМ :

*!*	?lnFlags >= INTERNET_CONNECTION_CONFIGURED
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_CONFIGURED, INTERNET_CONNECTION_CONFIGURED, 0)
*!*	?lnFlags >= INTERNET_CONNECTION_OFFLINE
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_OFFLINE, INTERNET_CONNECTION_OFFLINE, 0)
*!*	?lnFlags >= INTERNET_RAS_INSTALLED
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_RAS_INSTALLED, INTERNET_RAS_INSTALLED, 0)
*!*	?lnFlags >= INTERNET_CONNECTION_MODEM_BUSY
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_MODEM_BUSY, INTERNET_CONNECTION_MODEM_BUSY, 0)
*!*	?lnFlags >= INTERNET_CONNECTION_PROXY
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_PROXY, INTERNET_CONNECTION_PROXY, 0)
*!*	?lnFlags >= INTERNET_CONNECTION_LAN
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_LAN, INTERNET_CONNECTION_LAN, 0)
*!*	?lnFlags >= INTERNET_CONNECTION_MODEM
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_MODEM, INTERNET_CONNECTION_MODEM, 0)
*!*	?lnFlags && Здесь должен остаться 0 !!!
ENDPROC
PROCEDURE ischild
* THIS FUNCTION TESTS WHETHER A WINDOW IS A CHILD WINDOW
* OR DESCENDANT WINDOW OF A SPECIFIED PARENT WINDOW
* P.S. VFP КОНТРОЛЫ - РИСОВАННЫЕ БИТМАПЫ, А НЕ ОКНА, НО НЕ ВСЕГДА
* НАПРИМЕР COMBOBOX - РИСУНОК, А ЕГО ВЫПАДАЮЩИЙ СПИСОК - ОКНО !
* (ИНАЧЕ СПИСОК НЕВОЗМОЖНО БЫЛО БЫ ПОКАЗАТЬ ЗА ПРЕДЕЛАМИ ФОРМЫ)

LPARAMETERS tnHWndParent AS Integer, tnHWndChild AS Integer
LOCAL lnIsChild AS Integer
	IF !THIS.isLoaded("IsChild")
		DECLARE LONG IsChild IN Win32API LONG, LONG
	ENDIF
	*
	lnIsChild=IsChild(m.tnHWndParent, m.tnHWndChild)
RETURN m.lnIsChild<>0
ENDPROC
PROCEDURE isloaded
LPARAMETERS lcFunctionName as String
LOCAL ARRAY laDeclaredDlls[1,3]
LOCAL lnLen as Integer
	lnLen = ADLLS(m.laDeclaredDlls)
RETURN ASCAN(m.laDeclaredDlls, m.lcFunctionName , 1, m.lnLen , 2, 15) <> 0
ENDPROC
PROCEDURE loadicon
* ЗАГРУЗКА ИКОНКИ (ПАРАМЕТР СМ. В WINAPI.H РАЗДЕЛ ICON)
* РЕЗУЛЬТАТ : УСПЕШНО, ЕСЛИ lnHandle > 0
* This.LoadIcon(32516) && Information
LPARAMETERS tnIconId AS Integer
LOCAL lnHandle AS Integer
	IF !THIS.isLoaded("LoadIcon")
		DECLARE INTEGER LoadIcon IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	lnHandle=LoadIcon(0, m.tnIconId)
RETURN m.lnHandle
ENDPROC
PROCEDURE loadimage
* ЗАГРУЖАЕТ ФАЙЛ ИКОНКИ КАК РЕСУРС WINDOWS
* ВОЗВРАЩАЕТ RESOURCE HANDLE > 0
*  0	- ОШИБКА ПРИ ЗАГРУЗКЕ
* -1	- ФАЙЛ НЕ НАЙДЕН
LPARAMETERS tcIconFileName AS String
LOCAL lcTempFile AS String, lnHandle AS Integer
	lnHandle=-1
	*
	IF !THIS.isLoaded("LoadImage")
		DECLARE INTEGER LoadImage IN WIN32API;
				INTEGER, STRING, INTEGER, INTEGER, INTEGER, INTEGER
	ENDIF
	*
	lcTempFile=This.TempFile()
	COPY FILE (m.tcIconFileName) TO (m.lcTempFile)
	lnHandle=LoadImage(0, m.lcTempFile, 1, 0, 0, 0x0010)
	ERASE (m.lcTempFile)
RETURN m.lnHandle
ENDPROC
PROCEDURE loadkeyboardlayout
* ЗАГРУЗКА КЛАВИАТУРНОЙ РАСКЛАДКИ ('00000409'-English '00000419'-RUSSIAN)
* This.LoadKeyboardLayout(LANGID_RUS)
* This.LoadKeyboardLayout(LANGID_ENG)
LPARAMETERS tcLayout AS String
	IF !THIS.isLoaded("LoadKeyboardLayout")
		DECLARE INTEGER LoadKeyboardLayout IN WIN32API STRING, INTEGER
	ENDIF
	*
	LoadKeyboardLayout(tcLayout, KLF_ACTIVATE)

* DECLARE INTEGER GetKeyboardLayout IN win32api INTEGER
* ?GetKeyboardLayout(0)    && Даст текущую раскладку

*!*	DECLARE GetKeyboardLayoutName IN WIN32API STRING
*!*	DECLARE ActivateKeyboardLayout IN WIN32API INTEGER, INTEGER
*!*	LOCAL lcString
*!*	lcString = SPACE(8)
*!*	GetKeyboardLayoutName(@lcString)
*!*	MESSAGEBOX(lcString)
*!*	IF lcString # '00000409' && 409-Eng 419-Rus
*!*		ActivateKeyboardLayout(1,0)
*!*	ENDIF
*!* CLEAR DLLS 'GetKeyboardLayoutName', 'ActivateKeyboardLayout'

*!*	FUNCTION RusLatKey						&& Переключение раскладки клавиатуры RUS/LAT
*!*	LPARAMETERS tlRus						&& ВАРИАНТ 1
*!*	ASSERT VARTYPE(tlRus) = 'L'
*!*	LOCAL lnRetVal
*!*	* DECLARE LONG ActivateKeyboardLayout IN WIN32API;
*!*			INTEGER	nHandleToKeyboardLayout,;
*!*			INTEGER	nKeyboardLayoutFlags
*!*	DECLARE LONG ActivateKeyboardLayout IN WIN32API INTEGER, INTEGER
*!*	lnRetVal=ActivateKeyboardLayout(IIF(tlRus,68748313,67699721),0)
*!*	CLEAR DLLS 'ActivateKeyboardLayout'
*!*	RETURN lnRetVal	= 67699721				&& 67699721


*!*	FUNCTION LatRusKey						&& Переключение раскладки клавиатуры RUS/LAT
*!*	LPARAMETERS tlRus						&& ВАРИАНТ 2
*!*	ASSERT VARTYPE(tlRus) = 'L'
*!*	LOCAL lnRetVal
*!*	DECLARE LONG LoadKeyboardLayout IN WIN32API;
*!*			STRING pwszKLID,;
*!*			INTEGER nKeyboardLayoutFlags
*!*	lnRetVal = LoadKeyboardLayout(IIF(tlRus,'00000419','00000409'),1)
*!*	CLEAR DLLS 'LoadKeyboardLayout'
*!*	RETURN lnRetVal	= 68748313				&& 68748313

*!*	//  Primary language IDs.
*!*	#define LANG_NEUTRAL                     0x00
*!*	#define LANG_AFRIKAANS                   0x36
*!*	#define LANG_ALBANIAN                    0x1c
*!*	#define LANG_ARABIC                      0x01
*!*	#define LANG_ARMENIAN                    0x2b
*!*	#define LANG_ASSAMESE                    0x4d
*!*	#define LANG_AZERI                       0x2c
*!*	#define LANG_BASQUE                      0x2d
*!*	#define LANG_BELARUSIAN                  0x23
*!*	#define LANG_BENGALI                     0x45
*!*	#define LANG_BULGARIAN                   0x02
*!*	#define LANG_CATALAN                     0x03
*!*	#define LANG_CHINESE                     0x04
*!*	#define LANG_CROATIAN                    0x1a
*!*	#define LANG_CZECH                       0x05
*!*	#define LANG_DANISH                      0x06
*!*	#define LANG_DUTCH                       0x13
*!*	#define LANG_ENGLISH                     0x09
*!*	#define LANG_ESTONIAN                    0x25
*!*	#define LANG_FAEROESE                    0x38
*!*	#define LANG_FARSI                       0x29
*!*	#define LANG_FINNISH                     0x0b
*!*	#define LANG_FRENCH                      0x0c
*!*	#define LANG_GEORGIAN                    0x37
*!*	#define LANG_GERMAN                      0x07
*!*	#define LANG_GREEK                       0x08
*!*	#define LANG_GUJARATI                    0x47
*!*	#define LANG_HEBREW                      0x0d
*!*	#define LANG_HINDI                       0x39
*!*	#define LANG_HUNGARIAN                   0x0e
*!*	#define LANG_ICELANDIC                   0x0f
*!*	#define LANG_INDONESIAN                  0x21
*!*	#define LANG_ITALIAN                     0x10
*!*	#define LANG_JAPANESE                    0x11
*!*	#define LANG_KANNADA                     0x4b
*!*	#define LANG_KASHMIRI                    0x60
*!*	#define LANG_KAZAK                       0x3f
*!*	#define LANG_KONKANI                     0x57
*!*	#define LANG_KOREAN                      0x12
*!*	#define LANG_LATVIAN                     0x26
*!*	#define LANG_LITHUANIAN                  0x27
*!*	#define LANG_MACEDONIAN                  0x2f
*!*	#define LANG_MALAY                       0x3e
*!*	#define LANG_MALAYALAM                   0x4c
*!*	#define LANG_MANIPURI                    0x58
*!*	#define LANG_MARATHI                     0x4e
*!*	#define LANG_NEPALI                      0x61
*!*	#define LANG_NORWEGIAN                   0x14
*!*	#define LANG_ORIYA                       0x48
*!*	#define LANG_POLISH                      0x15
*!*	#define LANG_PORTUGUESE                  0x16
*!*	#define LANG_PUNJABI                     0x46
*!*	#define LANG_ROMANIAN                    0x18
*!*	#define LANG_RUSSIAN                     0x19
*!*	#define LANG_SANSKRIT                    0x4f
*!*	#define LANG_SERBIAN                     0x1a
*!*	#define LANG_SINDHI                      0x59
*!*	#define LANG_SLOVAK                      0x1b
*!*	#define LANG_SLOVENIAN                   0x24
*!*	#define LANG_SPANISH                     0x0a
*!*	#define LANG_SWAHILI                     0x41
*!*	#define LANG_SWEDISH                     0x1d
*!*	#define LANG_TAMIL                       0x49
*!*	#define LANG_TATAR                       0x44
*!*	#define LANG_TELUGU                      0x4a
*!*	#define LANG_THAI                        0x1e
*!*	#define LANG_TURKISH                     0x1f
*!*	#define LANG_UKRAINIAN                   0x22
*!*	#define LANG_URDU                        0x20
*!*	#define LANG_UZBEK                       0x43
*!*	#define LANG_VIETNAMESE                  0x2a

*!*	Identifier Predefined symbol Language 
*!*	0x00 LANG_NEUTRAL Neutral 
*!*	0x01 LANG_ARABIC Arabic 
*!*	0x02 LANG_BULGARIAN Bulgarian 
*!*	0x03 LANG_CATALAN Catalan  
*!*	0x04 LANG_CHINESE Chinese 
*!*	0x05 LANG_CZECH Czech 
*!*	0x06 LANG_DANISH Danish 
*!*	0x07 LANG_GERMAN German 
*!*	0x08 LANG_GREEK Greek 
*!*	0x09 LANG_ENGLISH English  
*!*	0x0a LANG_SPANISH Spanish  
*!*	0x0b LANG_FINNISH Finnish 
*!*	0x0c LANG_FRENCH French 
*!*	0x0d LANG_HEBREW Hebrew 
*!*	0x0e LANG_HUNGARIAN Hungarian 
*!*	0x0f LANG_ICELANDIC Icelandic 
*!*	0x10 LANG_ITALIAN Italian  
*!*	0x11 LANG_JAPANESE Japanese 
*!*	0x12 LANG_KOREAN Korean 
*!*	0x13 LANG_DUTCH Dutch 
*!*	0x14 LANG_NORWEGIAN Norwegian 
*!*	0x15 LANG_POLISH Polish 
*!*	0x16 LANG_PORTUGUESE Portuguese 
*!*	0x18 LANG_ROMANIAN Romanian 
*!*	0x19 LANG_RUSSIAN Russian 
*!*	0x1a LANG_CROATIAN Croatian 
*!*	0x1a LANG_SERBIAN Serbian 
*!*	0x1b LANG_SLOVAK Slovak 
*!*	0x1c LANG_ALBANIAN Albanian 
*!*	0x1d LANG_SWEDISH Swedish  
*!*	0x1e LANG_THAI Thai 
*!*	0x1f LANG_TURKISH Turkish  
*!*	0x20 LANG_URDU Urdu 
*!*	0x21 LANG_INDONESIAN Indonesian 
*!*	0x22 LANG_UKRAINIAN Ukrainian 
*!*	0x23 LANG_BELARUSIAN Belarusian 
*!*	0x24 LANG_SLOVENIAN Slovenian 
*!*	0x25 LANG_ESTONIAN Estonian 
*!*	0x26 LANG_LATVIAN Latvian 
*!*	0x27 LANG_LITHUANIAN Lithuanian 
*!*	0x29 LANG_FARSI Farsi 
*!*	0x2a LANG_VIETNAMESE Vietnamese 
*!*	0x2b LANG_ARMENIAN Armenian 
*!*	0x2c LANG_AZERI Azeri 
*!*	0x2d LANG_BASQUE Basque 
*!*	0x2f LANG_MACEDONIAN FYRO Macedonian 
*!*	0x36 LANG_AFRIKAANS Afrikaans 
*!*	0x37 LANG_GEORGIAN Georgian 
*!*	0x38 LANG_FAEROESE Faeroese 
*!*	0x39 LANG_HINDI Hindi 
*!*	0x3e LANG_MALAY Malay 
*!*	0x3f LANG_KAZAK Kazak 
*!*	0x40 LANG_KYRGYZ Kyrgyz 
*!*	0x41 LANG_SWAHILI Swahili 
*!*	0x43 LANG_UZBEK Uzbek 
*!*	0x44 LANG_TATAR Tatar 
*!*	0x45 LANG_BENGALI Not supported. 
*!*	0x46 LANG_PUNJABI Punjabi 
*!*	0x47 LANG_GUJARATI Gujarati 
*!*	0x48 LANG_ORIYA Not supported. 
*!*	0x49 LANG_TAMIL Tamil 
*!*	0x4a LANG_TELUGU Telugu 
*!*	0x4b LANG_KANNADA Kannada 
*!*	0x4c LANG_MALAYALAM Not supported. 
*!*	0x4d LANG_ASSAMESE Not supported. 
*!*	0x4e LANG_MARATHI Marathi 
*!*	0x4f LANG_SANSKRIT Sanskrit 
*!*	0x50 LANG_MONGOLIAN Mongolian 
*!*	0x56 LANG_GALICIAN Galician 
*!*	0x57 LANG_KONKANI Konkani 
*!*	0x58 LANG_MANIPURI Not supported. 
*!*	0x59 LANG_SINDHI Not supported. 
*!*	0x5a LANG_SYRIAC Syriac 
*!*	0x60 LANG_KASHMIRI Not supported. 
*!*	0x61 LANG_NEPALI Not supported. 
*!*	0x65 LANG_DIVEHI Divehi 
*!*	0x7f LANG_INVARIANT   

ENDPROC
PROCEDURE loadlibrary
* ЗАГРУЗКА ACTIVEX OCX  ==  DLL БИБЛИОТЕКИ
* ПАРАМЕТР : ПУТЬ И ИМЯ OCX ФАЙЛА
* РЕЗУЛЬТАТ : ХЭНДЛ ЗАГРУЖЕННОЙ БИБЛИОТЕКИ ИЛИ 0
* СМ. This.RegSvr32()
LPARAMETERS tcOcxFileName AS String
LOCAL lnHandle AS Integer
	IF !THIS.isLoaded("LoadLibrary")
		DECLARE INTEGER LoadLibrary IN WIN32API STRING
	ENDIF

	lnHandle = LoadLibrary(m.tcOcxFileName)
RETURN m.lnHandle

ENDPROC
PROCEDURE loadlibraryex
* ЗАГРУЗКА ACTIVEX OCX  =  =  DLL БИБЛИОТЕКИ
* ПАРАМЕТР : ПУТЬ И ИМЯ OCX ФАЙЛА
* РЕЗУЛЬТАТ : ХЭНДЛ ЗАГРУЖЕННОЙ БИБЛИОТЕКИ ИЛИ 0
* СМ. This.RegSvr32()
LPARAMETERS tcOcxFileName AS String
LOCAL lnHandle AS Integer
	IF !THIS.isLoaded("LoadLibrary")
		DECLARE INTEGER LoadLibraryEx IN WIN32API;
				String @ lpFileName, ;				&& file name of module
				Integer hFile, ;					&& reserved, must be NULL
				Integer dwFlags						&& entry-point execution option
	ENDIF

	lnHandle = LoadLibrary(m.tcOcxFileName, NULL, )
RETURN m.lnHandle

ENDPROC
PROCEDURE localerrormessage
* ЛОКАЛИЗОВАННАЯ СТРОКА СООБЩЕНИЯ ОБ ОШИБКЕ ПО ЕЕ НОМЕРУ ИЛИ ПУСТАЯ СТРОКА
* ПРИМЕР1 :	This.LocalErrorMessage('ShellExecute', 0) =
* 			'Ошибка при выполнении SHELLEXECUTE' + CHR_CR +;
*			'Недостаточно памяти или ресурсов'
* ПРИМЕР2 :	This.LocalErrorMessage('WinExec', 32) = ''
LPARAMETERS tcProcName AS String, tnError AS Integer
LOCAL ARRAY laError[1]
LOCAL lcProcName AS String, lcMessage AS String
	lcProcName=UPPER(ALLTRIM(m.tcProcName))
	lcMessage='Неизвестная ошибка No '+TRANSFORM(m.tnError)
	*
	DO CASE
	CASE m.lcProcName='SHELLEXECUTE'
		DO CASE
		CASE m.tnError>32
			RETURN ''					&& No error ocurred
		CASE BETWEEN(m.tnError, 0, 32)	&& Error range 0-32
			DIMENSION laError[33]		&& Array range 1-33
			laError[01]='Недостаточно памяти или ресурсов'					&& The system is out of memory or resources
			laError[03]='Соответствующий файл не найден'						&& The specified file was not found
			laError[04]='Соответствующий каталог не существует'				&& The specified path was not found
			laError[06]='Доступ к соответствующему файлу запрещен'			&& The operating system denied access to the specified file
			laError[09]='Недостаточно памяти для завершения операции'			&& There was not enough memory to complete the operation
			laError[12]='Неверный формат .exe файла'							&& The .exe file is invalid (non-Win32® .exe or error in .exe image)
			laError[27]='Конфликт одновременного доступа'						&& A sharing violation occurred
			laError[28]='Неверная ассоциация для этого типа файлов'			&& The file name association is incomplete or invalid
			laError[29]='Запрошенное для запуска время истекло'				&& The DDE transaction could not be completed because the request timed out
			laError[30]='Не удалось запустить соответствующую программу'		&& The DDE transaction failed
			laError[31]='Соответствующая программа сейчас недоступна'			&& The DDE transaction could not be completed because other DDE transactions were being processed
			laError[32]='Соответствующая программа не установлена'			&& There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable
			laError[33]='Соответствующая динамическая библиотека не найдена'	&& The specified dynamic-link library was not found
			*
			IF VARTYPE(laError[m.tnError+1])='C'
				lcMessage=laError[m.tnError+1]
			ENDIF
		ENDCASE
	CASE m.lcProcName='WINEXEC'
		DO CASE
		CASE m.tnError>31
			RETURN ''					&& No error ocurred
		CASE BETWEEN(m.tnError, 0, 31)	&& Error range 0-31
			DIMENSION laError[32]		&& Array range 1-32
			laError[01]='Недостаточно памяти или ресурсов'					&& The system is out of memory or resources
			laError[03]='Соответствующий файл не найден'						&& The specified file was not found
			laError[04]='Соответствующий каталог не существует'				&& The specified path was not found
			laError[12]='Неверный формат .exe файла'							&& The .exe file is invalid (non-Win32® .exe or error in .exe image)
			IF VARTYPE(laError[m.tnError+1])='C'
				lcMessage=laError[m.tnError+1]
			ENDIF
		ENDCASE
	ENDCASE
RETURN 'Ошибка при выполнении '+m.lcProcName+CHR_CR+m.lcMessage
ENDPROC
PROCEDURE mcisendstring
* ВЫПОЛНЕНИЕ MCI КОМАНД
* РЕЗУЛЬТАТ - СТРОКА С ОШИБКОЙ ИЛИ ПУСТО ЕСЛИ ВСЕ OK
* РАБОТА С AVI-ФАЙЛОМ :
* ОТКРЫТЬ AVI ФАЙЛ С АЛИАСОМ Animation В ОКНЕ С ПАРАМЕТРАМИ 12345
* tcCommand = 'open c:\foxrain.avi type AVIVideo alias Animation parent '+TRANSFORM(ThisForm.HWnd) + ' style ' + TRANSFORM(12345)
* ПЕРЕМЕСТИТЬ И ИЗМЕНИТЬ РАЗМЕРЫ ОКНА
* tcCommand = 'put Animation window at 10 10 200 200'
* ПРОИГРАТЬ AVI ФАЙЛ, ПРИЧЕМ WAIT - ДОЖДАТЬСЯ ВЫПОЛНЕНИЯ КОМАНДЫ
* tcCommand = 'play Animation wait'
* ЗАКРЫТЬ AVI
* tcCommand = 'close Animation'
* ПРОИГРЫВАНИЕ CD-AUDIO
* OPENDOOR 
* tcCommand = 'set cdaudio door open wait'
* CLOSEDOOR 
* tcCommand = 'set cdaudio door closed wait'
* OPENDEVICE 
* tcCommand = 'open cdaudio shareable'
* CLOSEDEVICE 
* tcCommand = 'stop cdaudio wait'
* tcCommand = 'close cdaudio'
LPARAMETERS tcCommand AS String
LOCAL lcReturn AS String, lnError AS Integer, lcError AS String, lcBuffer  AS String
	STORE SPACE(250) TO lcReturn, lcError 
	*
	IF !THIS.isLoaded("mciSendString")
		DECLARE INTEGER mciSendString IN WINMM.DLL STRING, STRING @, INTEGER, INTEGER
	ENDIF
	*
	lnError=mciSendString(m.tcCommand, @lcReturn, LEN(m.lcReturn), 0)
	IF m.lnError=0
		lcError=''
	ELSE
		IF !THIS.isLoaded("mciGetErrorString")
			DECLARE INTEGER mciGetErrorString IN WINMM.DLL INTEGER, STRING @, INTEGER
		ENDIF
		*
	    lcError=REPLICATE(CHR(0), 250) 
	    mciGetErrorString(m.lnError, @lcError, LEN(m.lcError))
		lcError=SUBSTR(m.lcError, 1, AT(CHR(0), m.lcError)-1)
	ENDIF
RETURN m.lcError
ENDPROC
PROCEDURE messagebeep
* РАЗНОЕ БИБИКАНЬЕ, ПАРАМЕТР - СМ. РАЗДЕЛ MESSAGEBEEP В WINAPI.H И THIS.BEEP()
* ПРИМЕР : THIS.MESSAGEBEEP(-1)
LPARAMETERS tnBeepType AS Integer
LOCAL lnSuccess AS Integer
	tnBeepType=IIF(VARTYPE(m.tnBeepType)='N', m.tnBeepType, MB_SIMPLEBEEP)
	*
	IF !THIS.isLoaded("MessageBeep")
		DECLARE INTEGER MessageBeep IN WIN32API INTEGER
	ENDIF
	*
	lnSuccess=MessageBeep(m.tnBeepType)
RETURN m.lnSuccess<>0

ENDPROC
PROCEDURE netmessagebuffersend
* ПОСЫЛКА СООБЩЕНИЯ ПО СЕТИ, РЕЗУЛЬТАТ - УСПЕХ ВЫПОЛНЕНИЯ
* УДОБНО ДЛЯ ПОЛУЧЕНИЯ СООБЩЕНИЙ ОТ МОЛЧАЛИВЫХ СЕРВЕРНЫХ ПРИЛОЖЕНИЙ
* НЕ РАБОТАЕТ ПОД WIN9X/ME, ТОЛЬКО ПОД WNT/2K/XP, ПРИЧЕМ ДОЛЖЕН БЫТЬ ЗАПУЩЕН СЕРВИС MESSENGER
* НАПРИМЕР : АНАЛОГОМ КОМАНДЫ net send ek текст сообщения
* БУДЕТ : This.NetMessageBufferSend('текст сообщения', 'ek', 'Вася Пупкин')
* ПОСЛАТЬ СООБЩЕНИЕ САМОМУ СЕБЕ МОЖНО ТАК :
* This.NetMessageBufferSend('Error report')
LPARAMETERS tcMessage AS String, tcToName AS String, tcFromName AS String, tcServerName AS String
LOCAL lnResult AS Integer	&& tcServerName - возможно имя сервера посредника для WNT4.0
	* ПЕРЕВЕДЕМ В UNICODE
	tcMessage=STRCONV(m.tcMessage+CHR(0), 5)
	tcServerName=IIF(VARTYPE(m.tcServerName)='C', STRCONV(m.tcServerName+CHR(0), 5), .NULL.)
	tcToName=STRCONV(IIF(VARTYPE(m.tcToName)='C', m.tcToName, RTRIM(LEFT(SYS(0), AT('#', SYS(0)) - 1))) + CHR(0), 5)
	tcFromName=IIF(VARTYPE(m.tcFromName)='C', STRCONV(m.tcFromName+CHR(0), 5), .NULL.)
	*
	IF !THIS.isLoaded("NetMessageBufferSend")
		DECLARE LONG NetMessageBufferSend IN NETAPI32.DLL STRING @, STRING @, STRING @, STRING @, LONG
	ENDIF
	*
	lnResult=NetMessageBufferSend(@tcServerName, @tcToName, @tcFromName, @tcMessage, LEN(m.tcMessage))
RETURN m.lnResult=0
ENDPROC
PROCEDURE openfile
* ОТКРЫТЬ ФАЙЛ И ВЕРНУТЬ ХЭНДЛ
LPARAMETERS tcFileName AS String
LOCAL lcBuffer AS String, lnHandle AS Integer
	IF !THIS.isLoaded("OpenFile")
		DECLARE INTEGER OpenFile IN WIN32API STRING, STRING @, INTEGER
	ENDIF
	*
	lcBuffer=REPLICATE(CHR(0), 250)
	lnHandle=OpenFile(m.tcFileName, @lcBuffer, 1)
RETURN m.lnHandle
ENDPROC
PROCEDURE opensemaphore
* ОТКРЫТИЕ СЕМАФОРА С УНИКАЛЬНЫМ ИДЕНТИФИКАТОРОМ = TCUNIQUE
* РЕЗУЛЬТАТ - НЕНУЛЕВОЙ УКАЗАТЕЛЬ НА СУЩЕСТВУЮЩИЙ СЕМАФОР ИЛИ 0,
* ЕСЛИ ТАКОГО СЕМАФОРА НЕ СУЩЕСТВУЕТ
LPARAMETERS tcUnique AS String
LOCAL lnHandle AS Integer
	* TCUNIQUE IS LIMITED TO MAX_PATH CHARACTERS AND CAN CONTAIN ANY
	* CHARACTER EXCEPT THE BACKSLASH PATH-SEPARATOR CHARACTER (\)
	* NAME COMPARISON IS CASE SENSITIVE
	tcUnique=CHRTRAN(m.tcUnique, '\', '_')
	*
	IF !THIS.isLoaded("OpenSemaphore")
		DECLARE INTEGER OpenSemaphore IN WIN32API INTEGER, INTEGER, STRING
	ENDIF
	*
	lnHandle=OpenSemaphore(STANDARD_RIGHTS_REQUIRED, 0, m.tcUnique)
RETURN m.lnHandle
ENDPROC
PROCEDURE regclosekey
* ЗАКРЫТЬ КЛЮЧ РЕЕСТРА
* РЕЗУЛЬТАТ : .T. - КЛЮЧ УСПЕШНО ЗАКРЫТ, .F. - ОШИБКА ЗАКРЫТИЯ КЛЮЧА
LPARAMETERS tnKeyHandle as Integer
LOCAL lnError as Integer
	IF !THIS.isLoaded("RegCloseKey")
		DECLARE INTEGER RegCloseKey IN WIN32API INTEGER
	ENDIF
	*
	lnError=RegCloseKey(m.tnKeyHandle)
RETURN m.lnError=0
ENDPROC
PROCEDURE regcreatekey
* СОЗДАТЬ КЛЮЧ РЕЕСТРА
* РЕЗУЛЬТАТ : ХЭНДЛ СОЗДАННОГО КЛЮЧА (INTEGER) ИЛИ 0 ПРИ ОШИБКЕ
* This.RegCreateKey(HKEY_LOCAL_MACHINE, 'Software\Microsoft\Shared Tools\MSInfo')
LPARAMETERS tnRoot AS Integer, tcPath AS String
LOCAL lnKeyHandle as Integer
	lnKeyHandle=0
	*
	IF !THIS.isLoaded("RegCreateKey")
		DECLARE INTEGER RegCreateKey IN WIN32API INTEGER, STRING, INTEGER @lnKeyHandle
	ENDIF
	*
	RegCreateKey(m.tnRoot, m.tcPath, @lnKeyHandle)
RETURN m.lnKeyHandle
ENDPROC
PROCEDURE regdeletekey
* УДАЛЯЕТ ВЕТКУ КЛЮЧЕЙ СО ВСЕМИ ПОДВЕТКАМИ !
* THE FUNCTION ALSO DELETES ALL SUBKEYS AND VALUES !
* This.RegDeleteKey(REG_HKEY_LOCAL_MACHINE, REG_KEY_WIN9X_CURRENTVERSION + '\Run')
LPARAMETERS tnRoot AS Integer, tcPath AS String
LOCAL lnError AS Integer
	IF !THIS.isLoaded("RegDeleteKey")
		DECLARE INTEGER RegDeleteKey IN WIN32API INTEGER, STRING @
	ENDIF
	*
	lnError=RegDeleteKey(m.tnRoot, @tcPath)
RETURN m.lnError=0
ENDPROC
PROCEDURE regdeletevalue
* УДАЛЯЕМ КЛЮЧ TCKEY ВЕТКИ TCPATH РАЗДЕЛА TNROOT
* This.RegDeleteValue(REG_HKEY_LOCAL_MACHINE, REG_KEY_WIN9X_CURRENTVERSION + '\Run', 'My cool program ;)')
* РЕЗУЛЬТАТ : .T. - КЛЮЧ УСПЕШНО УДАЛЕН
LPARAMETERS tnRoot AS Integer, tcPath AS String, tcKey AS String
LOCAL lnKeyHandle AS Integer
	lnKeyHandle=This.RegOpenKey(m.tnRoot, m.tcPath)
	*
	IF m.lnKeyHandle>0
		IF !THIS.isLoaded("RegDeleteValue")
			DECLARE INTEGER RegDeleteValue IN WIN32API INTEGER, STRING @
		ENDIF
		*
		lnError=RegDeleteValue(m.lnKeyHandle, @tcKey)
	    This.RegCloseKey(m.lnKeyHandle)
	    *
		RETURN m.lnError=0
	ENDIF
RETURN .F.
ENDPROC
PROCEDURE reggetkey
* ПРОЧЕСТЬ СТРОКОВЫЙ ИЛИ ЧИСЛОВОЙ КЛЮЧ РЕЕСТРА
* РЕЗУЛЬТАТ : СТРОКА ИЛИ ЧИСЛО СО ЗНАЧЕНИЕМ КЛЮЧА ИЛИ .F. ПРИ ОШИБКЕ
* This.RegGetKey(-2147483646, 'Software\Microsoft\Shared Tools\MSInfo', 'Path')
* This.RegGetKey(-2147483646, 'Hardware\Description\System\CentralProcessor\0', '~MHz')
* REG_HKEY_CLASSES_ROOT = -2147483648
* REG_KEY_BROWSER = 'HTTP\shell\open\ddeexec\Application'
* This.RegGetKey(REG_HKEY_CLASSES_ROOT, REG_KEY_BROWSER) = 'IExplore'
LPARAMETERS tnRoot, tcPath, tcKey
LOCAL lcKey, lnKeyHandle, lnKeyType, lnKeyLength, lcKeyValue, lnError
	lcKey=IIF(VARTYPE(tcKey)<>'C', '', m.tcKey)
	lnKeyHandle=This.RegOpenKey(m.tnRoot, m.tcPath)
	*
	IF m.lnKeyHandle<>0
		IF !THIS.isLoaded("RegQueryValueEx")
			DECLARE INTEGER RegQueryValueEx IN WIN32API INTEGER, STRING, INTEGER, INTEGER @lnKeyType, STRING @lcKeyValue, INTEGER @lnKeyLength
		ENDIF
		*
		lnKeyType=0
		lnKeyLength=256
		lcKeyValue=SPACE(m.lnKeyLength)
		lnError=RegQueryValueEx(m.lnKeyHandle, m.lcKey, 0, @lnKeyType, @lcKeyValue, @lnKeyLength)
		This.RegCloseKey(m.lnKeyHandle)
		*
		IF m.lnError=0
			DO CASE
			CASE m.lnKeyType=1 OR m.lnKeyType=2	&& 1 - Data string (REG_SZ) 2-(REG_EXPAND_SZ)
				RETURN LEFT(m.lcKeyValue, m.lnKeyLength - 1)
			CASE m.lnKeyType=4					&& 4 - 32 bit number DWORD
				RETURN CTOBIN(LEFT(m.lcKeyValue, 4), '4RS')
			OTHE								&& 3 - Binary data
			ENDCASE
		ENDIF
	ENDIF
RETURN .F.

ENDPROC
PROCEDURE regopenkey
* ОТКРЫТЬ КЛЮЧ РЕЕСТРА
* РЕЗУЛЬТАТ : ХЭНДЛ ОТКРЫТОГО КЛЮЧА (INTEGER) ИЛИ 0 ПРИ ОШИБКЕ
* This.RegOpenKey(HKEY_LOCAL_MACHINE, 'Software\Microsoft\Shared Tools\MSInfo')
LPARAMETERS tnRoot AS Integer, tcPath AS String
LOCAL lnKeyHandle AS Integer
	lnKeyHandle=0
	*
	IF !THIS.isLoaded("RegOpenKey")
		DECLARE INTEGER RegOpenKey IN WIN32API INTEGER, STRING @, INTEGER @
	ENDIF
	*
	RegOpenKey(m.tnRoot, m.tcPath, @lnKeyHandle)
RETURN m.lnKeyHandle
ENDPROC
PROCEDURE regsetkey
* ЗАПИСАТЬ СТРОКОВЫЙ ИЛИ ЧИСЛОВОЙ КЛЮЧ РЕЕСТРА
* РЕЗУЛЬТАТ : .T. - КЛЮЧ УСПЕШНО ЗАПИСАН, .F. - ОШИБКА ЗАПИСИ КЛЮЧА
* ПОДМЕНА MSINFO НА АИДУ ;)
* This.RegSetKey(REG_HKEY_LOCAL_MACHINE, 'Software\Microsoft\Shared Tools\MSInfo', 'Path', 'C:\Util\Aida32.exe')
* АВТОЗАПУСК : (\Run,\RunOnce,\RunOnceEx)
* This.RegSetKey(REG_HKEY_LOCAL_MACHINE, REG_KEY_WIN9X_CURRENTVERSION + '\Run', 'My cool program ;)', 'C:\VFP\MAIN\Main.exe')
LPARAMETERS tnRoot AS Integer, tcPath AS String, tcKey AS String, tuValue AS Variant
LOCAL lnKeyHandle, lnKeyType, lnKeyLength, lcKeyValue, lnError
	lnKeyHandle=This.RegOpenKey(m.tnRoot, m.tcPath)
	*
	IF m.lnKeyHandle>0
		DO CASE
		CASE VARTYPE(m.tuValue)='C'
			* DATA STRING
			lnKeyType=1
			lcKeyValue=m.tuValue+CHR(0)
		CASE VARTYPE(m.tuValue)='N'
			* 32 BIT NUMBER
			lnKeyType=4
			lcKeyValue=BINTOC(m.tuValue, '4RS')+CHR(0)
		OTHERWISE
			RETURN .F.
		ENDCASE
		*
		lnKeyLength=LEN(m.lcKeyValue)
		*
		IF !THIS.isLoaded("RegSetValueEx")
			DECLARE INTEGER RegSetValueEx IN WIN32API INTEGER, STRING, INTEGER, INTEGER, STRING, INTEGER
		ENDIF
		*
		lnError=RegSetValueEx(m.lnKeyHandle, m.tcKey, 0, m.lnKeyType, m.lcKeyValue, m.lnKeyLength)
		This.RegCloseKey(m.lnKeyHandle)
		RETURN m.lnError=0
	ENDIF
RETURN .F.
ENDPROC
PROCEDURE regsvr32
* РЕГИСТРАЦИЯ OCX ACTIVEX БИБЛИОТЕКИ В РЕЕСТРЕ ПОСРЕДСТВОМ ВСТРОЕННЫХ ПРОЦЕДУР
* ЗАМЕНИТЕЛЬ REGSVR32.EXE FILENAME.OCX И REGSVR32.EXE /U FILENAME.OCX
* ПАРАМЕТРЫ : ПУТЬ И ИМЯ OCX ФАЙЛА (C), REGISTER / UNREGISTER (L)
* РЕЗУЛЬТАТ : СТРОКА С СООБЩЕНИЕМ ОБ ОШИБКЕ ИЛИ ПУСТО
LPARAMETERS tcOcxFileName AS String, tlRegister AS Logical
LOCAL lcMessage AS String, lnHandle AS Integer, lcProcedure AS String, lnError AS Integer
	lcMessage=''
	lnHandle=This.LoadLibrary(m.tcOcxFileName)
	*
	IF m.lnHandle>0
		lcProcedure=IIF(m.tlRegister, 'DllRegisterServer', 'DllUnregisterServer')
		*
		IF This.GetProcAddress(m.lnHandle, m.lcProcedure)>0
			IF m.tlRegister
				lnError=This.DllRegisterServer(m.tcOcxFileName)
			ELSE
				lnError=This.DllUnregisterServer(m.tcOcxFileName)
			ENDIF
			*
			IF m.lnError<>0
				lcMessage='Ошибка при выполнении процедуры '+;
					m.lcProcedure+CHR_CR+'в библиотеке '+m.tcOcxFileName
			ENDIF
		ELSE
			lcMessage='Не найден адрес точки входа процедуры '+;
				m.lcProcedure+CHR_CR+'в библиотеке '+m.tcOcxFileName
		ENDIF
		IF !This.FreeLibrary(m.lnHandle)
			lcMessage='Ошибка освобождения библиотеки'+CHR_CR+m.tcOcxFileName
		ENDIF
	ELSE
		lcMessage='Ошибка загрузки библиотеки'+CHR_CR+m.tcOcxFileName
	ENDIF
RETURN m.lcMessage
ENDPROC
PROCEDURE releasecapture
* RESTORES NORMAL MOUSE INPUT PROCESSING
	IF !THIS.isLoaded("ReleaseCapture")
		DECLARE ReleaseCapture IN WIN32API
	ENDIF
	*
	ReleaseCapture()
ENDPROC
PROCEDURE releasedc
* RELEASES A DEVICE CONTEXT (DC), FREEING IT FOR USE BY OTHER APPLICATIONS
* This.ReleaseDC(ThisForm.Hwnd, This.GetDC(ThisForm.Hwnd))
LPARAMETERS tnHWnd AS Integer, tnDCHandle AS Integer
	IF !THIS.isLoaded("ReleaseDC")
		DECLARE INTEGER ReleaseDC IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	ReleaseDC(m.tnHWnd, m.tnDCHandle)
ENDPROC
PROCEDURE releasemutex
* ОСВОБОЖДЕНИЕ ОБЪЕКТА СИНХРОНИЗАЦИИ
* РЕЗУЛЬТАТ : УСПЕХ ОПЕРАЦИИ
LPARAMETERS tnHandle AS Integer
LOCAL lnSuccess AS Integer
	IF !THIS.isLoaded("ReleaseMutex")
		DECLARE INTEGER ReleaseMutex IN WIN32API INTEGER
	ENDIF

	lnSuccess = ReleaseMutex(m.tnHandle)
RETURN m.lnSuccess > 0
ENDPROC
PROCEDURE removedirectory
* УДАЛЕНИЕ КАТАЛОГА
* P.S. НИКАКИХ ПРЕИМУЩЕСТВ ПЕРЕД ВСТРОЕННОЙ RMDIR.
* ОБЩЕЕ В ПОВЕДЕНИИ REMOVEDIRECTORY И RMDIR :
* 1) НЕ УМЕЮТ УДАЛЯТЬ READONLY КАТАЛОГИ
* 2) ЗАПРОСТО РАСПРАВЛЯЮТСЯ С SYSTEM И HIDDEN ПАПКАМИ
* 3) ЦЕПОЧКИ ВЛОЖЕННЫХ КАТАЛОГОВ НЕ МОГУТ БЫТЬ УДАЛЕНЫ ЗА 1 ПРИСЕСТ
LPARAMETERS tcFolder AS String
LOCAL lnSuccess AS Integer
	lnSuccess = 0

	IF DIRECTORY(m.tcFolder, 1)
		IF !THIS.isLoaded("RemoveDirectory")
			DECLARE INTEGER RemoveDirectory IN WIN32API STRING
		ENDIF

		lnSuccess = RemoveDirectory(m.tcFolder)
	ENDIF
RETURN m.lnSuccess <> 0
ENDPROC
PROCEDURE removeicon
* УДАЛИМ ИКОНКУ В TITLEBAR ОКНА
* ПОСЛЕДОВАТЕЛЬНОСТЬ ДЕЙСТВИЙ ВАЖНА!
* ОРИГИНАЛЬНАЯ ИДЕЯ ВАДИМА ПИРОЖКОВА
LPARAMETERS tnHWnd AS Integer
	WITH This
		* УСТАНОВИМ ОТСУТСТВУЮЩИЙ В VFP ДИАЛОГОВЫЙ СТИЛЬ ОКНА (BorderStyle # 0,1,2,3!)
		.SetWindowLong(m.tnHWnd, GWL_EXSTYLE, WS_EX_DLGMODALFRAME)
		* ПЕРЕДЕРНЕМ ИКОНКУ С МАЛЕНЬКОЙ НА БОЛЬШУЮ, ХОТЯ И ТАК УЖЕ СТОИТ БОЛЬШАЯ ;)
		.SendMessage(m.tnHWnd, WM_SETICON, ICON_SMALL, 0)
		.SendMessage(m.tnHWnd, WM_SETICON, ICON_BIG, 0)
		* ЗАНУЛИМ УКАЗАТЕЛЬ ИКОНКИ, АССОЦИИРОВАННОЙ С КЛАССОМ ОКНА
		.SetClassLong(m.tnHWnd, GCL_HICON, 0)
	ENDWITH

* ПРИМЕР ПОЛУЧЕНИЯ TOOLWINDOW - БЕЗ ИКОНКИ,С КНОПКОЙ CLOSE ПОЛОВИННОЙ ВЫСОТЫ
* #DEFINE GWL_EXSTYLE				-20
* #DEFINE WS_EX_TOOLWINDOW		0x00000080
* DECLARE INTEGER SetWindowLong IN WIN32API INTEGER, INTEGER, INTEGER
* o=CREATEOBJECT('form')
* SetWindowLong(o.hWnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW)
* o.Show(1)
ENDPROC
PROCEDURE runprocess
* ЗАПУСК ПРИЛОЖЕНИЯ DOS ИЛИ WINDOWS C ОЖИДАНИЕМ РЕЗУЛЬТАТА
* ПАРАМЕТРЫ : КОМАНДНАЯ СТРОКА, РАБОЧАЯ ПАПКА ПРОЦЕССА, РЕЖИМ ОКНА, ПРИОРИТЕТ
* РЕЗУЛЬТАТ : 0 - ОШИБКА СОЗДАНИЯ ПРОЦЕССА
* 			  1 - ПРОЦЕСС УСПЕШНО ЗАВЕРШЕН
* 		   	 -1 - ПРОЦЕСС УБИТ ОПЕРАТОРОМ (НАЖАТ ESC)
* ПРИМЕЧАНИЕ : ЕСЛИ ПРОЦЕСС СНЯЛИ ТРЕМЯ ПАЛЬЦАМИ - ВЕРНЕТ 1
* ОСОБЕННОСТИ :
* ЕСЛИ К NORMAL_PRIORITY_CLASS ДОБАВИТЬ CREATE_NO_WINDOW,
* ТО ОКНО НЕ ПОКАЖЕТСЯ, ДАЖЕ ЕСЛИ ВЫСТАВЛЕНО SW_SHOWNORMAL

LPARAMETERS tcCommandLine AS String, tcWorkingDir AS String,;
	tnWindowState AS Integer, tnPriority AS Integer
LOCAL lnReturnValue AS Integer, lnProcessHandle AS Integer,;
	lnResult AS Integer, lcProcessInfo AS String, lcStartUpInfo AS String
	* CREATES A NEW PROCESS AND ITS PRIMARY THREAD
	IF !THIS.isLoaded("CreateProcess")
		DECLARE SHORT CreateProcess IN WIN32API;
			STRING, STRING, STRING, STRING, SHORT, INTEGER, STRING, STRING, STRING, STRING
	ENDIF
	* RETURNS THE PSEUDOHANDLE OF THE CURRENT PROCESS
	IF !THIS.isLoaded("GetCurrentProcess")
		DECLARE INTEGER GetCurrentProcess IN WIN32API
	ENDIF
	* WAITS UNTIL THE PROCESS IS IDLE FOR INPUT
	IF !THIS.isLoaded("WaitForInputIdle")
		DECLARE INTEGER WaitForInputIdle IN WIN32API	INTEGER, INTEGER
	ENDIF
	*
	* WAITS UNTIL THE PROCESS IS SIGNALLED OR THE TIMEOUT PERIOD EXPIRES
	IF !THIS.isLoaded("WaitForSingleObject")
		DECLARE INTEGER WaitForSingleObject IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	IF !THIS.isLoaded("TerminateProcess")
		DECLARE INTEGER TerminateProcess IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	IF !THIS.isLoaded("CloseHandle")
		DECLARE INTEGER CloseHandle	IN WIN32API INTEGER
	ENDIF
	*
	tcWorkingDir=IIF(VARTYPE(m.tcWorkingDir)<>'C' OR !DIRECTORY(m.tcWorkingDir), 0, ADDBS(ALLTRIM(m.tcWorkingDir))+CHR(0))
	tnWindowState=IIF(VARTYPE(m.tnWindowState)<>'N', SW_SHOWNORMAL, m.tnWindowState)
	tnPriority=IIF(VARTYPE(m.tnPriority)<>'N', NORMAL_PRIORITY_CLASS, m.tnPriority)
	lcStartUpInfo=CHR(68)+REPLICATE(CHR(0),43)+CHR(1)+REPLICATE(CHR(0), 3)+;
		CHR(m.tnWindowState)+REPLICATE(CHR(0), 19)
	lcProcessInfo=REPLICATE(CHR(0), 16)
	lnReturnValue=0					&& Ошибка создания процесса
	*
	IF CreateProcess(0, m.tcCommandLine, 0, 0, 1, m.tnPriority, 0, m.tcWorkingDir,;
		@lcStartUpInfo, @lcProcessInfo)=1
		lnProcessHandle=(((ASC(SUBSTR(m.lcProcessInfo, 4, 1))*256)+;
			ASC(SUBSTR(m.lcProcessInfo, 3, 1)))*256+;
			ASC(SUBSTR(m.lcProcessInfo, 2, 1)))*256+;
			ASC(LEFT(m.lcProcessInfo, 1))
		* БЕСКОНЕЧНОЕ ОЖИДАНИЕ ОКОНЧАНИЯ РАБОТЫ ПРОЦЕССА
		WaitForInputIdle(GetCurrentProcess(), INFINITE)
		lnReturnValue=1				&& Успешное завершение
		* ПРОВЕРЯЕМ НАЖАТИЕ ESC КАЖДЫЕ ПОЛСЕКУНДЫ
		DO WHILE WaitForSingleObject(m.lnProcessHandle, TIME_ONE_SECOND/2)=WAIT_TIMEOUT
			IF INKEY()=KEY_ESC
				* ПРЕКРАТИТЬ ВЫПОЛНЕНИЕ ПРОГРАММЫ ?
				IF MESSAGEBOX(MSG_PROGRAMTERMINATE, 4+32+256, ThisForm.Caption)=6
					* ПРЕКРАТИМ ВЫПОЛНЕНИЕ С PROCESSEXITCODE = 0
					TerminateProcess(m.lnProcessHandle, 0)
					CloseHandle(m.lnProcessHandle)
					lnReturnValue=-1	&& Оператор нажал Escape
					EXIT
				ENDIF
			ENDIF
		ENDDO
	ENDIF									
RETURN m.lnReturnValue

*!* * * * * * * * * * * * * * * * * * * * * * * *
*!*	СМ. http://support.microsoft.com/kb/q191584/*
*!* * * * * * * * * * * * * * * * * * * * * * * *
*!*	HOW TO DETERMINE WHEN A 32-BIT PROCESS HAS COMPLETED
*!*	Executing the RUN/! command in a Visual FoxPro program starts another executable
*!*	program asynchronously and returns control to the Visual FoxPro application. This
*!*	shelled program continues to run independently of the parent Visual FoxPro
*!*	application until the user closes it. However, if your Visual FoxPro application
*!*	needs to wait for the child process to terminate, you can use the Win32
*!*	CreateProcess and WaitForSingleObject API functions. CreateProcess starts
*!*	the child process and populates a PROCESS_INFORMATION structure with its process
*!*	handle. WaitForSingleObject accepts this process handle as an argument, and puts
*!*	the processor in an extremely efficient wait state until the child process
*!*	terminates. 

*!*	#DEFINE NORMAL_PRIORITY_CLASS 32
*!*	#DEFINE IDLE_PRIORITY_CLASS 64
*!*	#DEFINE HIGH_PRIORITY_CLASS 128
*!*	#DEFINE REALTIME_PRIORITY_CLASS 1600

*!*	* Return code from WaitForSingleObject() if
*!*	* it timed out.
*!*	#DEFINE WAIT_TIMEOUT 0x00000102

*!*	* This controls how long, in milli secconds, WaitForSingleObject()
*!*	* waits before it times out. Change this to suit your preferences.
*!*	#DEFINE WAIT_INTERVAL 200

*!*	DECLARE INTEGER CreateProcess IN kernel32.DLL ;
*!*	   INTEGER lpApplicationName, ;
*!*	   STRING lpCommandLine, ;
*!*	   INTEGER lpProcessAttributes, ;
*!*	   INTEGER lpThreadAttributes, ;
*!*	   INTEGER bInheritHandles, ;
*!*	   INTEGER dwCreationFlags, ;
*!*	   INTEGER lpEnvironment, ;
*!*	   INTEGER lpCurrentDirectory, ;
*!*	   STRING @lpStartupInfo, ;
*!*	   STRING @lpProcessInformation

*!*	DECLARE INTEGER WaitForSingleObject IN kernel32.DLL ;
*!*	   INTEGER hHandle, INTEGER dwMilliseconds

*!*	DECLARE INTEGER CloseHandle IN kernel32.DLL ;
*!*	   INTEGER hObject

*!*	DECLARE INTEGER GetLastError IN kernel32.DLL

*!*	* STARTUPINFO is 68 bytes, of which we need to
*!*	* initially populate the 'cb' or Count of Bytes member
*!*	* with the overall length of the structure.
*!*	* The remainder should be 0-filled
*!*	start = long2str(68) + REPLICATE(CHR(0), 64)

*!*	* PROCESS_INFORMATION structure is 4 longs,
*!*	* or 4*4 bytes = 16 bytes, which we'll fill with nulls.
*!*	process_info = REPLICATE(CHR(0), 16)

*!*	* Start a copy of NOTEPAD (EXE name must be null-terminated)
*!*	File2Run = "C:\WINNT\NOTEPAD.EXE" + CHR(0)

*!*	* Call CreateProcess, obtain a process handle. Treat the
*!*	* application to run as the 'command line' argument, accept
*!*	* all other defaults. Important to pass the start and
*!*	* process_info by reference.
*!*	RetCode = CreateProcess(0, File2Run, 0, 0, 1, ;
*!*	   NORMAL_PRIORITY_CLASS, 0, 0, @start, @process_info)

*!*	* Unable to run, exit now.
*!*	IF RetCode = 0
*!*	   =MESSAGEBOX("Error occurred. Error code: ", GetLastError())
*!*	   RETURN
*!*	ENDIF

*!*	* Extract the process handle from the
*!*	* PROCESS_INFORMATION structure.
*!*	hProcess = str2long(SUBSTR(process_info, 1, 4))

*!*	DO WHILE .T.
*!*	* Use timeout of TIMEOUT_INTERVAL msec so the display
*!*	* will be updated. Otherwise, the VFP window never repaints until
*!*	* the loop is exited.
*!*	IF WaitForSingleObject(hProcess, WAIT_INTERVAL) != WAIT_TIMEOUT
*!*	     EXIT
*!*	   ELSE
*!*	      DOEVENTS
*!*	   ENDIF
*!*	ENDDO

*!*	* Show a message box when we're done.
*!*	=MESSAGEBOX ("Process completed")

*!*	* Close the process handle afterwards.
*!*	RetCode = CloseHandle(hProcess)
*!*	RETURN


*!*	********************
*!*	FUNCTION long2str
*!*	********************
*!*	* Passed : 32-bit non-negative numeric value (m.longval)
*!*	* Returns : ASCII character representation of passed
*!*	*           value in low-high format (m.retstr)
*!*	* Example :
*!*	*    m.long = 999999
*!*	*    m.longstr = long2str(m.long)

*!*	PARAMETERS m.longval

*!*	PRIVATE i, m.retstr

*!*	m.retstr = ""
*!*	FOR i = 24 TO 0 STEP -8
*!*	   m.retstr = CHR(INT(m.longval/(2^i))) + m.retstr
*!*	   m.longval = MOD(m.longval, (2^i))
*!*	NEXT
*!*	RETURN m.retstr


*!*	*******************
*!*	FUNCTION str2long
*!*	*******************
*!*	* Passed:  4-byte character string (m.longstr)
*!*	*   in low-high ASCII format
*!*	* returns:  long integer value
*!*	* example:
*!*	*   m.longstr = "1111"
*!*	*   m.longval = str2long(m.longstr)

*!*	PARAMETERS m.longstr

*!*	PRIVATE i, m.retval

*!*	m.retval = 0
*!*	FOR i = 0 TO 24 STEP 8
*!*	   m.retval = m.retval + (ASC(m.longstr) * (2^i))
*!*	   m.longstr = RIGHT(m.longstr, LEN(m.longstr) - 1)
*!*	NEXT
*!*	RETURN m.retval

ENDPROC
PROCEDURE selectobject
* SELECTS AN OBJECT INTO A SPECIFIED DEVICE CONTEXT
LPARAMETERS tnDC, tnObject
	IF !THIS.isLoaded("SelectObject")
		DECLARE LONG SelectObject IN Win32API LONG, LONG
	ENDIF
	*
	SelectObject(m.tnDC, m.tnObject)
ENDPROC
PROCEDURE sendmessage
* SENDS THE SPECIFIED MESSAGE TO A WINDOW OR WINDOWS
* This.SendMessage(ThisForm.hWnd, WM_SYSCOMMAND, SC_MOVE + HTCAPTION, 0)
* This.SendMessage(ThisForm.hWnd, WM_SETICON, ICON_SMALL, 0)
* This.SendMessage(ThisForm.hWnd, WM_CLOSE, 0, 0)
* P.S. VFP КОНТРОЛЫ - РИСОВАННЫЕ БИТМАПЫ, А НЕ ОКНА, НО НЕ ВСЕГДА
* НАПРИМЕР COMBOBOX - РИСУНОК, А ЕГО ВЫПАДАЮЩИЙ СПИСОК - ОКНО !
* (ИНАЧЕ СПИСОК НЕВОЗМОЖНО БЫЛО БЫ ПОКАЗАТЬ ЗА ПРЕДЕЛАМИ ФОРМЫ)
LPARAMETERS tnHwnd, tnMessage, tnParameter1, tnParameter2
LOCAL lnResult AS Long
	tnParameter1=IIF(VARTYPE(m.tnParameter1)='N', m.tnParameter1, 0)
	tnParameter2=IIF(VARTYPE(m.tnParameter2)='N', m.tnParameter2, 0)
	*
	IF !THIS.isLoaded("SendMessage")
		DECLARE LONG SendMessage IN WIN32API LONG, LONG, LONG, LONG
	ENDIF
	*
	lnResult=SendMessage(m.tnHWnd, m.tnMessage, m.tnParameter1, m.tnParameter2)
RETURN m.lnResult
ENDPROC
PROCEDURE setattributes
* СМЕНА АТРИБУТОВ ФАЙЛА ИЛИ КАТАЛОГА
LPARAMETERS tcPathFileOrFolder AS String, tnAttribute AS Integer
LOCAL lnSuccess AS Integer
	lnSuccess=0
	*
	IF FILE(m.tcPathFileOrFolder, 1) OR DIRECTORY(m.tcPathFileOrFolder, 1)
		tnAttribute=IIF(VARTYPE(m.tnAttribute)<>'N', FILE_ATTRIBUTE_NORMAL, m.tnAttribute)
		*
		IF !THIS.isLoaded("SetFileAttributes")
			DECLARE INTEGER SetFileAttributes IN WIN32API STRING, INTEGER
		ENDIF
		*
		lnSuccess=SetFileAttributes(m.tcPathFileOrFolder, m.tnAttribute)
	ENDIF
RETURN m.lnSuccess<>0

ENDPROC
PROCEDURE setclasslong
* REPLACES THE SPECIFIED 32-BIT (LONG) VALUE AT THE SPECIFIED OFFSET INTO THE EXTRA CLASS MEMORY OR THE WNDCLASSEX STRUCTURE FOR THE CLASS TO WHICH THE SPECIFIED WINDOW BELONGS
* НАПРИМЕР ЗАНУЛИМ УКАЗАТЕЛЬ ИКОНКИ АССОЦИИРОВАННОЙ, С КЛАССОМ ОКНА :
* This.SetClassLong(ThisForm.hWnd, GCL_HICON, 0)
LPARAMETERS tnHWnd AS Integer, tnIndex AS Integer, tnValue AS Integer
	IF !THIS.isLoaded("SetClassLong")
		DECLARE INTEGER SetClassLong IN WIN32API INTEGER, INTEGER, INTEGER
	ENDIF
	*
	SetClassLong(m.tnHWnd, m.tnIndex, m.tnValue)

ENDPROC
PROCEDURE setdatetime
* УСТАНОВКА СИСТЕМНОЙ ДАТЫ И ВРЕМЕНИ (UTC?)
* This.SetDateTime(TIME())
* СМ. MSDN : Q188897
LPARAMETERS ttNewDateTime AS Datetime
LOCAL lcSystemTime AS String
	* LPSYSTEMTIME - СТРОКА СТРУКТУРЫ WINAPI : 8 Х 2 = 16
	IF !THIS.isLoaded("SetLocalTime")
		DECLARE SetLocalTime IN WIN32API STRING @
	ENDIF
	* ЗАНУЛЯЕМ НОМЕР ДНЯ НЕДЕЛИ И МИЛЛИСЕКУНДЫ
	lcSystemTime=BINTOC(YEAR(m.ttNewDateTime), '2RS')+;
		BINTOC(MONTH(m.ttNewDateTime), '2RS')+REPLICATE(CHR(0), 2)+;
		BINTOC(DAY(m.ttNewDateTime), '2RS')+BINTOC(HOUR(m.ttNewDateTime), '2RS')+;
		BINTOC(MINUTE(m.ttNewDateTime), '2RS')+BINTOC(SEC(m.ttNewDateTime), '2RS')+;
		REPLICATE(CHR(0), 2)
	SetLocalTime(@lcSystemTime)
	* ОПОВЕСТИМ ВСЕХ О СМЕНЕ СИСТЕМНОГО ВРЕМЕНИ
	This.SendMessage(HWND_BROADCAST, WM_TIMECHANGE)


ENDPROC
PROCEDURE setfiletime
* УСТАНОВКА ДАТЫ И ВРЕМЕНИ СОЗДАНИЯ, МОДИФИКАЦИИ И ДОСТУПА К ФАЙЛУ
* ОСОБЕННОСТИ ПОВЕДЕНИЯ FAT И NTFS :
* Windows NT FAT, create time has a resolution of 10 milliseconds,
* write time has a resolution of 2 seconds, and access time has a
* resolution of 1 day (really, the access date).
* On NTFS, access time has a resolution of 1 hour.
* Therefore, the GetFileTime function may not return the same file time
* information set using SetFileTime. Furthermore, FAT records times
* on disk in local time. However, NTFS records times on disk in UTC. 
* NTFS records file times natively in FILETIME format,
* so they are not affected by changes in time zone or daylight saving time
LPARAMETERS tcFileName AS String, ttCreate AS Datetime,;
	ttAccess AS Datetime, ttModify AS Datetime
LOCAL lnHandle AS Integer
	lnHandle=This.Openfile(m.tcFileName)
	*
	WITH This.Parent.oFunction
		lcCreate=.TimeToString(m.ttCreate)
		lcAccess=.TimeToString(m.ttAccess)
		lcModify=.TimeToString(m.ttModify)
	ENDWITH
	*
	IF m.lnHandle>0
		IF !THIS.isLoaded("SetFileTime")
			DECLARE INTEGER SetFileTime IN WIN32API INTEGER, STRING @, STRING @, STRING @  
		ENDIF
		*
		SetFileTime(m.lnHandle, m.lcCreate, m.lcAccess, m.lcModify)
		This.CloseHandle(m.lnHandle)
	ENDIF
ENDPROC
PROCEDURE setwindowlong
* CHANGES AN ATTRIBUTE OF THE SPECIFIED WINDOW
* НАПРИМЕР УСТАНОВИМ ОТСУТСТВУЮЩИЙ В VFP ДИАЛОГОВЫЙ СТИЛЬ ОКНА (BorderStyle # 0,1,2,3!)
* This.SetWindowLong(ThisForm.hWnd, GWL_EXSTYLE, WS_EX_DLGMODALFRAME)
LPARAMETERS tnHWnd AS Integer, tnIndex AS Integer, tnValue AS Integer
	IF !THIS.isLoaded("SetWindowLong")
		DECLARE INTEGER SetWindowLong IN WIN32API INTEGER, INTEGER, INTEGER
	ENDIF
	*
	SetWindowLong(m.tnHWnd, m.tnIndex, m.tnValue)
ENDPROC
PROCEDURE setwindowrgn
* THE SETWINDOWRGN FUNCTION SETS THE WINDOW REGION OF A WINDOW.
* THE WINDOW REGION DETERMINES THE AREA WITHIN THE WINDOW WHERE THE SYSTEM PERMITS DRAWING.
* THE SYSTEM DOES NOT DISPLAY ANY PORTION OF A WINDOW THAT LIES OUTSIDE OF THE WINDOW REGION.
LPARAMETERS tnWindowHandle AS Integer, tnRegionHandle AS Integer
LOCAL llSuccess AS Logical
	IF !THIS.isLoaded("SetWindowRgn")
		DECLARE INTEGER SetWindowRgn IN WIN32API INTEGER, INTEGER, INTEGER
	ENDIF
	*
	llSuccess=SetWindowRgn(m.tnWindowHandle, m.tnRegionHandle, 1)<>0
	*
	IF !m.llSuccess
		THIS.DeleteObject(m.tnRegionHandle)
	ENDIF
RETURN m.llSuccess
ENDPROC
PROCEDURE shellexecute
* ШЭЛ-РЕАКЦИЯ НА РАСШИРЕНИЕ ФАЙЛА И ДРУГИЕ БОГАТЫЕ ВОЗМОЖНОСТИ!
* IF EMPTY(This.ShellExecute('readme.txt', FULLPATH(''), 'Print', 0))	- распечатать файл
* IF EMPTY(This.ShellExecute('notepad.exe',,,'c:\autoexec.bat')			- открыть notepad и с загруженным для просмотра autoexec.bat
LPARAMETERS tcFilename AS String, tcWorkDir AS String, tcOperation AS String, tcParameters AS String, tnWindowState AS Integer
LOCAL lcFileName As String, lcWorkDir AS String, lcOperation AS String,;
	lcParameters AS String, lnWindowState AS Integer, lnError AS Integer
	lcFileName = ALLTRIM(m.tcFileName)
	lcWorkDir = IIF(VARTYPE(m.tcWorkDir) = 'C', ALLTRIM(m.tcWorkDir), '')
	lcOperation = IIF(VARTYPE(m.tcOperation) = 'C' AND !EMPTY(m.tcOperation), ALLTRIM(m.tcOperation), 'open')
	lcParameters = IIF(VARTYPE(m.tcParameters) = 'C', ALLTRIM(m.tcParameters), '')
	lnWindowState = IIF(VARTYPE(m.tnWindowState) = 'N', m.tnWindowState, SW_SHOWNORMAL)

	IF !THIS.isLoaded("ShellExecute")
		DECLARE INTEGER ShellExecute IN SHELL32.DLL INTEGER, STRING, STRING, STRING, STRING, INTEGER
	ENDIF

	lnError = ShellExecute(0, m.lcOperation, m.lcFilename, m.lcParameters, m.lcWorkDir, m.lnWindowState)
RETURN This.LocalErrorMessage('ShellExecute', m.lnError) && 0-32

#IF .F.

	tcOperation :
	'edit'		- Launches an editor and opens the document for editing. If lpFile is not a document file, the function will fail. 
	'explore'	- Explores the folder specified by lpFile.  
	'find'		- Initiates a search starting from the specified directory. 
	'open'		- Opens the file specified by the lpFile parameter. The file can be an executable file, a document file, or a folder. 
	'print'		- Prints the document file specified by lpFile. If lpFile is not a document file, the function will fail. 

	OPENS DATA FILES WITH THEIR ASSOCIATED APPLICATIONS
	ShellExecute (0,	'open',	'c:\mybase.mdb','',	'',	SW_SHOWMAXIMIZED) 

	ACCESSING A SITE ON THE INTERNET
	ShellExecute (0, 'open', 'http://www.mysite.com/','', '',SW_SHOWMAXIMIZED) 

	OPENS A FOLDER BY IE ;)
	ShellExecute (0, 'explore','c:\util','','',SW_SHOWMAXIMIZED) 

	OPEN SEARCH FILE WINDOW STARTING FROM THE SPECIFIED DIRECTORY
	ShellExecute (0, 'find','','','C:\',SW_SHOWMAXIMIZED) 

	PRINTS THE TEXT FILE USING THE ASSOCIATED APPLICATION (ПЕЧАТЬ ФАЙЛА ПОСРЕДСТВОМ NOTEPAD)
	ShellExecute (0, 'print','c:\myfile.txt','','',SW_SHOWMAXIMIZED) 

#ENDIF
ENDPROC
PROCEDURE showcursor
* СКРЫТЬ / ПОКАЗАТЬ МЫШИНЫЙ КУРСОР
* P.S. VFP8 VERY OFTEN RESTORES HIDDEN MOUSE CURSOR AUTOMATICALLY. SO THIS FUNCTION MAY NOT BE USEFUL.
* MOUSEPOINTER PROPERTY, APPLICABLE TO MANY VFP CONTROLS, HIDES THE POINTER WHEN SET TO 13
LPARAMETERS tlShow AS Logical
	IF !THIS.isLoaded("ShowCursor")
		DECLARE INTEGER ShowCursor IN Win32API INTEGER
	ENDIF
	*
	ShowCursor(IIF(m.tlShow, 1, 0))
ENDPROC
PROCEDURE shutdownwindows
* ВЫЗОВ ДИАЛОГА ЗАВЕРШЕНИЯ РАБОТЫ WINDOWS
LOCAL lnHandle AS Integer
	lnHandle=This.FindWindow('Program Manager')
	This.SendMessage(m.lnHandle, WM_ENDSESSION, 0, 0)

*!*	* HOWTO Exit Windows from Visual FoxPro ?
*!*	* =======================================
*!*	* Program....:  EXITWINDOWS.PRG  
*!*	* Version....:  1.0  
*!*	* Author.....:  Dipl. Kfm. Frank Dietrich  
*!*	* Date.......:  21.Oktober 2001  
*!*	* Notice.....:  Copyright (c) 2001  
*!*	*               Frank Dietrich Datentechnik  
*!*	*               Leo-Baeck-Str. 22  
*!*	*               14165 Berlin  
*!*	*               PHONE : +49-30-845 777-0  
*!*	*               FAX   : +49-30-845 777-19  
*!*	*         CIS   : 100322,333  
*!*	*    e-mail: frank.dietrich@dd-tech.de, All Rights Reserved.  
*!*	* Compiler...:  Visual FoxPro 07.00.0000.9297 fьr Windows  
*!*	* Abstract...:  Prozedurendatei mit einer Prozedur, um Windows  
*!*	*    in unterschiedlichen Modi herunterzufahren und  
*!*	*    ggf. auch den Rechner auszuschalten  
*!*	*    Funktioniert auf allen Win OS  
*!*	*    Source stammt aus  
*!*	*-- Define from Winnt.h  
*!*	#DEFINE TOKEN_ADJUST_PRIVILEGES   0x0020  
*!*	#DEFINE TOKEN_QUERY               0x0008  
*!*	#DEFINE SE_PRIVILEGE_ENABLED      2  

*!*	*-- Defines from Winbase.h  
*!*	#DEFINE VER_PLATFORM_WIN32s             0  
*!*	#DEFINE VER_PLATFORM_WIN32_WINDOWS      1  
*!*	#DEFINE VER_PLATFORM_WIN32_NT           2  
*!*	    
*!*	*-- Defines from WinUser.h  
*!*	#DEFINE EWX_LOGOFF           0  && Shuts down all processes running  
*!*	                                && in the security  
*!*	                                && context of the process that  
*!*	                                && called the ExitWindowsEx function.  
*!*	                                && Then it logs the user off.  
*!*	    
*!*	#DEFINE EWX_SHUTDOWN         1  && Shuts down the system to a point  
*!*	                                && at which it is safe to turn off the  
*!*	                                && power. All file buffers have been  
*!*	                                && flushed to disk, and all  
*!*	                                && running processes have stopped.  

*!*	                                && Windows NT/2000: The calling process  
*!*	                                && must have the SE_SHUTDOWN_NAME  
*!*	                                && privilege.  
*!*	    
*!*	#DEFINE EWX_REBOOT           2  && Shuts down the system and then  
*!*	                                && restarts the system.  
*!*	    
*!*	                                && Windows NT/2000: The calling process  
*!*	                                && must have the SE_SHUTDOWN_NAME  
*!*	                                && privilege.  
*!*	    
*!*	#DEFINE EWX_POWEROFF         8  && Shuts down the system and turns  
*!*	                                && off the power. The system must support  
*!*	                                && the power-off feature.  

*!*	                                && Windows NT/2000: The calling process  
*!*	                                && must have the SE_SHUTDOWN_NAME  
*!*	                                && privilege.  

*!*	*-- Change EWX_SHUTDOWN to any of the above #define values to  
*!*	*-- either logoff, shutdown, reboot, or power off.  
*!*	* DO ExitWindowsFox WITH EWX_SHUTDOWN  
*!*	PROCEDURE ExitWindows
*!*	PARAMETERS ExitMode
*!*	LOCAL iRc
*!*	iRc = 0
*!*	DECLARE ExitWindowsEx IN Win32Api INTEGER, INTEGER
*!*	*-- Check the OS version, and call the SetPrivilege function if NT/Win2K
*!*	liPlatform = GetPlatform()
*!*	IF liPlatform != VER_PLATFORM_WIN32_NT	&& We can do whatever we wish  
*!*											&& without worrying about security  
*!*		iRc = ExitWindowsEx(ExitMode, 0)
*!*		IF ExitMode = EWX_LOGOFF OR ExitMode = EWX_POWEROFF
*!*			*-- Necessary because VFP will not exit using  
*!*			*-- either of these parameters under Win9x.  
*!*			QUIT
*!*		ENDIF  
*!*	ELSE									&& We have to set the process security  
*!*		iRc = SetProcPrivilege()  
*!*		IF iRc <> 0  
*!*			iRc = ExitWindowsEx(ExitMode, 0)  
*!*		ENDIF
*!*	ENDIF									&& liPlatform != VER_PLATFORM_WIN32_NT  

*!*	PROCEDURE SetProcPrivilege  
*!*	*-- Sets the appropriate process privilege to allow shutdown on NT/Win2K  
*!*	*-- Declare function to obtain current Process ID, needed to open the process  
*!*	*-- get the process token.  
*!*	LOCAL iRc  
*!*	iRc = 0  
*!*	DECLARE INTEGER GetCurrentProcessId IN kernel32.DLL  
*!*	DECLARE INTEGER OpenProcess IN Kernel32.DLL INTEGER, INTEGER, INTEGER  
*!*	DECLARE INTEGER OpenProcessToken IN AdvApi32.DLL INTEGER, INTEGER, INTEGER @
*!*	 
*!*	*-- Declare function to retrieve a LUID for the necessary security  
*!*	*-- privilege.  
*!*	DECLARE INTEGER LookupPrivilegeValue IN AdvApi32.DLL STRING, STRING, INTEGER @
*!*	 
*!*	*-- Declare function to adjust the process token privileges so that  
*!*	*-- we can shut down NT/Windows 2000  
*!*	DECLARE INTEGER AdjustTokenPrivileges IN AdvApi32.DLL INTEGER, ;  
*!*	INTEGER, STRING @, INTEGER, INTEGER, INTEGER  

*!*	liAccessToken = 0        && Placeholder for the access token whose privileges we'll change  
*!*	lsLuidBuffer = SPACE(8)  && Placeholder for LUID used to change access privileges  
*!*	lsName = SPACE(15)       && Placeholder for computer name  
*!*	liBufferLen = 15         && Placeholder for the computer name buffer length  
*!*	liLuid = 0  
*!*	liProc = 0  
*!*	liProc = GetCurrentProcessId()  
*!*	hProc = OpenProcess(2035711, 0, liProc)  
*!*	iRc = OpenProcessToken(hProc, BITOR(TOKEN_ADJUST_PRIVILEGES, TOKEN_QUERY), @liAccessToken)  
*!*	IF iRc <> 0  
*!*		IF iRc <> 0  
*!*			*-- "SeShutdownPrivilege" is the string value for the SE_SHUTDOWN_NAME value.  
*!*			LookupPrivilegeValue("", "SeShutdownPrivilege", @liLuid)  
*!*			lsLuidBuffer = LongToStr(liLuid) + CHR(0) + CHR(0) + CHR(0) + CHR(0)  
*!*			*-- Declare a string to hold the TOKEN_PRIVILEGES structure  
*!*			lsNewState = SPACE(16)
*!*			*-- Fill in the structure  
*!*			lsNewState = LongToStr(1) + lsLuidBuffer + LongToStr(SE_PRIVILEGE_ENABLED)
*!*			iRc = AdjustTokenPrivileges(liAccessToken, 0, @lsNewState, LEN(lsNewState), 0, 0)
*!*			RETURN iRc  
*!*		ELSE  
*!*			RETURN iRc  
*!*		ENDIF
*!*	ELSE  
*!*		RETURN iRc  
*!*	ENDIF  
*!*	ENDPROC  

*!*	PROCEDURE GetPlatform  
*!*	LOCAL liPlatform, iRc  
*!*	liPlatform = 0  
*!*	iRc = 0  
*!*	DECLARE INTEGER GetVersionEx IN Win32Api STRING @
*!*	*-- Declare a string to hold the OSVERSIONINFO structure  
*!*	lsOSVersionInfo = LongToStr(148) + SPACE(144)
*!*	iRc = GetVersionEx(@lsOSVersionInfo)
*!*	liPlatform = StrToLong(SUBSTR(lsOSVersionInfo, 17, 4))
*!*	RETURN liPlatform
*!*	ENDPROC  
*!*	 
*!*	*-- The following function converts a long integer to an ASCII  
*!*	*-- character representation of the passed value in low-high format.  
*!*	FUNCTION LongToStr
*!*	* Passed : 32-bit non-negative numeric value (lnLongval)  
*!*	* Returns : ascii character representation of passed value in low-high  
*!*	* format (lcRetstr)  
*!*	* Example :  
*!*	* m.long   = 999999  
*!*	* m.longstr  = long2str(m.long)  
*!*	PARAMETERS lnLongval  
*!*	PRIVATE i, lcRetstr  
*!*	lcRetstr = ""  
*!*	FOR i = 24 TO 0 STEP -8  
*!*		lcRetstr = CHR(INT(lnLongval/(2^i))) + lcRetstr  
*!*		lnLongval = MOD(lnLongval, (2^i))  
*!*	NEXT
*!*	RETURN lcRetstr
*!*	 
*!*	*-- The following function converts a string in low-high format to a long integer.  
*!*	FUNCTION StrToLong  
*!*	* Passed:  4-byte character string (lcLongstr) in low-high ASCII format  
*!*	* Returns:  long integer value  
*!*	* Example:  
*!*	* m.longstr = "1111"  
*!*	* m.longval = str2long(m.longstr)  
*!*	PARAMETERS lcLongstr  
*!*	PRIVATE i, lnRetval  
*!*	lnRetval = 0  
*!*	FOR i = 0 TO 24 STEP 8  
*!*		lnRetval = lnRetval + (ASC(lcLongstr) * (2^i))  
*!*		lcLongstr = RIGHT(lcLongstr, LEN(lcLongstr) - 1)  
*!*	NEXT  
*!*	RETURN lnRetval

ENDPROC
PROCEDURE sleep
* АГРУМЕНТ - ПЕРИОД ОЖИДАНИЯ В МИЛЛИСЕКУНДАХ
LPARAMETERS tnTime AS Integer
	IF !THIS.isLoaded("Sleep")
		DECLARE Sleep IN WIN32API INTEGER
	ENDIF

	Sleep(m.tnTime)
ENDPROC
PROCEDURE terminateprocess
* УБИВАЕМ ПРОЦЕСС ПО ХЭНДЛУ ОКНА
* РЕЗУЛЬТАТ : УСПЕХ КАРАТЕЛЬНОЙ ОПЕРАЦИИ
* This.TerminateProcess(GetActiveWindow())
LPARAMETERS tnWindowHandle
LOCAL lnReturn AS Integer, lnProcessId AS Integer
	IF !THIS.isLoaded("GetWindowThreadProcessId")
		DECLARE INTEGER GetWindowThreadProcessId IN WIN32API INTEGER, INTEGER
	ENDIF

	IF !THIS.isLoaded("OpenProcess")
		DECLARE INTEGER OpenProcess IN WIN32API INTEGER, INTEGER,INTEGER
	ENDIF

	IF !THIS.isLoaded("TerminateProcess")
		DECLARE INTEGER TerminateProcess IN WIN32API INTEGER, INTEGER
	ENDIF

	IF !THIS.isLoaded("CloseHandle")
		DECLARE INTEGER CloseHandle	IN WIN32API INTEGER
	ENDIF

	lnReturn = 0
	lnProcessId = 0
	* ПОЛУЧИМ ID ПРОЦЕССА ПО ХЭНДЛУ ОКНА
	GetWindowThreadProcessId(m.tnWindowHandle, @lnProcessId)
	lnProcessHandle = OpenProcess(0xF1, .F., m.lnProcessId)

	IF !EMPTY(m.lnProcessHandle)
		lnReturn = TerminateProcess(m.lnProcessHandle, 0)
		CloseHandle(m.lnProcessHandle)
	ENDIF
RETURN m.lnReturn <> 0

*!*	#DEFINE PROCESS_TERMINATE			0x0001
*!*	#DEFINE PROCESS_CREATE_THREAD		0x0002
*!*	#DEFINE PROCESS_SET_SESSIONID		0x0004
*!*	#DEFINE PROCESS_VM_OPERATION		0x0008
*!*	#DEFINE PROCESS_VM_READ				0x0010
*!*	#DEFINE PROCESS_VM_WRITE			0x0020
*!*	#DEFINE PROCESS_DUP_HANDLE			0x0040
*!*	#DEFINE PROCESS_CREATE_PROCESS		0x0080
*!*	#DEFINE PROCESS_SET_QUOTA			0x0100
*!*	#DEFINE PROCESS_SET_INFORMATION		0x0200
*!*	#DEFINE PROCESS_QUERY_INFORMATION	0x0400
*!*	#DEFINE PROCESS_ALL_ACCESS			0xFFF	&& STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE

ENDPROC
PROCEDURE urldownloadtofile
* МОЛЧА ГРУЗИМ ФАЙЛ С HTTP-СЕРВЕРА И СОХРАНЯЕМ ЕГО В ЛОКАЛЬНОМ КАТАЛОГЕ
* РЕЗУЛЬТАТ - УСПЕХ ОПЕРАЦИИ
* This.URLDownloadToFile('http://www.urfin.narod.ru/index.html','c:\util\index.html')
* This.URLDownloadToFile('http://www.cbr.ru/scripts/XML_daily.asp?date_req=02/03/2002', ADDBS(SYS(2023)) + 'course.xml')
LPARAMETERS tcSourceFile AS String, tcTargetFile AS String
	IF !FILE(m.tcTargetFile)
		IF !THIS.isLoaded("URLDownloadToFile")
			DECLARE INTEGER URLDownloadToFile IN URLMON.DLL;
				LONG, STRING, STRING, LONG, LONG
		ENDIF
		*
		URLDownloadToFile(0, m.tcSourceFile, m.tcTargetFile, 0, 0)
		RETURN FILE(m.tcTargetFile)
	ENDIF
RETURN .F.

ENDPROC
PROCEDURE windowfrompoint
* ПОЛУЧИТЬ ХЭНДЛ ОКНА, В КООРДИНАТАХ TLLEFT, TLTOP
* P.S. КООРДИНАТЫ ОТНОСИТЕЛЬНО ДЭСКТОПА!
LPARAMETERS tnLeft AS Integer, tnTop AS Integer
LOCAL lnHWnd AS Integer
	IF !THIS.isLoaded("WindowFromPoint")
		DECLARE LONG WindowFromPoint IN WIN32API LONG, LONG
	ENDIF
	*
	lnHWnd=WindowFromPoint(m.tnLeft, m.tnTop)
RETURN m.lnHWnd 
ENDPROC
PROCEDURE winexec
* ЗАПУСТИТЬ ПРИЛОЖЕНИЕ WINDOWS И ПРОДОЛЖИТЬ РАБОТУ БЕЗ ОЖИДАНИЯ РЕЗУЛЬТАТА
* WinExec('notepad c:/newfile.txt', SW_SHOWMAXIMIZED)
* tnWindowState	- Режим окна процесса (см. WinApi.h)
LPARAMETERS tcCommandLine AS String, tnWindowState AS Integer
LOCAL lnError AS Integer
	IF !THIS.isLoaded("WinExec")
		DECLARE INTEGER WinExec IN WIN32API STRING, INTEGER
	ENDIF

	tnWindowState = IIF(VARTYPE(m.tnWindowState) = 'N', m.tnWindowState, SW_SHOWNORMAL)
	lnError = WinExec(m.tcCommandLine, m.tnWindowState)
RETURN This.LocalErrorMessage("WinExec", m.lnError) && 0-31
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*activatewindow 
*beep 
*bitblt 
*blockinput 
*cddoor 
*checkinstance 
*clienttoscreen 
*closehandle 
*colorbitsperpixel 
*colorcombination 
*copyfile 
*createcompatiblebitmap 
*createcompatibledc 
*createdirectory 
*createellipticrgn 
*createmutex 
*createrectrgn 
*createsemaphore 
*deletedc 
*deletefile 
*deleteobject 
*dllregisterserver 
*dllunregisterserver 
*drawicon 
*drawiconresource 
*exitprocess 
*exitwindowsex 
*fatalappexit 
*findwindow 
*flashwindow 
*freelibrary 
*gdicreatebitmap 
*gdicreatepatternbrush 
*gdicreatepen 
*gdigetstockobject 
*gdipatblt 
*gdipdisposeimage 
*gdipgetimageheight 
*gdipgetimagerawformat 
*gdipgetimagewidth 
*gdiploadimagefromfile 
*gdiplusshutdown 
*gdiplusstartup 
*gdirectangle 
*gdisetrop2 
*getapppath 
*getclientrect 
*getcpuspeed 
*getcursorpos 
*getdatetime 
*getdc 
*getdevicecaps 
*getfocus 
*getfolderpath 
*getguid Уникальная строка вида : {96C1E335-B6C2-41C7-9602-295CD99988E3}
*getipaddress 
*getipentries 
*getkeyboardlayoutname 
*getlastactivepopup 
*getlasterror 
*getlogicaldrive 
*getmessagepos 
*getprocaddress 
*getshortfilename 
*getsyscolor 
*getsystemdirectory 
*getsystemmetrics 
*gettempfilename 
*gettemppath 
*gettickcount 
*gettimezoneinformation 
*getuserdefaultlcid Определить локаль пользователя
*getvolumeinformation 
*getwindow 
*getwindowlong 
*getwindowrect 
*getwindowsdirectory 
*globalmemorystatus 
*hideprocess 
*internetgetconnectedstate 
*ischild 
*isloaded Проверка загрузки dll
*loadicon 
*loadimage Загружает файл иконки как ресурс WINDOWS
*loadkeyboardlayout 
*loadlibrary 
*loadlibraryex 
*localerrormessage Occurs when the Valid event returns false (.F.), and provides a means to display an error message.
*mcisendstring 
*messagebeep 
*netmessagebuffersend 
*openfile 
*opensemaphore 
*regclosekey 
*regcreatekey 
*regdeletekey 
*regdeletevalue 
*reggetkey 
*regopenkey 
*regsetkey 
*regsvr32 
*releasecapture 
*releasedc 
*releasemutex 
*removedirectory 
*removeicon 
*runprocess 
*selectobject 
*sendmessage 
*setattributes 
*setclasslong 
*setdatetime 
*setfiletime 
*setwindowlong 
*setwindowrgn 
*shellexecute 
*showcursor 
*shutdownwindows 
*sleep 
*terminateprocess 
*urldownloadtofile 
*windowfrompoint 
*winexec 
_memberdata XML Metadata for customizable properties
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\cstwinapi.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\cstwinapi.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Системные функции[END RESERVED7]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] cstwinapi

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM01C8TQ
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] editbar
[START PROPERTIES]
Enabled = .F.
Height = 44
Left = 0
Name = "editbar"
Top = 0
Width = 290
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
10[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM024ZGC
[CLASS] base_separator
[CLASSLOC] base_gui.vcx
[BASECLASS] separator
[OBJNAME] Base_separator1
[PARENT] editbar
[START PROPERTIES]
Height = 0
Left = 88
Name = "Base_separator1"
Top = 3
Width = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM02EDJW
[CLASS] base_separator
[CLASSLOC] base_gui.vcx
[BASECLASS] separator
[OBJNAME] Base_separator2
[PARENT] editbar
[START PROPERTIES]
Height = 0
Left = 209
Name = "Base_separator2"
Top = 3
Width = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM025TSU
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdCopy
[PARENT] editbar
[START PROPERTIES]
Left = 126
Name = "cmdCopy"
Picture = ..\bmp\copy.ico
ToolTipText = "Сохранить в буфер обмена"
Top = 3
ZOrderSet = 4
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+C}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM024ZGD
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdCut
[PARENT] editbar
[START PROPERTIES]
Left = 88
Name = "cmdCut"
Picture = ..\bmp\cut.ico
ToolTipText = "Сохранить в буфер обмена и удалить"
Top = 3
ZOrderSet = 3
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+X}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM02EDJX
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdFind
[PARENT] editbar
[START PROPERTIES]
Left = 209
Name = "cmdFind"
Picture = ..\bmp\find.ico
ToolTipText = "Найти текст"
Top = 3
ZOrderSet = 7
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+F}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM027JQE
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdPaste
[PARENT] editbar
[START PROPERTIES]
Left = 164
Name = "cmdPaste"
Picture = ..\bmp\paste.ico
ToolTipText = "Вставить из буфера обмена"
Top = 3
ZOrderSet = 5
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+V}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM022YEU
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdRedo
[PARENT] editbar
[START PROPERTIES]
Left = 43
Name = "cmdRedo"
Picture = ..\bmp\redo.ico
ToolTipText = "Повторить последнее действие"
Top = 3
ZOrderSet = 1
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+R}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM02EDJY
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdRepl
[PARENT] editbar
[START PROPERTIES]
Left = 247
Name = "cmdRepl"
Picture = ..\bmp\replace.ico
ToolTipText = "Найти и заменить текcт"
Top = 3
ZOrderSet = 8
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+L}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM01FW5W
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdUndo
[PARENT] editbar
[START PROPERTIES]
Left = 5
Name = "cmdUndo"
Picture = ..\bmp\undo.ico
ToolTipText = "Отменить последнее действие"
Top = 3
ZOrderSet = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+Z}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] editbar
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1S60CG3CP
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] exitbar
[START PROPERTIES]
Enabled = .F.
Height = 44
Left = 0
Name = "exitbar"
Top = 0
Width = 48
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1S60CH2Y1
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdExit
[PARENT] exitbar
[START PROPERTIES]
Left = 5
Name = "cmdExit"
Picture = ..\bmp\exit.ico
Top = 3
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
CLEAR EVENTS
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] exitbar
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QA0279C8
[CLASS] dialog_form_szgr_2buttons
[CLASSLOC] base_gui.vcx
[BASECLASS] form
[OBJNAME] login_form
[START PROPERTIES]

Caption = "Идентификация пользователя"
DataSession = 1
Dialog_shape.Height = 135
Dialog_shape.Left = 3
Dialog_shape.Name = "Dialog_shape"
Dialog_shape.Top = 3
Dialog_shape.Width = 329
DoCreate = .T.
Height = 178
Icon = ..\bmp\keys.ico
Left = 0
Name = "login_form"
OSAVESET_FORM.Name = "OSAVESET_FORM"
Top = 0
Width = 335
WindowState = 1
_memberdata =      924<VFPData><memberdata name="cusername" type="property" display="cUserName"/><memberdata name="cuserpassword" type="property" display="cUserPassword"/><memberdata name="otask" type="property" display="oTask"/><memberdata name="recreateuserlist" type="method" display="recreateUserList"/><memberdata name="otasklist" type="property" display="oTaskList"/><memberdata name="movetocenter" type="Method" favorites="True" display="moveToCenter"/><memberdata name="lpassverification" type="property" display="lPassVerification"/><memberdata name="checkuser" type="method" display="checkUser"/><memberdata name="oapp" type="property" display="oApp"/><memberdata name="odbconnect" type="property" display="oDBConnect"/><memberdata name="lisload" type="property" display="lIsLoad"/><memberdata name="lstorepwd" type="property" display="lStorePwd"/><memberdata name="lstorepassword" type="property" display="lStorePassword"/></VFPData>
cancelbutton.Left = 232
cancelbutton.Name = "cancelbutton"
cancelbutton.TabIndex = 9
cancelbutton.Top = 144
cusername = 
cuserpassword = 
dbcontainer.Name = "dbcontainer"
lisload = .T.
lpassverification = .F.
lstorepassword = .F.
oapp = .NULL.
odbconnect = .NULL.
okbutton.Left = 137
okbutton.Name = "okbutton"
okbutton.TabIndex = 8
okbutton.Top = 144
resizecorner.Image.Height = 16
resizecorner.Image.Name = "Image"
resizecorner.Image.Width = 16
resizecorner.Left = 319
resizecorner.Name = "resizecorner"
resizecorner.Top = 162
resizecorner.resize_timer.Name = "resize_timer"
resizecorner.tmrRefresh.Name = "tmrRefresh"
[END PROPERTIES]
[START PROTECTED]
lisload^
[END PROTECTED]
[START METHODS]
PROCEDURE Activate
DODEFAULT()

IF THIS.lIsLoad
	THIS.WindowState = 0
	THIS.lIsLoad = .F.
ENDIF
ENDPROC
PROCEDURE Init
LPARAMETERS toApp as Object
LOCAL loTask as tasklist OF ..\lib.9\base_app, lnItem as Integer
	DODEFAULT()

	WITH THIS
		.oApp = m.toApp

		IF !ISNULL(m.toApp.oTaskList)
			*если задача только одна и пользователей у нее нет - то пробуем залететь молча
			lnItem = 0

			WITH .combobox_tasklist
				FOR lnItem = 1 TO m.toApp.oTaskList.Count
					.AddItem(m.toApp.oTaskList.Item[m.lnItem].oVars.cTaskCaption)
					.List[.NewIndex, 2] = m.toApp.oTaskList.Item[m.lnItem].oVars.cTaskName
					.Picture[m.lnItem] = m.toApp.oTaskList.Item[m.lnItem].oVars.cTaskIcon

					IF m.toApp.oTaskList.Item[m.lnItem].oVars.lActive
						.ListIndex = m.lnItem

						.Valid()
					ENDIF
				ENDFOR
			ENDWITH

			IF (.lStorePassword OR (m.toApp.oTaskList.Count = 1 AND .combobox_userlist.ListCount = 0));
				AND	.checkUser()
			ELSE
				.textbox_password.SetFocus()
			ENDIF

			.moveToCenter()
		ENDIF
	ENDWITH
ENDPROC
PROCEDURE cancelbutton.Click
THISFORM.Hide()
NODEFAULT
ENDPROC
PROCEDURE checkuser
#INCLUDE ..\lib.9\base_app.h
WITH THIS
	IF !ISNULL(.oApp.oVars.oCurrentTask) && AND !EMPTY(.cUserName)
		LOCAL loExc as Exception, llres as Logical

		.lPassVerification = .F.

		.oDBConnect = NEWOBJECT("DbConnect", "..\lib.9\base_idb", '', .oApp.oVars.oCurrentTask.oVars.nDBType)
#IF !_DEVELOP_MODE
		TRY
#ENDIF
			.lPassVerification = .oDBConnect.connect(.oApp.oVars.oCurrentTask.oVars.cDBPath,;
												     .oApp.oVars.oCurrentTask.oVars.cDBName,;
												     ALLTRIM(.cUserName),;
												     ALLTRIM(.cUserPassword))
#IF !_DEVELOP_MODE
		CATCH TO loExc
			.oApp.oFunction.showErrMsg(m.loExc)
		ENDTRY
#ENDIF
		IF .lPassVerification
			.oApp.oVars.oCurrentTask.oVars.cUserName = ALLTRIM(.cUserName)
			.oApp.oVars.oCurrentTask.oVars.cUserPassword = ALLTRIM(.cUserPassword)
			.oApp.oVars.oCurrentTask.oVars.lStorePassword = .lStorePassword

			.Hide()
		ELSE
			IF .oDBConnect.getResultCode() = 210
				MESSAGEBOX("Пароль не верен!", 16, .oApp.oVars.cTaskCaption)

				THIS.textbox_password.SetFocus()
			ENDIF

			.oDBConnect.Destroy()
			.oDBConnect = .NULL.
		ENDIF
	ENDIF
	
	RETURN .lPassVerification
ENDWITH
ENDPROC
PROCEDURE okbutton.Click
THISFORM.checkUser()
ENDPROC
PROCEDURE recreateuserlist
#INCLUDE ..\lib.9\base_app.h
LPARAMETERS tсTask as String
	WITH THIS
		IF !EMPTY(m.tсTask)
			LOCAL lnItem as Integer, lnI as Integer, lcMsg as String,;
				  loDBConnect as DbConnect OF ..\lib.9\base_idb,;
				  loExc as Exception, llres as Logical
			FOR lnI = 1 TO .oApp.oTaskList.Count
				IF .oApp.oTaskList.Item[m.lnI].oVars.cTaskName == m.tсTask
					CREATE CURSOR USERLIST (FULL_NAME C(50), SYSTEM_NAME C(50))

					.oApp.oVars.oCurrentTask = .oApp.oTaskList.Item[m.lnI]

					loDBConnect = NEWOBJECT("DbConnect", "..\lib.9\base_idb", '',;
											.oApp.oTaskList.Item[m.lnI].oVars.nDBType)

					DO CASE
					CASE .oApp.oTaskList.Item[m.lnI].oVars.nDBType = DB_FoxPro
					CASE .oApp.oTaskList.Item[m.lnI].oVars.nDBType = DB_PostgreSQL
#IF !_DEVELOP_MODE
						TRY
#ENDIF
							llres = m.loDBConnect.connect(.oApp.oTaskList.Item[m.lnI].oVars.cDBPath,;
														  .oApp.oTaskList.Item[m.lnI].oVars.cDBName,;
														  "list_users", "list_users")
							m.loDBConnect.lock()

							IF m.llres
								llres = SQLEXEC(m.loDBConnect.nId_Connection,;
												"SELECT * FROM " + .oApp.oTaskList.Item[m.lnI].oVars.cDBSchema;
												+ ".get_list_users()", "USERLIST")

								IF m.llres = -1
									LOCAL ARRAY laResult[1]
									AERROR(laResult)

									lcMsg = "Don't receive users list from server ";
											+ .oApp.oTaskList.Item[m.lnI].oVars.cDBPath + "!" + CRLF;
											+ laResult[2]

									THIS.oApp.showMsg(m.lcMsg)
									MESSAGEBOX(m.lcMsg, 16, .oApp.oTaskList.Item[m.lnI].oVars.cTaskCaption)
								ENDIF
							ENDIF

							m.loDBConnect.unLock()
#IF !_DEVELOP_MODE
						CATCH TO loExc
							.oApp.oFunction.showErrMsg(m.loExc)
						ENDTRY
#ENDIF
						RELEASE m.loDBConnect
					CASE .oApp.oTaskList.Item[m.lnI].oVars.nDBType = DB_MSSQL
					CASE .oApp.oTaskList.Item[m.lnI].oVars.nDBType = DB_Oracle
					CASE .oApp.oTaskList.Item[m.lnI].oVars.nDBType = DB_Access
						.combobox_userlist.Style = 0
						
						IF !EMPTY(.oApp.oTaskList.Item[m.lnI].oVars.cUserName)
							INSERT INTO USERLIST (FULL_NAME, SYSTEM_NAME);
										  VALUES (.oApp.oTaskList.Item[m.lnI].oVars.cUserName,;
										  		  .oApp.oTaskList.Item[m.lnI].oVars.cUserName)
						ENDIF
					OTHERWISE
					ENDCASE

					.cUserName = .oApp.oTaskList.Item[m.lnI].oVars.cUserName
					.lStorePassword = .oApp.oTaskList.Item[m.lnI].oVars.lStorePassword

					WITH .Combobox_UserList
						lnItem = 0
						.Clear()

						IF USED("USERLIST")
							SELECT USERLIST

							SCAN
								lnItem = m.lnItem + 1

								.AddItem(ALLTRIM(FULL_NAME))
								.List[.NewIndex, 2] = ALLTRIM(SYSTEM_NAME)
								.Picture[m.lnItem] = "..\bmp\16x16\user1.bmp"

								IF THIS.oApp.oTaskList.Item[m.lnI].oVars.cUserName == ALLTRIM(SYSTEM_NAME)
									.ListIndex = m.lnItem
					
									IF THIS.lStorePassword
										THIS.cUserPassword = THIS.oApp.oTaskList.Item[m.lnI].oVars.cUserPassword
									ENDIF
								ENDIF
							ENDSCAN

							USE
						ENDIF
					ENDWITH	

					EXIT
				ENDIF
			ENDFOR
		ELSE
			THIS.Combobox_UserList.Clear()
		ENDIF
	ENDWITH
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
8[END RESERVED2]
[START RESERVED3]
*checkuser 
*recreateuserlist 
cusername
cuserpassword
lisload Признак закгрузки впервый раз
lpassverification
lstorepassword
oapp
odbconnect
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\user1.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\user1.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
base_idb.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _20N19OC7R
[CLASS] base_checkbox
[CLASSLOC] base_gui.vcx
[BASECLASS] checkbox
[OBJNAME] checkbox_StorePwd
[PARENT] login_form
[START PROPERTIES]
Alignment = 0
Caption = "Сохранять пароль"
ControlSource = "THISFORM.lStorePassword"
FontBold = .T.
Left = 150
Name = "checkbox_StorePwd"
ToolTipText = "Сохранять пароль"
Top = 112
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QC0CCS8M
[CLASS] base_combobox
[CLASSLOC] base_gui.vcx
[BASECLASS] combobox
[OBJNAME] combobox_tasklist
[PARENT] login_form
[START PROPERTIES]
BoundColumn = 2
BoundTo = .T.
ColumnCount = 1
Height = 24
Left = 150
Name = "combobox_tasklist"
StatusBarText = "Выберите задачу"
Style = 2
TabIndex = 3
ToolTipText = "Выберите задачу"
Top = 14
Width = 168
[END PROPERTIES]
[START METHODS]
PROCEDURE Valid
THISFORM.recreateUserList(THIS.Value)
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QA02R7QW
[CLASS] base_combobox
[CLASSLOC] base_gui.vcx
[BASECLASS] combobox
[OBJNAME] combobox_userlist
[PARENT] login_form
[START PROPERTIES]
BoundColumn = 2
BoundTo = .T.
ColumnCount = 1
Height = 24
Left = 150
Name = "combobox_userlist"
StatusBarText = "Выберите пользователя"
Style = 2
TabIndex = 5
ToolTipText = "Выберите пользователя"
Top = 49
Width = 168
[END PROPERTIES]
[START METHODS]
PROCEDURE Valid
THISFORM.cUserName = ALLTRIM(IIF(EMPTY(THIS.Text), THIS.Value, THIS.Text))
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QA02R7QX
[CLASS] base_label
[CLASSLOC] base_gui.vcx
[BASECLASS] label
[OBJNAME] label_password
[PARENT] login_form
[START PROPERTIES]
BackStyle = 0
Caption = "Пароль пользователя:"
FontBold = .T.
Height = 15
Left = 14
Name = "label_password"
TabIndex = 6
Top = 87
Width = 135
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QC0CCS8L
[CLASS] base_label
[CLASSLOC] base_gui.vcx
[BASECLASS] label
[OBJNAME] label_tasklist
[PARENT] login_form
[START PROPERTIES]
BackStyle = 0
Caption = "Название задачи:"
FontBold = .T.
Height = 15
Left = 41
Name = "label_tasklist"
TabIndex = 2
Top = 18
Width = 107
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QA0279C8
[CLASS] base_label
[CLASSLOC] base_gui.vcx
[BASECLASS] label
[OBJNAME] label_user
[PARENT] login_form
[START PROPERTIES]
BackStyle = 0
Caption = "Имя пользователя:"
FontBold = .T.
Height = 15
Left = 32
Name = "label_user"
TabIndex = 4
Top = 53
Width = 116
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QA02SJ7J
[CLASS] base_textbox
[CLASSLOC] base_gui.vcx
[BASECLASS] textbox
[OBJNAME] textbox_password
[PARENT] login_form
[START PROPERTIES]
Anchor = 6
ControlSource = "THISFORM.cUserPassword"
Height = 21
Left = 150
Name = "textbox_password"
PasswordChar = "*"
SelectOnEntry = .T.
StatusBarText = "Введите пароль"
TabIndex = 7
ToolTipText = "Введите пароль"
Top = 84
Width = 168
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] login_form
[START PROPERTIES]
Courier New, 0, 8, 7, 14, 11, 7, 3, 0
MS Sans Serif, 0, 8, 5, 13, 11, 11, 2, 0
MS Sans Serif, 1, 8, 6, 13, 11, 12, 2, 0
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1NJ0UL9NO
[CLASS] optionbutton
[BASECLASS] optionbutton
[OBJNAME] op_window
[START PROPERTIES]

Caption = "WindowCaption"
FontName = "Microsoft Sans Serif"
FontSize = 8
Height = 22
Name = "op_window"
Picture = ..\bmp\16x16\view_text.png
PicturePosition = 2
SpecialEffect = 2
Style = 1
Width = 150
_memberdata =      547<VFPData><memberdata name="formname" type="property" display="formName"/><memberdata name="formcaption" type="property" display="formCaption"/><memberdata name="formshortcaption" type="property" display="formShortCaption"/><memberdata name="formhwnd" type="property" display="formHWnd"/><memberdata name="ctempimage" type="property" display="cTempImage"/><memberdata name="ctempscreenimage" type="property" display="cTempScreenImage"/><memberdata name="contextmenuselectionhandler" type="method" display="contextMenuSelectionHandler"/></VFPData>
ctempicon = 
ctempimage = 
formcaption = 
formhwnd = 0
formname = 
formshortcaption = 
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
LOCAL loForm as Form
	FOR EACH loForm IN m.goApp.oApp_Collection
		IF m.loForm.hWnd = THIS.formHWnd
			IF THIS.Parent.Parent.Parent.lHideOnClickIfActive
				m.loForm.Hide()
				loForm.WindowState = 0

				EXIT 
			ENDIF 

			IF m.loForm.WindowState = 1
				loForm.WindowState = 0
			ENDIF

			IF TYPE("m.loForm.ActiveControl") = 'O'
				IF PEMSTATUS(m.loForm.ActiveControl, "SetFocus", 5)
					m.loform.Activecontrol.Setfocus()
				ENDIF
			ELSE
				m.loForm.Show()
			ENDIF

			EXIT
		ENDIF
	ENDFOR

	THIS.Value = 1
ENDPROC
PROCEDURE DblClick
THIS.Click()
ENDPROC
PROCEDURE Destroy
oTaskbarButton_1NT0UWKRF = .NULL.

IF !EMPTY(THIS.cTempImage)
	THIS.Picture = ''

	CLEAR RESOURCES (THIS.cTempImage)
	ERASE (THIS.cTempImage)
ENDIF
ENDPROC
PROCEDURE Init
THIS.Height = TSKB_BTN_HEIGHT
THIS.Width = TSKB_BTN_MAXWIDTH
THIS.FontName = TSKB_FONTNAME
THIS.FontSize = TSKB_FONTSIZE
THIS.FontBold = TSKB_FONTBOLD
ENDPROC
PROCEDURE RightClick
LOCAL loForm as Form, llModalWindow as Logical, lnRow as Integer, lnCol as Integer
	FOR EACH loForm IN _Screen.Forms
		IF VARTYPE(m.loForm.WindowType) = "N" 
			IF m.loForm.WindowType = 1
				llModalWindow = .T.
				EXIT
			ENDIF 
		ENDIF
	ENDFOR

	IF m.llModalWindow
		*modal form active, nothing to do
		RETURN 
	ENDIF 

	FOR EACH loForm IN _Screen.Forms
		IF m.loForm.hWnd = THIS.formHWnd
			EXIT
		ENDIF
	ENDFOR
	*set a public variable to handle context menu click
	IF TYPE("oTaskbarButton_1NT0UWKRF") = 'U'
		PUBLIC oTaskbarButton_1NT0UWKRF 
		oTaskbarButton_1NT0UWKRF = THIS 
	ELSE
		oTaskbarButton_1NT0UWKRF = THIS 
	ENDIF

	lnRow = m.goApp.oFunction.pixeltoFoxel(m.goApp.oWinApi.getCursorPos(.T.), .T.)
	lnCol = m.goApp.oFunction.pixeltoFoxel(m.goApp.oWinApi.getCursorPos(.F.), .F.)

	DEFINE POPUP context SHORTCUT RELATIVE FROM m.lnRow, m.lnCol IN SCREEN

	ACTIVATE WINDOW (m.loForm.Name) TOP

	IF m.loForm.WindowState <> 0 OR (m.loForm.WindowState = 0 AND m.loForm.Visible = .F.)
		DEFINE BAR 1 OF context PROMPT CNT_MENU_RESTORE
	ELSE
		DEFINE BAR 1 OF context PROMPT '\' + CNT_MENU_RESTORE
	ENDIF

	IF m.loForm.WindowState <> 1 AND m.loForm.Visible = .T.
		DEFINE BAR 2 OF context PROMPT CNT_MENU_MINIMIZE
	ELSE
		DEFINE BAR 2 OF context PROMPT '\' + CNT_MENU_MINIMIZE
	ENDIF

	IF m.loForm.WindowState <> 2
		DEFINE BAR 3 OF context PROMPT CNT_MENU_MAXIMIZE
	ELSE
		DEFINE BAR 3 OF context PROMPT '\' + CNT_MENU_MAXIMIZE
	ENDIF

	DEFINE BAR 4 OF context PROMPT '\-'
	DEFINE BAR 5 OF context PROMPT CNT_MENU_CLOSE

	ON SELECTION POPUP context oTaskbarButton_1NT0UWKRF.contextMenuSelectionHandler(BAR())
	ACTIVATE POPUP context

	oTaskbarButton_1NT0UWKRF = .NULL.
ENDPROC
PROCEDURE contextmenuselectionhandler
LPARAMETERS tnBar as Integer
LOCAL loForm as Form
	FOR EACH loForm IN _Screen.Forms
		IF m.loForm.hWnd = THIS.formHWnd
			DO CASE
			CASE m.tnBar = 1
				loForm.WindowState = 0
				m.loForm.Show() 
			CASE m.tnBar = 2
				IF THIS.Parent.Parent.Parent.lHideFormOnMinimize
					m.loForm.Hide()
					loForm.WindowState = 0
				ELSE 
					loForm.WindowState = 1
				ENDIF 
			CASE m.tnBar = 3
				loForm.WindowState = 2

				IF m.loForm.Visible = .F.
					m.loForm.Show()
				ENDIF 
			CASE m.tnBar = 5
				m.loForm.Release()
			ENDCASE 
			EXIT
		ENDIF  
	ENDFOR

	oTaskbarButton_1NT0UWKRF = .NULL.
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*contextmenuselectionhandler 
_memberdata XML Metadata for customizable properties
ctempicon temporary icon, used to create a temporary bitmap used for button
ctempimage temporary image used to store form icon converted to 16x16 bitmap
formcaption assigned form caption
formhwnd assigned form hWnd
formname name of the form
formshortcaption if the form has shortCaption property, use this instead of normal caption
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
taskbar.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] op_window
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RL10TC0Y
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] servicebar
[START PROPERTIES]
Caption = "Servicebar"
Enabled = .F.
Height = 44
Left = 0
Name = "servicebar"
Top = 0
Width = 131
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
5[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RL13ULZ4
[CLASS] base_separator
[CLASSLOC] base_gui.vcx
[BASECLASS] separator
[OBJNAME] Base_separator1
[PARENT] servicebar
[START PROPERTIES]
Height = 0
Left = 50
Name = "Base_separator1"
Top = 3
Width = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RL12MFAF
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdCalendar
[PARENT] servicebar
[START PROPERTIES]
Left = 50
Name = "cmdCalendar"
Picture = ..\bmp\calendar.ico
ToolTipText = "Календарь"
Top = 3
ZOrderSet = 2
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
m.goApp.OnMenuEvents("Calendar")
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RL11RB3B
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdClock
[PARENT] servicebar
[START PROPERTIES]
Left = 88
Name = "cmdClock"
Picture = ..\bmp\clock.ico
ToolTipText = "Часы"
Top = 3
ZOrderSet = 3
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
m.goApp.OnMenuEvents("Clock")
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RL13ULZ5
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdWorkInterval
[PARENT] servicebar
[START PROPERTIES]
Left = 5
Name = "cmdWorkInterval"
Picture = ..\bmp\data_time.ico
ToolTipText = "Рабочий период"
Top = 3
ZOrderSet = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
m.goApp.goForm("Select_period", 0, .NULL., .NULL.)
*!*	m.goApp.goForm("FORMS\Select_period", 0, .NULL., .NULL.)
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] servicebar
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q509URR2
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] taskbar
[START PROPERTIES]

Height = 28
Left = 0
Name = "taskbar"
Top = 0
Width = 210
_memberdata =     1923<VFPData><memberdata name="addactiveforms" type="method" display="addActiveForms"/><memberdata name="addformbutton" type="method" display="addFormButton"/><memberdata name="removeformbutton" type="method" display="removeFormButton"/><memberdata name="orderbuttons" type="method" display="orderButtons"/><memberdata name="ncurrentline" type="property" display="nCurrentLine"/><memberdata name="resizetaskbar" type="method" display="resizeTaskBar"/><memberdata name="nextrawidth" type="property" display="nExtraWidth"/><memberdata name="setbuttonpicture" type="method" display="setButtonPicture"/><memberdata name="setbuttonwidthandcaption" type="method" display="setButtonWidthAndCaption"/><memberdata name="activateformbutton" type="method" display="activateFormButton"/><memberdata name="singleline" type="property" display="singleLine"/><memberdata name="nlinecount" type="property" display="nLineCount"/><memberdata name="nmaxbuttonwidth" type="property" display="nMaxButtonWidth"/><memberdata name="nminbuttonwidth" type="property" display="nMinButtonWidth"/><memberdata name="nscrollbarwidth" type="property" display="nScrollBarWidth"/><memberdata name="otoplevelform" type="property" display="oToplevelForm"/><memberdata name="singleline_assign" type="method" display="singleLine_Assign"/><memberdata name="gettoplevelform" type="method" display="getToplevelForm"/><memberdata name="checkresizebinding" type="method" display="checkResizeBinding"/><memberdata name="nscrollbarheight" type="property" display="nScrollbarHeight"/><memberdata name="coldcursor" type="property" display="cOldCursor"/><memberdata name="nextraheight" type="property" display="nExtraHeight"/><memberdata name="captionassignhandler" type="method" display="captionAssignHandler"/><memberdata name="deactivatehandler" type="method" display="deactivateHandler"/><memberdata name="resizehandler" type="method" display="resizeHandler"/></VFPData>
coldcursor = 
lhideformonminimaze = .F.
lhideonclickifactive = .F.
lresizebinding = .F.
ncurrentline = 1
nextraheight = 0
nextrawidth = 0
nlinecount = 0
nmaxbuttonwidth = 200
nminbuttonwidth = 100
nscrollbarheight = 0
nscrollbarwidth = 0
oimage = .NULL.
otoplevelform = .NULL.
singleline = .F.
[END PROPERTIES]
[START METHODS]
PROCEDURE AfterDock
THIS.resizeTaskbar()
ENDPROC
PROCEDURE DblClick
NODEFAULT
ENDPROC
PROCEDURE Init
THIS.cnt_windows.Height=0
THIS.nScrollbarWidth = SYSMETRIC(5)
THIS.nScrollbarHeight = SYSMETRIC(6)
THIS.oTopLevelForm = THIS.getTopLevelForm()
*gpImage instance used to convert icon to PNG
THIS.oImage = NEWOBJECT("gpImage", "_gdiplus.vcx")
*!*	*bind host resize if not already 
*!*	IF THIS.checkResizeBinding()
*!*		THIS.lResizeBinding = .T.
*!*		BINDEVENT(THIS.oTopLevelForm, "Resize", THIS, "ResizeTaskbar")
*!*	ENDIF

THIS.Tag = "init"
THIS.resizeTaskbar()
THIS.Tag = ''
*loop through _screen.Forms collection and buttons for them
THIS.addActiveForms()

THIS.Dock(3, 0, 0)

IF THIS.cnt_windows.opg_windows.ButtonCount > 0
	THIS.Show()
ENDIF
ENDPROC
PROCEDURE Show
LPARAMETERS tnStyle
	*requires some buttons to be made visible
	IF THIS.cnt_windows.opg_windows.ButtonCount = 0
		NODEFAULT 
	ELSE 
		DODEFAULT(m.tnStyle)
	ENDIF
ENDPROC
PROCEDURE activateformbutton
LPARAMETERS tHWnd as Integer
*delegate to be executed when a form is activated
*simulate a click on the form associated button
LOCAL loButton as Object
	THIS.cnt_windows.opg_windows.SetAll("Value", 0)

	FOR EACH loButton IN THIS.cnt_windows.opg_windows.Buttons
		IF m.loButton.formhWnd = m.thWnd
			loButton.Value = 1
			EXIT
		ENDIF
	ENDFOR
ENDPROC
PROCEDURE addactiveforms
LOCAL loForm as Form
	IF VARTYPE(m.goApp) = 'O' AND !ISNULL(m.goApp)
		FOR EACH loForm IN m.goApp.oApp_Collection
			IF !EMPTY(m.loForm.Caption) AND m.loForm.BaseClass == "Form"
				THIS.AddFormButton(m.loForm)
			ENDIF 
		ENDFOR
	ENDIF
ENDPROC
PROCEDURE addformbutton
LPARAMETERS toForm as Form
LOCAL lcName, loButton, llAddFormOK
	IF !UPPER(JUSTFNAME(THIS.ClassLibrary)) $ UPPER(SET("Classlib"))
		SET CLASSLIB TO (THIS.ClassLibrary) ADDITIVE 
	ENDIF 
	*first, scan forms collection to see if hWnd is from some active form
	llAddFormOK = .T.

	FOR EACH loButton IN THIS.cnt_windows.opg_windows.Buttons
		IF m.loButton.formHWnd = m.toForm.HWnd
			llAddFormOk = .F.
			EXIT
		ENDIF 
	ENDFOR 

	IF m.llAddFormOK
		lcName = "hWnd" + TRANSFORM(m.toForm.hWnd)
		THIS.cnt_windows.opg_windows.AddObject(m.lcName, "op_window")
		loButton = EVALUATE("THIS.cnt_WINDOWS.opg_windows." + m.lcName)

		WITH m.loButton as op_window
			.formHWnd = m.toForm.HWnd
			.formName = m.toForm.Name

			IF TYPE("m.toForm.shortCaption") = 'C'
				.formShortCaption = m.toForm.shortCaption
			ENDIF

			.formCaption = m.toForm.Caption
			.ToolTipText = m.toForm.Caption
			THIS.setButtonWidthAndCaption(m.loButton)
			THIS.setButtonPicture(m.loButton, m.toForm)
		ENDWITH
		*loop through buttons and add new lines and spinner if necessary
		THIS.orderButtons()

		THIS.activateFormButton(m.toForm.HWnd)
	ENDIF
ENDPROC
PROCEDURE captionassignhandler
LPARAMETERS toForm as Form
LOCAL loButton as Object, llisFound as Logical
	THIS.cnt_windows.opg_windows.SetAll("Value", 0)

	FOR EACH loButton IN THIS.cnt_windows.opg_windows.Buttons
		IF m.loButton.FormHWnd = m.toForm.HWnd
			llisFound = .t.
			EXIT
		ENDIF
	ENDFOR

	IF m.llisFound  
		loButton.FormHWnd = m.toForm.HWnd
		loButton.FormName = m.toForm.Name

		IF TYPE("m.toForm.shortCaption") = 'C'
			loButton.FormShortCaption = m.toForm.ShortCaption
		ENDIF

		loButton.FormCaption = m.toForm.Caption
		loButton.ToolTipText = m.toForm.Caption

		THIS.oTopLevelForm.LockScreen = .T.

		THIS.setButtonWidthAndCaption(m.loButton)
		THIS.orderButtons()

		THIS.oTopLevelForm.LockScreen = .F.
	ENDIF
ENDPROC
PROCEDURE checkresizebinding
LOCAL ARRAY laEv[1]
LOCAL lnEvCount, llOK
	llOK = .T.
	lnEvCount = AEVENTS(laEv, THIS.oTopLevelForm)

	IF m.lnEvCount > 0
		IF ASCAN(laEv, "RESIZETASKBAR") > 0
			llOk = .F.
		ENDIF
	ENDIF
RETURN m.llOK
ENDPROC
PROCEDURE deactivatehandler
LPARAMETERS tHWnd as Integer
*delegate to be executed when a form is deactivated
*check associated button
LOCAL loButton as Object
*!*		*hide minimized forms if needed
*!*		IF laEv[1].WindowState = 1 AND THIS.lHideFormOnMinimize AND laEv[1].Visible = .T.
*!*			laEv[1].Hide()
*!*			*avoid bug with minimized invisible forms, ghost context menu appear, so restore to normal state
*!*			laEv[1].WindowState = 0
*!*		ENDIF 
	FOR EACH loButton IN THIS.cnt_windows.opg_windows.Buttons 
		IF m.loButton.formhWnd = m.tHWnd
			loButton.Value = 0
		ENDIF 
	ENDFOR
ENDPROC
PROCEDURE gettoplevelform
	*from Foundation Classes "_ui.vcx"
	ASSERT TYPE("_SCREEN.ActiveForm") <> "O" OR INLIST(_SCREEN.ActiveForm.ShowWindow, 0, 1, 2)

	DO CASE
	CASE _SCREEN.FormCount = 0 OR (TYPE("_SCREEN.ActiveForm") = "O" AND _SCREEN.ActiveForm.ShowWindow = 0)     && ShowWindow In Screen
	    loTopForm = _SCREEN
	CASE (TYPE("_SCREEN.ActiveForm") = "O" AND _SCREEN.ActiveForm.ShowWindow = 2)    && ShowWindow As Top Form
	    loTopForm = _SCREEN.ActiveForm
	OTHERWISE
	    FOR EACH loForm IN _SCREEN.Forms  && note: these may be toolbars
	                                       && if undocked, but that's okay --
	                                       && they are only ShowWIndow 0 or 1.
	       	IF m.loForm.ShowWindow = 2 && the first one in the collection will
	                               && be "active top form"
	          	loTopForm = m.loForm
	    		EXIT
	    	ENDIF
	    ENDFOR

	    IF VARTYPE(m.loTopForm) <> "O"
	    	loTopForm = _SCREEN
	    ENDIF
	ENDCASE
RETURN m.loTopForm
ENDPROC
PROCEDURE orderbuttons
*loop through buttons and order them after a new one added or width changes. 
LOCAL loButton, lnLeft, lnTop, lnI, lnTotalWidth, lnCurrentLine, lnLineCount
	STORE 0 TO lnLeft, lnTop, lnTotalWidth
	STORE 1 TO lnCurrentLine, lnLineCount

	WITH THIS.cnt_windows.opg_windows
		FOR lnI = 1 to .ButtonCount 
			IF m.lnTotalWidth+.Buttons[m.lnI].Width > .Width
				lnLineCount = m.lnLineCount + 1
				lnTotalWidth = 0
				lnTop = (m.lnLineCount - 1) * TSKB_BTN_HEIGHT +(m.lnLinecount - 1)
			ENDIF

			lnLeft = m.lnTotalWidth
			lnTotalWidth = m.lnTotalWidth+.Buttons[m.lnI].Width + 1

			IF !.Buttons[m.lnI].Top = m.lnTop
				.Buttons[m.lnI].Top = m.lnTop
			ENDIF

			IF !.Buttons[m.lnI].Left = m.lnLeft
				.Buttons[m.lnI].Left = m.lnLeft
			ENDIF
		ENDFOR

		IF INLIST(THIS.DockPosition, -1, 0, 3)
			IF m.lnLineCount > 1
				IF .Height <> (m.lnLineCount - 1) * (1 + TSKB_BTN_HEIGHT)
					.Height = (m.lnLineCount - 1) * (1 + TSKB_BTN_HEIGHT)
				ENDIF
			ELSE
				IF .Height <> TSKB_BTN_HEIGHT
					.Height = TSKB_BTN_HEIGHT
				ENDIF
			ENDIF
		ENDIF

		.SetAll("Visible", .T.)

		IF THIS.singleLine
			IF THIS.cnt_windows.Height <> TSKB_BTN_HEIGHT 
				THIS.cnt_windows.Height = TSKB_BTN_HEIGHT 
			ENDIF
			*set option group line count, for spinner 
			THIS.nLineCount = m.lnLinecount
			*set max value for the spinner
			THIS.cnt_windows.spnActiveLine.SpinnerHighValue = m.lnLinecount
			THIS.cnt_windows.spnActiveLine.KeyboardHighValue = m.lnLinecount
			*if opg has many lines, set top property
			* only .nCurrentLine will be visible
			IF m.lnLinecount > 1
				IF .Top <> -((.nCurrentLine - 1) * TSKB_BTN_HEIGHT + (THIS.nCurrentLine - 1))
					.Top = -((.nCurrentLine - 1) * TSKB_BTN_HEIGHT + (THIS.nCurrentLine - 1))
				ENDIF

				.Parent.spnActiveLine.Visible = .T.
				.ToolTipText = "Line " + TRANSFORM(THIS.nCurrentLine) + " / " + TRANSFORM(THIS.nLineCount)
				.Parent.spnActiveLine.ToolTipText = .ToolTipText
			ELSE
				IF .Top <> 0
					.Top = 0
				ENDIF

				.Parent.spnActiveLine.Visible = .F.
				.ToolTipText = ''
			ENDIF
		ELSE
			IF THIS.cnt_windows.Height <> .Height AND INLIST(THIS.DockPosition, -1, 0, 3)
				THIS.cnt_windows.Height = .Height
			ENDIF

			.Parent.spnActiveLine.Visible = .F.
			.ToolTipText = ''
		ENDIF  
	ENDWITH 

	IF THIS.cnt_windows.opg_windows.ButtonCount = 0
		THIS.Hide()
	ELSE
		THIS.Show()
	ENDIF
ENDPROC
PROCEDURE removeformbutton
LPARAMETERS thWnd as Integer
LOCAL lcName, lcObject
	lcName = "hwnd" + TRANSFORM(m.thWnd)
	lcObject = "THIS.cnt_windows.opg_windows." + m.lcName

	IF TYPE(m.lcObject) = 'O'
		 THIS.cnt_windows.opg_windows.RemoveObject(m.lcName)
		 THIS.orderButtons() 
	ENDIF
ENDPROC
PROCEDURE resizehandler
*added 2005.11.13
*delegate to be executed when a form is resized
*only needed to hide the last form minimized, Deactivate doesn't fire
LOCAL ARRAY laEv[1]
LOCAL lhWnd as Integer
	AEVENTS(laEv, 0)

	IF UPPER(laEv[2]) = "RESIZE" AND laEv[3] = 0
		lhWnd = laEv[1].hWnd
		*hide minimized forms if needed, but restore to normal state, bug workaround
		IF laEv[1].WindowState = 1 AND THIS.lHideFormOnMinimize &&AND laEv[1].Visible = .t.
			laEv[1].Hide()
			laEv[1].WindowState = 0
		ENDIF 
	ENDIF
ENDPROC
PROCEDURE resizetaskbar
*temporary unbind host resize event 
*!*	UNBINDEVENT(THIS.oTopLevelForm, "Resize", THIS, "ResizeTaskbar")

THIS.oTopLevelForm.LockScreen = .T.

DO CASE
CASE INLIST(THIS.DockPosition, -1, 0, 3)
*верх, низ
	THIS.Left = 0
	THIS.cnt_windows.Width = THIS.oTopLevelForm.Width - (THIS.nScrollbarWidth + 1) + THIS.nExtraWidth
CASE INLIST(THIS.DockPosition, 1, 2)
*право, лево
	THIS.Top = 0
	THIS.SingleLine = .F.
	THIS.cnt_windows.Width = THIS.nMaxButtonWidth + THIS.nExtraWidth
	THIS.cnt_windows.Height = THIS.oTopLevelForm.Height - (THIS.nScrollbarHeight + 1) + THIS.nExtraHeight
ENDCASE

IF !THIS.Tag == "init"
	FOR EACH loButton IN THIS.cnt_windows.opg_windows.Buttons
		THIS.setButtonWidthAndCaption(m.loButton)
	ENDFOR 

	THIS.orderButtons()
	THIS.Tag = ''
ENDIF

THIS.oTopLevelForm.LockScreen = .F.
*!*	BINDEVENT(THIS.oTopLevelForm, "Resize", THIS, "ResizeTaskbar")
ENDPROC
PROCEDURE setbuttonpicture
LPARAMETERS toButton, toForm as Form
LOCAL lcTempIcon, lcImage, loThumb as gpimage OF _gdiplus.vcx
	IF EMPTY(m.toForm.Icon) OR !FILE(m.toForm.Icon)
		RETURN 
	ENDIF 

	lcImage = SYS(2015)
	lcTempIcon = SYS(2023) + '\' + m.lcImage + ".ico"
	*STRTOFILE(FILETOSTR)) is used because icons can be embedded in EXE and the 
	*gdi+ class needs to locate files on disk
	IF STRTOFILE(FILETOSTR(m.toForm.Icon), m.lcTempIcon) > 0
		IF THIS.oImage.CreateFromFile(m.lcTempIcon)
			loThumb = THIS.oImage.GetThumbnailImage(m.toButton.Height - 6, m.toButton.Height - 6)
			toButton.cTempImage = SYS(2023) + '\' + m.lcImage + ".tif"

			IF loThumb.SaveToFile(m.toButton.cTempImage, "image/tiff")
				*save successful, hadle transparency issues by creating an image control
				toButton.Picture = m.toButton.cTempImage
				toButton.cTempIcon = m.lcTempIcon
			ENDIF
		ENDIF
		*free icon file hadle, we need to delete it
		THIS.oImage.Destroy()
		loThumb.Destroy()

		ERASE (m.lcTempIcon)
	ENDIF
ENDPROC
PROCEDURE setbuttonwidthandcaption
LPARAMETERS toButton
LOCAL lcCaption, lcCaptionVar, lni, lnwidth
	lcCaption = ALLTRIM(IIF(EMPTY(m.toButton.formShortCaption), m.toButton.formCaption, m.toButton.formShortCaption))
	toButton.Caption = m.lcCaption

	lnwidth = TXTWIDTH(m.lcCaption, m.toButton.FontName,;
				  	   m.toButton.FontSize,;
					   IIF(m.toButton.FontBold, 'B', ''));
			  * FONTMETRIC(6, m.toButton.FontName,;
					       m.toButton.FontSize,;
					       IIF(m.toButton.FontBold, 'B', '')) + 24

	DO CASE
	CASE m.lnwidth > m.toButton.Parent.Parent.Parent.nMaxButtonWidth	&&exceed max button width limit
		FOR lni = LEN(m.lcCaption) TO 0 STEP -1
			lcCaptionVar = LEFT(m.lcCaption, m.lni) + "..."
			lnwidth = TXTWIDTH(m.lcCaptionVar, m.toButton.FontName,;
							   m.toButton.FontSize,;
							   IIF(m.toButton.FontBold, 'B', ''));
					  * FONTMETRIC(6, m.toButton.FontName,;
							     m.toButton.FontSize,;
							     IIF(m.toButton.FontBold, 'B', '')) + 24

			IF m.lnwidth <= m.toButton.Parent.Parent.Parent.nMaxButtonWidth
				toButton.Caption = m.lcCaptionVar
				EXIT
			ENDIF
		ENDFOR
	CASE m.lnwidth <= m.toButton.Parent.Parent.Parent.nMinButtonWidth
		lnwidth = m.toButton.Parent.Parent.Parent.nMinButtonWidth
	ENDCASE

	toButton.Width = IIF(INLIST(THIS.DockPosition, 1, 2), m.toButton.Parent.Parent.Parent.nMaxButtonWidth, m.lnwidth)

	m.toButton.Refresh()
ENDPROC
PROCEDURE singleline_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
	IF THIS.SingleLine <> m.vNewVal
		THIS.SingleLine = m.vNewVal
		THIS.orderButtons() 
	ENDIF
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
4[END RESERVED2]
[START RESERVED3]
*activateformbutton 
*addactiveforms 
*addformbutton 
*captionassignhandler 
*checkresizebinding 
*deactivatehandler 
*gettoplevelform 
*orderbuttons 
*removeformbutton 
*resizehandler 
*resizetaskbar 
*setbuttonpicture 
*setbuttonwidthandcaption 
*singleline_assign 
_memberdata XML Metadata for customizable properties
coldcursor
lhideformonminimaze
lhideonclickifactive
lresizebinding
ncurrentline
nextraheight
nextrawidth
nlinecount
nmaxbuttonwidth
nminbuttonwidth
nscrollbarheight
nscrollbarwidth
oimage
otoplevelform
singleline
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\windows.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\windows.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
taskbar.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q509W15G
[CLASS] base_container
[CLASSLOC] base_gui.vcx
[BASECLASS] container
[OBJNAME] Cnt_windows
[PARENT] taskbar
[START PROPERTIES]
Height = 22
Left = 5
Name = "Cnt_windows"
Top = 3
Width = 200
ZOrderSet = 1
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q7074B35
[CLASS] optiongroup
[BASECLASS] optiongroup
[OBJNAME] opg_windows
[PARENT] taskbar.Cnt_windows
[START PROPERTIES]
Anchor = 15
BorderStyle = 0
ButtonCount = 0
Height = 22
Left = 0
Name = "opg_windows"
Top = 0
Value = 0
Width = 182
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
WITH THIS.Parent
	THIS.Width = .Width - IIF(.Parent.SingleLine, SYSMETRIC(5), 0)

	THIS.Height = IIF(.Height < TSKB_BTN_HEIGHT, TSKB_BTN_HEIGHT, .Height)
	.Parent.nMaxButtonWidth = TSKB_BTN_MAXWIDTH
	.Parent.nMinButtonWidth = TSKB_BTN_MINWIDTH
ENDWITH
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q7078NJ6
[CLASS] base_spinner
[CLASSLOC] base_gui.vcx
[BASECLASS] spinner
[OBJNAME] spnactiveline
[PARENT] taskbar.Cnt_windows
[START PROPERTIES]
Anchor = 8
BorderStyle = 0
Height = 22
Increment =  -1.00
KeyboardHighValue = 1
KeyboardLowValue = 1
Left = 183
Name = "spnactiveline"
SpinnerHighValue =   1.00
SpinnerLowValue =   1.00
Top = 0
Visible = .F.
Width = 17
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
THIS.Width = SYSMETRIC(5)
THIS.Height = TSKB_BTN_HEIGHT
THIS.Left = THIS.Parent.Width - THIS.Width
ENDPROC
PROCEDURE InteractiveChange
THIS.Parent.Parent.nCurrentLine = THIS.Value

WITH THIS.Parent.opg_windows
	IF .Top <> -((.Parent.nCurrentLine - 1) * TSKB_BTN_HEIGHT + (.Parent.nCurrentLine - 1))
		.Top = -((.Parent.nCurrentLine - 1) * TSKB_BTN_HEIGHT + (.Parent.nCurrentLine - 1))
	ENDIF

	THIS.ToolTipText = "Line " + TRANSFORM(.Parent.nCurrentLine) + " / " + TRANSFORM(.Parent.nLineCount)
	.ToolTipText = THIS.ToolTipText
	THIS.SelStart = 0
	THIS.SelLength = 1
ENDWITH
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] taskbar
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QC0DCWHS
[CLASS] custom
[BASECLASS] custom
[OBJNAME] tasklist
[START PROPERTIES]

Name = "tasklist"
Width = 20
_memberdata =      679<VFPData><memberdata name="cusername" type="property" display="cUserName"/><memberdata name="lactive" type="property" display="lActive"/><memberdata name="lstorestatewindows" type="property" display="lStoreStateWindows"/><memberdata name="ctaskdesktoppicture" type="property" display="cTaskDesktopPicture"/><memberdata name="cuserpassword" type="property" display="cUserPassword"/><memberdata name="cdbschema" type="property" display="cDBSchema"/><memberdata name="nidsession" type="property" display="nIdSession"/><memberdata name="cstorepassword" type="property" display="cStorePassword"/><memberdata name="lstorepassword" type="property" display="lStorePassword"/></VFPData>
nidsession = 
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
*!*	Custom::AddObject("Vars", "cstVars")
THIS.AddObject("oVars", "cstVars")
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
_memberdata XML Metadata for customizable properties
nidsession
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] tasklist
[EOF]
