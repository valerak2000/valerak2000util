SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RH30Y2QJB
[CLASS] sfmenubase
[CLASSLOC] sfmenu.vcx
[BASECLASS] collection
[OBJNAME] sfbar
[START PROPERTIES]

</VFPData>
<memberdata name="addbar" type="method" display="AddBar"/>
<memberdata name="addbars" type="method" display="AddBars"/>
<memberdata name="addseparatorbar" type="method" display="AddSeparatorBar"/>
<memberdata name="allow" type="method" display="Allow" favorites="True"/>
<memberdata name="cactiveformmethod" type="property" display="cActiveFormMethod" favorites="True"/>
<memberdata name="cappobjectmethod" type="property" display="cAppObjectMethod" favorites="True"/>
<memberdata name="cappobjectname" type="property" display="cAppObjectName"/>
<memberdata name="cbarposition" type="property" display="cBarPosition"/>
<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
<memberdata name="cinstancename" type="property" display="cInstanceName"/>
<memberdata name="ckey" type="property" display="cKey" favorites="True"/>
<memberdata name="ckeytext" type="property" display="cKeyText" favorites="True"/>
<memberdata name="click" type="method" display="Click" favorites="True"/>
<memberdata name="cmenuclauses" type="property" display="cMenuClauses" favorites="True"/>
<memberdata name="cmrubarclass" type="property" display="cMRUBarClass"/>
<memberdata name="cmrubarlibrary" type="property" display="cMRUBarLibrary"/>
<memberdata name="conclickcommand" type="property" display="cOnClickCommand" favorites="True"/>
<memberdata name="cpicturefile" type="property" display="cPictureFile" favorites="True"/>
<memberdata name="cpictureresource" type="property" display="cPictureResource" favorites="True"/>
<memberdata name="cpopupname" type="property" display="cPopupName"/>
<memberdata name="cpopupnamethis" type="property" display="cPopupNameThis"/>
<memberdata name="cskipfor" type="property" display="cSkipFor" favorites="True"/>
<memberdata name="cstatusbartext" type="property" display="cStatusBarText" favorites="True"/>
<memberdata name="csystembar" type="property" display="cSystemBar" favorites="True"/>
<memberdata name="define" type="method" display="Define"/>
<memberdata name="evaluatevisible" type="method" display="EvaluateVisible" favorites="True"/>
<memberdata name="findbarposition" type="method" display="FindBarPosition"/>
<memberdata name="hide" type="method" display="Hide"/>
<memberdata name="init" type="event" favorites="True"/>
<memberdata name="ldefined" type="property" display="lDefined"/>
<memberdata name="lenabled" type="property" display="lEnabled"/>
<memberdata name="linvert" type="property" display="lInvert"/>
<memberdata name="lmarked" type="property" display="lMarked"/>
<memberdata name="lmarked_assign" type="method" display="lMarked_Assign"/>
<memberdata name="lmru" type="property" display="lMRU"/>
<memberdata name="lspecified" type="property" display="lSpecified"/>
<memberdata name="lvisible" type="property" display="lVisible"/>
<memberdata name="lvisible_assign" type="method" display="lVisible_Assign"/>
<memberdata name="nbarnumber" type="property" display="nBarNumber"/>
<memberdata name="nseparatorbarcount" type="property" display="nSeparatorBarCount"/>
<memberdata name="oimplementation" type="property" display="oImplementation"/>
<memberdata name="oimplementation_assign" type="method" display="oImplementation_Assign"/>
<memberdata name="oparent" type="property" display="oParent"/>
<memberdata name="refresh" type="method" display="Refresh"/>
<memberdata name="setenabled" type="method" display="SetEnabled"/>
<memberdata name="setvisible" type="method" display="SetVisible"/>
<memberdata name="show" type="method" display="Show"/>
Name = "sfbar"
_memberdata =     3536<VFPData>
cactiveformmethod = 
cappobjectmethod = 
cappobjectname = oApp
cbarposition = 
ccaption = 
cinstancename = 
ckey = 
ckeytext = 
cmenuclauses = 
cmrubarclass = SFMRUBar
cmrubarlibrary = SFMenu.vcx
conclickcommand = 
cpicturefile = 
cpictureresource = 
cpopupname = 
cpopupnamethis = 
cskipfor = not This.Allow()
cstatusbartext = 
csystembar = 
ldefined = .F.
lenabled = .T.
linvert = .F.
lmarked = .F.
lmru = .F.
lspecified = .F.
lvisible = .T.
nbarnumber = 0
nseparatorbarcount = 0
oimplementation = .NULL.
oparent = .NULL.
[END PROPERTIES]
[START PROTECTED]
addbars
cpopupname
cpopupnamethis
define
evaluatevisible
findbarposition
ldefined
lspecified
nseparatorbarcount
[END PROTECTED]
[START METHODS]
PROCEDURE Init
lparameters tnBarNumber, ;
	tcPopupName, ;
	tcName, ;
	tlSpecified
with This
	.nBarNumber = tnBarNumber
	.cPopupName = tcPopupName
	.lSpecified = tlSpecified
	.lVisible   = .EvaluateVisible()

* If a name was specified, use it.

	if vartype(tcName) = 'C' and not empty(tcName)
		.Name = tcName
	endif vartype(tcName) = 'C' ...

* Define the popup for this bar.

	if empty(.cPopupNameThis)
		.cPopupNameThis = .Name
	endif empty(.cPopupNameThis)
endwith

ENDPROC
PROCEDURE addbar
lparameters tcClass, ;
	tcLibrary, ;
	tcName, ;
	tnBarNumber
local lnBarNumber, ;
	llSpecified, ;
	loBar
with This

* Create a bar number if one wasn't passed.

	if vartype(tnBarNumber) = 'N' and tnBarNumber <> 0
		lnBarNumber = tnBarNumber
		llSpecified = .T.
	else
		lnBarNumber = .Count + 1
	endif vartype(tnBarNumber) = 'N' ...

* Create the object as a member.

	if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
		loBar = createobject(tcClass, lnBarNumber, .cPopupNameThis, tcName, ;
			llSpecified)
	else
		loBar = newobject(tcClass, tcLibrary, '', lnBarNumber, ;
			.cPopupNameThis, tcName, llSpecified)
	endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
	loBar.oParent = This
	.AddProperty(tcName, loBar)

* Add the bar to the collection.

	.Add(loBar, tcName)
endwith
return loBar

ENDPROC
PROCEDURE addbars
* Abstract method

ENDPROC
PROCEDURE addseparatorbar
local lcName, ;
	loBar
with This
	.nSeparatorBarCount = .nSeparatorBarCount + 1
	lcName = 'Separator' + transform(.nSeparatorBarCount)
	loBar  = .AddBar('SFSeparatorBar', 'SFMenu.vcx', lcName)
endwith
return loBar

ENDPROC
PROCEDURE allow
* Abstract method

ENDPROC
PROCEDURE click
local lcMethod, ;
	lnPos, ;
	lcPadPath, ;
	lcBarPath, ;
	lcCommand
with This
	do case

* We have an implementation object, so call its Execute method.

		case vartype(.oImplementation) = 'O'
			.oImplementation.Execute()

* If a method of the application object was specified, call it.

		case not empty(.cAppObjectMethod)
			lcMethod = .cAppObjectMethod
			lnPos    = at('(', lcMethod)
			if lnPos > 0
				lcMethod = left(lcMethod, lnPos - 1)
			endif lnPos > 0
			if type(.cAppObjectName + '.Name') = 'C' and ;
				pemstatus(evaluate(.cAppObjectName), lcMethod, 5)
				evaluate(.cAppObjectName + '.' + .cAppObjectMethod + ;
					iif(lnPos = 0, '()', ''))
			endif type(.cAppObjectName + '.Name') = 'C' ...

* If a method of the active form was specified, call it.

		case not empty(.cActiveFormMethod)
			lcMethod = .cActiveFormMethod
			lnPos    = at('(', lcMethod)
			if lnPos > 0
				lcMethod = left(lcMethod, lnPos - 1)
			endif lnPos > 0
			if type('_screen.ActiveForm.Name') = 'C' and ;
				pemstatus(_screen.ActiveForm, lcMethod, 5)
				evaluate('_screen.ActiveForm.' + .cActiveFormMethod + ;
					iif(lnPos = 0, '()', ''))
			endif type('_screen.ActiveForm.Name') = 'C' ...

* If an command to execute was specified, call it.

		case not empty(.cOnClickCommand)
			lcPadPath = .oParent.cInstanceName + '.'
			lcBarPath = lcPadPath + .Name + '.'
			lcCommand = strtran(strtran(.cOnClickCommand, 'This.oParent.', ;
				lcPadPath), 'This.', lcBarPath)
			if chr(13) $ lcCommand
				execscript(lcCommand)
			else
				&lcCommand
			endif chr(13) $ lcCommand
	endcase
endwith

ENDPROC
PROCEDURE define
local lcPopupName, ;
	lcPadPath, ;
	lcBarPath, ;
	llSystemBar, ;
	lcBarNumber, ;
	lcSkipFor, ;
	lcBarPosition, ;
	lcBarName, ;
	lnI, ;
	loBar, ;
	lnBar, ;
	lcClauses, ;
	lcPopupNameThis
with This
	if vartype(.oParent) = 'O'
		lcPopupName    = .cPopupName
		lcPadPath      = .oParent.cInstanceName + '.'
		.cInstanceName = lcPadPath + .Name
		lcBarPath      = .cInstanceName + '.'

* Get the bar number based on whether we're a system bar or not.

		if empty(.cSystemBar)
			lcBarNumber = transform(.nBarNumber)
		else
			lcBarNumber = transform(evaluate(.cSystemBar))
			llSystemBar = .T.
		endif empty(.cSystemBar)

* Create a default status bar text if we don't have one.

		if empty(.cStatusBarText)
			.cStatusBarText = strtran(strtran(.cCaption, '\<'), '\')
		endif empty(.cStatusBarText)

* Set the SKIP FOR for the bar.

		lcSkipFor = 'not ' + lcBarPath + 'lEnabled'
		if not empty(.cSkipFor)
			lcSkipFor = lcSkipFor + ' or ' + ;
				strtran(strtran(.cSkipFor, 'This.oParent.', lcPadPath), ;
					'This.', lcBarPath)
		endif not empty(.cSkipFor)

* If a bar position has been defined, it may have been defined by bar name
* rather than number, so get the appropriate bar number.

		lcBarPosition = ''
		if not empty(.cBarPosition)
			lcBarName = alltrim(upper(substr(.cBarPosition, 7)))
			if val(lcBarName) = 0
				for lnI = 1 to .nBarNumber - 1
					loBar = .oParent.Item(lnI)
					do case
						case not upper(loBar.Name) == lcBarName
						case empty(loBar.cSystemBar)
							lcBarPosition = trim(left(.cBarPosition, 6)) + ;
								' ' + transform(loBar.nBarNumber)
							exit
						otherwise
							lcBarPosition = trim(left(.cBarPosition, 6)) + ;
								' ' + transform(evaluate(loBar.cSystemBar))
							exit
					endcase
				next lnI
			else
				lcBarPosition = .cBarPosition
			endif val(lcBarName) = 0

* If the bar position wasn't defined, see if there's another bar in our
* position. If so, we'll use the BEFORE clause to put ourselves before that
* one. This is needed, for example, if you refresh a bar; it's removed from the
* menu, then readded. Without the BEFORE clause, it would be added to the end
* because we define popups with the RELATIVE clause.

		else
			try
				lnBar = getbar(lcPopupName, .nBarNumber)
			catch
				lnBar = .nBarNumber
			endtry
			if lnBar <> .nBarNumber
				lcBarPosition = 'before ' + transform(lnBar)
			endif lnBar <> .nBarNumber
		endif not empty(.cBarPosition)

* Set the other clauses of the DEFINE BAR command.

		lcClauses = .cMenuClauses + iif(empty(.cMenuClauses), '', ' ') + ;
			lcBarPosition
		if not empty(.cKey)
			lcClauses = lcClauses + ' key ' + .cKey + ", '" + .cKeyText + "'"
		endif not empty(.cKey)
		if .lInvert
			lcClauses = lcClauses + ' invert'
		endif .lInvert
		do case
			case not empty(.cPictureResource)
				lcClauses = lcClauses + ' pictres ' + .cPictureResource
			case not empty(.cPicturefile)
				lcClauses = lcClauses + " picture '" + .cPicturefile + "'"
			case not empty(.cSystemBar)
				lcClauses = lcClauses + ' pictres ' + .cSystemBar
		endcase

* Define the bar.

		define bar &lcBarNumber of &lcPopupName prompt .cCaption ;
			message .cStatusBarText skip for &lcSkipFor &lcClauses

* Mark the bar if it's supposed to be.

		if .lMarked
			set mark of bar &lcBarNumber of &lcPopupName to .T.
		endif .lMarked

* If this isn't a system bar, call the Click method when the bar's selected.

		if not llSystemBar
			on selection bar &lcBarNumber of &lcPopupName &lcBarPath.Click()
		endif not llSystemBar

* If we have any bars in our submenu, create the popup for it.

		if .Count > 0
			lcPopupNameThis = .cPopupNameThis
			define popup (.cPopupNameThis) margin relative shadow ;
				color scheme 4
			on bar &lcBarNumber of &lcPopupName activate popup &lcPopupNameThis

* Now add bars to the submenu.

			.AddBars()

* If this is an MRU submenu, add an MRU bar at the end.

			if .lMRU
				.AddBar(.cMRUBarClass, .cMRUBarLibrary, 'MRUBar')
			endif .lMRU
		endif .Count > 0

* Flag that the menu bar has been defined.

		.lDefined = .T.
	endif vartype(.oParent) = 'O'
endwith

ENDPROC
PROCEDURE evaluatevisible
* Abstract method.

return .T.

ENDPROC
PROCEDURE findbarposition
local lnBar, ;
	loBar, ;
	lcBarNumber, ;
	llFoundBar
with This

* We'll only do this if we don't already have a bar position.

	if empty(.cBarPosition)

* See if there are any bars before this one that are currently visible.

		for lnBar = .nBarNumber - 1 to 1 step -1
			loBar = .oParent.Item(lnBar)
			if vartype(loBar) = 'O' and loBar.lVisible
				if empty(loBar.cSystemBar)
					lcBarNumber = transform(loBar.nBarNumber)
				else
					lcBarNumber = transform(evaluate(loBar.cSystemBar))
				endif empty(loBar.cSystemBar)
				.cBarPosition = 'after ' + lcBarNumber
				llFoundBar    = .T.
				exit
			endif vartype(loBar) = 'O' ...
		next lnBar

* If we haven't found a bar to place this one after, see if there's one we can
* place this before.

		if not llFoundBar
			for lnBar = .nBarNumber + 1 to .oParent.Count
				loBar = .oParent.Item(lnBar)
				if vartype(loBar) = 'O' and loBar.lVisible
					if empty(loBar.cSystemBar)
						lcBarNumber = transform(loBar.nBarNumber)
					else
						lcBarNumber = transform(evaluate(loBar.cSystemBar))
					endif empty(loBar.cSystemBar)
					.cBarPosition = 'before ' + lcBarNumber
					exit
				endif vartype(loBar) = 'O' ...
			next lnBar
		endif not llFoundBar
	endif empty(.cBarPosition)
endwith

ENDPROC
PROCEDURE hide
local lnI, ;
	lcBarNumber, ;
	lcPopupName, ;
	lcPopupNameThis
with This
	if .lDefined

* Hide any bars in the submenu if there is one.

		for lnI = 1 to .Count
			loBar = .Item(lnI)
			loBar.Hide()
		next lnI

* Hide the bar by releasing it.

		if empty(.cSystemBar)
			lcBarNumber = transform(.nBarNumber)
		else
			lcBarNumber = transform(evaluate(.cSystemBar))
		endif empty(.cSystemBar)
		lcPopupName = .cPopupName
		release bar &lcBarNumber of &lcPopupName
	endif .lDefined

* Release our submenu popup if it exists.

	lcPopupNameThis = .cPopupNameThis
	if popup(lcPopupNameThis)
		release popup &lcPopupNameThis
	endif popup(lcPopupNameThis)
	.lDefined = .F.
endwith

ENDPROC
PROCEDURE lmarked_assign
lparameters tlValue
local lcSetting, ;
	lcBarNumber, ;
	lcPopupName
with This
	assert vartype(tlValue) = 'L'
	lcSetting = iif(tlValue, '.T.', '.F.')
	.lMarked  = tlValue
	if empty(.cSystemBar)
		lcBarNumber = transform(.nBarNumber)
	else
		lcBarNumber = transform(evaluate(.cSystemBar))
	endif empty(.cSystemBar)
	lcPopupname = .cPopupName
	set mark of bar &lcBarNumber of &lcPopupName to &lcSetting
endwith

ENDPROC
PROCEDURE lvisible_assign
lparameters tlValue
assert vartype(tlValue) = 'L'
with This
	if tlValue <> .lVisible
		.lVisible   = tlValue
		.lSpecified = .T.	&& so when we show it, it appears in correct place
		do case
			case .CalledFromThisClass()
			case tlValue
				.Show()
			otherwise
				.Hide()
		endcase
	endif tlValue <> .lVisible
endwith

ENDPROC
PROCEDURE oimplementation_assign
* Set a reference to an implementation object and bind to changes to its
* lVisible and lEnabled properties.

lparameters toObject
if vartype(toObject) = 'O'
	This.oImplementation = toObject
	bindevent(This.oImplementation, 'lVisible', This, 'SetVisible', 1)
	bindevent(This.oImplementation, 'lEnabled', This, 'SetEnabled', 1)
endif vartype(toObject) = 'O'

ENDPROC
PROCEDURE refresh
* Refresh the bar by hiding it, re-evaluating lVisible, and showing it again.

with This
	.Hide()
	.lVisible = .EvaluateVisible()
	.Show()
endwith

ENDPROC
PROCEDURE releasemembers
* Hide the bar by releasing it and nuke our own parent reference.

local lnI, ;
	loBar
This.Hide()
dodefault()
This.oParent = .NULL.

* Unbind from and nuke our implementation object.

if vartype(This.oImplementation) = 'O'
	unbindevents(This.oImplementation)
	This.oImplementation = .NULL.
endif vartype(This.oImplementation) = 'O'

ENDPROC
PROCEDURE setenabled
if vartype(This.oImplementation) = 'O'
	This.lEnabled = This.oImplementation.lEnabled
endif vartype(This.oImplementation) = 'O'

ENDPROC
PROCEDURE setvisible
if vartype(This.oImplementation) = 'O'
	This.lVisible = This.oImplementation.lVisible
endif vartype(This.oImplementation) = 'O'

ENDPROC
PROCEDURE show
* If we're supposed to, call FindBarPosition to see where the bar should go,
* then define it.

local lnI, ;
	loBar
with This
	if .lVisible and not .lDefined
		if .lSpecified or .lInvert
			.FindBarPosition()
		endif .lSpecified ...
		.Define()
	endif .lVisible ...

* Display any bars in our submenu if there is one.

	for lnI = 1 to .Count
		loBar = .Item(lnI)
		if loBar.lInvert
			loBar.Hide()
		else
			loBar.Show()
		endif loBar.lInvert
	next lnI
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addbar Adds a bar to the submenu popup for this bar
*addbars Add bars to the submenu popup for this bar
*addseparatorbar Adds a separator bar to the submenu popup for this bar
*allow Determine if the bar is enabled
*click Called when the bar is chosen
*define Defines the bar
*evaluatevisible Determines if the bar is visible or not
*findbarposition Finds where the bar should be placed
*hide Hides the bar
*lmarked_assign 
*lvisible_assign 
*oimplementation_assign 
*refresh Refreshes the bar
*setenabled Sets the Enabled property to the match the implementation object's
*setvisible Sets the Visible property to the match the implementation object's
*show Displays the bar
cactiveformmethod The method of the active form to execute
cappobjectmethod The method of the application object to execute
cappobjectname The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
cbarposition A "before" or "after" bar number clause
ccaption The caption for the bar
cinstancename The complete object path to this object starting from the menu object
ckey The hotkey for the bar
ckeytext The text for the hotkey
cmenuclauses Other clauses for bar
cmrubarclass The class to use for the MRU bar
cmrubarlibrary The library containing the class specified in cMRUBarClass
conclickcommand The command to execute when the bar is clicked
cpicturefile The file name for the picture to use
cpictureresource The system menu bar name for the picture to use
cpopupname The name of the popup this bar belongs to
cpopupnamethis The name of the popup this bar uses for submenus
cskipfor The SKIP FOR clause for the bar
cstatusbartext The text displayed in the status bar when this bar is highlighted
csystembar The name of the VFP system menu bar if this is one of those
ldefined .T. if the menu bar for this object has been defined
lenabled .T. if the bar is enabled
linvert .T. to make this an inverted bar
lmarked .T. if the bar is marked
lmru .T. to add an MRU bar at the bottom of the submenu
lspecified .T. if the bar number is specified at a certain position
lvisible .T. if the bar should be visible
nbarnumber The number of the bar
nseparatorbarcount The number of separator bars in the menu
oimplementation A reference to an implementation object
oparent A reference to the parent for this bar
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
A bar in a popup[END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfbar

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0BV0ZPMU6
[CLASS] sfpad
[CLASSLOC] sfmenu.vcx
[BASECLASS] collection
[OBJNAME] sfeditpad
[START PROPERTIES]
Name = "sfeditpad"
ccaption = \<Edit
ckey = ALT+E
cpopupname = _medit
cstatusbartext = Edit text
[END PROPERTIES]
[START METHODS]
PROCEDURE addbars
with This
	.AddBar('SFBar', 'SFMenu.vcx', 'EditUndo')
	with .EditUndo
		.cCaption       = '\<Undo'
		.cKey           = 'CTRL+Z'
		.cKeyText       = 'Ctrl+Z'
		.cStatusBarText = 'Reverse the most recent edit action'
		.cSystemBar     = '_med_undo'
		.cPictureFile   = 'undoxpsmall.bmp'
	endwith

	.AddBar('SFBar', 'SFMenu.vcx', 'EditRedo')
	with .EditRedo
		.cCaption       = '\<Redo'
		.cKey           = 'CTRL+R'
		.cKeyText       = 'Ctrl+R'
		.cStatusBarText = 'Repeat the action previously reversed with Undo'
		.cSystemBar     = '_med_redo'
		.cPictureFile   = 'redoxpsmall.bmp'
	endwith

	.AddSeparatorBar()

	.AddBar('SFBar', 'SFMenu.vcx', 'EditCut')
	with .EditCut
		.cCaption       = 'Cu\<t'
		.cKey           = 'CTRL+X'
		.cKeyText       = 'Ctrl+X'
		.cStatusBarText = 'Remove the selection and put it on the clipboard'
		.cSystemBar     = '_med_cut'
		.cPictureFile   = 'cutxpsmall.bmp'
	endwith

	.AddBar('SFBar', 'SFMenu.vcx', 'EditCopy')
	with .EditCopy
		.cCaption       = '\<Copy'
		.cKey           = 'CTRL+C'
		.cKeyText       = 'Ctrl+C'
		.cStatusBarText = 'Copy the selection and put it on the clipboard'
		.cSystemBar     = '_med_copy'
		.cPictureFile   = 'copyxpsmall.bmp'
	endwith

	.AddBar('SFBar', 'SFMenu.vcx', 'EditPaste')
	with .EditPaste
		.cCaption       = '\<Paste'
		.cKey           = 'CTRL+V'
		.cKeyText       = 'Ctrl+V'
		.cStatusBarText = 'Paste the contents of the clipboard at the ' + ;
			'insertion point'
		.cSystemBar     = '_med_paste'
		.cPictureFile   = 'pastexpsmall.bmp'
	endwith

	.AddBar('SFBar', 'SFMenu.vcx', 'EditClear')
	with .EditClear
		.cCaption       = 'Clear'
		.cStatusBarText = 'Erase the selection'
		.cSystemBar     = '_med_clear'
		.cSkipFor       = 'empty(wontop())'
	endwith

	.AddSeparatorBar()

	.AddBar('SFBar', 'SFMenu.vcx', 'EditSelectAll')
	with .EditSelectAll
		.cCaption       = 'Select \<All'
		.cKey           = 'CTRL+A'
		.cKeyText       = 'Ctrl+A'
		.cStatusBarText = 'Select all lines of text in the current field'
		.cSystemBar     = '_med_slcta'
	endwith
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfeditpad

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0BW10OOOG
[CLASS] sfbar
[CLASSLOC] sfmenu.vcx
[BASECLASS] collection
[OBJNAME] sfhelptopicsbar
[START PROPERTIES]
Name = "sfhelptopicsbar"
ccaption = \<Help Topics
ckey = F1
ckeytext = F1
cpicturefile = helpxpsmall.bmp
cstatusbartext = Display Help table of contents
csystembar = _mst_hpsch
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfhelptopicsbar

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _REP01S9BY
[CLASS] sfmenubase
[CLASSLOC] sfmenu.vcx
[BASECLASS] collection
[OBJNAME] sfmenu
[START PROPERTIES]

</VFPData>
<memberdata name="addpad" type="method" display="AddPad"/>
<memberdata name="cformname" type="property" display="cFormName"/>
<memberdata name="cinstancename" type="property" display="cInstanceName"/>
<memberdata name="cinstancename_assign" type="method" display="cInstanceName_Assign"/>
<memberdata name="cmenuname" type="property" display="cMenuName"/>
<memberdata name="definemenu" type="method" display="DefineMenu"/>
<memberdata name="refresh" type="method" display="Refresh"/>
<memberdata name="show" type="method" display="Show"/>
Name = "sfmenu"
_memberdata =      559<VFPData>
cformname = 
cinstancename = 
cmenuname = _msysmenu
[END PROPERTIES]
[START PROTECTED]
definemenu
[END PROTECTED]
[START METHODS]
PROCEDURE Init
* Save the name of the variable or property we're being instantiated into in
* cInstanceName. We need this so we can reference the object path from a bar
* all the way up to the menu properly.

lparameter tcInstanceName
This.cInstanceName = tcInstanceName

ENDPROC
PROCEDURE addpad
lparameters tcClass, ;
	tcLibrary, ;
	tcName
local loPad, ;
	lnCount, ;
	loOtherPad
with This

* Add a pad of the desired class and name to the menu.

	if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
		loPad = createobject(tcClass, tcName)
	else
		loPad = newobject(tcClass, tcLibrary, '', tcName)
	endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
	loPad.oParent = This
	.AddProperty(tcName, loPad)

* Add the pad to the collection.

	.Add(loPad, tcName)
	lnCount = .Count
	do case

* If this is the second item in the menu, tell the first item to display BEFORE
* this item and this item to display AFTER that item.

		case lnCount = 2
			loOtherPad = .Item(1)
			loOtherPad.cPadPosition = 'before ' + tcName
			loPad.cPadPosition = 'after ' + loOtherPad.Name

* If there are more than 2 items in the menu, this item will be displayed AFTER
* the previous one.

		case lnCount > 2
			loOtherPad = .Item(lnCount - 1)
			loPad.cPadPosition = 'after ' + loOtherPad.Name
	endcase
endwith
return loPad

ENDPROC
PROCEDURE cinstancename_assign
lparameters tuValue
if This.CalledFromThisClass()
	This.cInstanceName = tuValue
else
	error 1743, 'cInstanceName'
endif This.CalledFromThisClass()

ENDPROC
PROCEDURE definemenu
* Abstract method

ENDPROC
PROCEDURE refresh
* Refresh the menu by refreshing all pads and then activating it.

local lnI
with This
	for lnI = 1 to .Count
		loPad = .Item(lnI)
		loPad.Refresh()
	next lnI
	activate menu (.cMenuName) nowait
endwith

ENDPROC
PROCEDURE releasemembers
* Clean up the menu. 

dodefault()
set sysmenu automatic
set sysmenu off
set sysmenu to
set sysmenu to default
set sysmenu on

ENDPROC
PROCEDURE show
local lnI, ;
	loPad
with This

* If we're putting the menu in a top-level form, set cMenuName and define the
* menu in the specified form. Otherwise, clear the old menu.

	if empty(.cFormName) 
    	set sysmenu to
	else 
		if .cMenuName = '_msysmenu'
			.cMenuName = sys(2015)
		endif .cMenuName = '_msysmenu'
		define menu (.cMenuName) bar in (.cFormName)
	endif empty(.cFormName) 

* Define the menu if it hasn't already been.

	if .Count = 0
		.DefineMenu()
	endif .Count = 0

* Show all the pads.

	for lnI = 1 to .Count
		loPad = .Item(lnI)
		loPad.Show()
	next lnI

* Display the menu.

	set sysmenu automatic
	activate menu (.cMenuName) nowait
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addpad Adds a pad to the menu
*cinstancename_assign 
*definemenu Defines the desired pads in the menu
*refresh Refreshes the display of the menu.
*show Displays the menu.
cformname The name of a top-level form for the menu to be placed into
cinstancename The name of the variable containing the reference for this object
cmenuname The name of the menu
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
A menu[END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfmenu

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q40ZEW1M
[CLASS] collection
[BASECLASS] collection
[OBJNAME] sfmenubase
[START PROPERTIES]

</VFPData>
<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
<memberdata name="cleanup" type="method" display="Cleanup"/>
<memberdata name="cversion" type="property" display="cVersion"/>
<memberdata name="lrelease" type="property" display="lRelease"/>
<memberdata name="release" type="method" display="Release"/>
<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
Height = 23
Name = "sfmenubase"
Width = 23
_memberdata =      433<VFPData>
cversion = 2008.02.07
lrelease = .F.
[END PROPERTIES]
[START PROTECTED]
calledfromthisclass
cleanup
lrelease
releasemembers
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
* Cleanup as the object is destroyed.

This.Cleanup()

ENDPROC
PROCEDURE Error
lparameters tnError, ;
	tcMethod, ;
	tnLine
local lnError, ;
	lcMethod, ;
	lnLine, ;
	lcSource, ;
	laError[1], ;
	lcName, ;
	lcOrigMethod, ;
	lcError, ;
	lcReturn, ;
	lcMessage, ;
	lnChoice

* Use AERROR() to get information about the error. If we have an Exception
* object in oException, get information about the error from it.

lnError  = tnError
lcMethod = tcMethod
lnLine   = tnLine
lcSource = message(1)
aerror(laError)
with This
	if vartype(.oException) = 'O'
		lnError     = .oException.ErrorNo
		lcMethod    = .oException.Procedure
		lnLine      = .oException.LineNo
		lcSource    = .oException.LineContents
		laError[1]  = .oException.ErrorNo
		laError[2]  = .oException.Message
		laError[3]  = .oException.Details
		.oException = .NULL.
	endif vartype(.oException) = 'O'
endwith

* Determine which method of which object the error occurred in. If the error
* occurred in a child object, the method may already have our name on it, so
* handle that.

lcName   = upper(This.Name) + '.'
lcMethod = upper(tcMethod)
if lcMethod = lcName or '.' + lcName $ lcMethod
	lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
else
	lcOrigMethod = tcMethod
endif lcMethod = lcName ...
lcMethod = This.Name + '.' + lcOrigMethod

* A global error handler is in effect, so let's pass the error on to it.
* Replace certain parameters passed to the error handler (the name of the
* program, the error number, the line number, the message, and SYS(2018)) with
* the appropriate values.

if not empty(on('ERROR'))
	lcError = upper(on('ERROR'))
	lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
	lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
	lcError = strtran(lcError, ',ERROR()',  ',lnError')
	lcError = strtran(lcError, ' ERROR()',  ' lnError')
	lcError = strtran(lcError, 'LINENO()',  'lnLine')
	lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
	lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')

* If the error handler is called with DO, macro expand it and assume the return
* value is "CONTINUE". If the error handler is called as a function (such as an
* object method), call it and grab the return value if there is one.

	if left(lcError, 3) = 'DO ' or '=' $ lcError
		&lcError
		lcReturn = 'Continue'
	else
		lcReturn = &lcError
	endif left(lcError, 3) = 'DO ' ...

* Display a generic dialog box with an option to display the debugger (this
* should only occur in a test environment).

else
	lcSource  = message(1)
	lcMessage = 'Error #: ' + transform(lnError) + chr(13) + ;
		'Message: ' + laError[2] + chr(13) + ;
		iif(empty(lcSource), '', 'Code: ' + lcSource + chr(13)) + ;
		iif(lnLine = 0, '', 'Line #: ' + transform(lnLine) + chr(13)) + ;
		'Method: ' + lcMethod
	if version(2) = 0
		lnChoice = messagebox(lcMessage + chr(13) + chr(13) + ;
			'Choose OK to continue or Cancel to cancel execution', 17, ;
			_VFP.Caption)
	else
		lnChoice = messagebox(lcMessage + chr(13) + chr(13) + ;
			'Choose Yes to display the debugger, No to continue ' + ;
			'without the debugger, or Cancel to cancel execution', 19, ;
			_VFP.Caption)
	endif version(2) = 0
	do case
		case lnChoice = 6
			lcReturn = 'Debug'
		case lnChoice = 2
			lcReturn = 'Cancel'
	endcase
endif not empty(on('ERROR'))

* Ensure the return message is acceptable. If not, assume "CONTINUE".

lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
	not lcReturn $ 'Continue,Retry,Cancel,Debug', 'Continue', lcReturn)

* Handle the return value.

do case

* It wasn't our error, so pass it back to the calling method.

	case '.' $ lcOrigMethod
		return lcReturn

* Display the debugger.

	case lcReturn = 'Debug'
		debug
		if wexist('Visual FoxPro Debugger')
			keyboard '{SHIFT+F7}' plain
		endif wexist('Visual FoxPro Debugger')
		suspend

* Retry the command.

	case lcReturn = 'Retry'
		retry

* Cancel execution.

	case lcReturn = 'Cancel'
		cancel

* Go to the line of code following the error.

	otherwise
		return
endcase

ENDPROC
PROCEDURE calledfromthisclass
local lnLevel, ;
	lcProgram, ;
	lcObject, ;
	loParent, ;
	laClasses[1], ;
	lnClasses, ;
	lnI, ;
	llReturn, ;
	lcThisName

* Get the name of the program that called us, and get the object name from it.
* Set loParent to our parent if there is one.

lnLevel   = program(-1)
lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)

* Check our class hierarchy to see if we were called from ourselves or an
* ancester method.

lnClasses = aclass(laClasses, This)
for lnI = 1 to lnClasses
	if lcObject == upper(laClasses[lnI])
		llReturn = .T.
		exit
	endif lcObject == upper(laClasses[lnI])
next lnI

* If we didn't come from ourselves or an ancestor and we have a parent, our
* name may not match our class, so check the containership hierarchy.

if not llReturn and not isnull(loParent)
	lcThisName = This.Name
	do while vartype(loParent) = 'O'
		lcThisName = loParent.Name + '.' + lcThisName
		loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
			.NULL.)
	enddo while vartype(loParent) = 'O'
	llReturn = upper(lcObject) == upper(lcThisName)
endif not llReturn ...
return llReturn

ENDPROC
PROCEDURE cleanup
* Perform cleanup tasks. Note the avoidance of "with This" in this code to
* prevent potential problems with dangling object references.

if This.lRelease
	return
endif This.lRelease
This.lRelease = .T.
This.ReleaseMembers()

ENDPROC
PROCEDURE release
* Release the object. Note the avoidance of "with This" in this code to prevent
* potential problems with dangling object references.

if This.lRelease
	return
endif This.lRelease
This.Cleanup()
release This

ENDPROC
PROCEDURE releasemembers
* Release each member so our reference in it is nuked.

local lnI, ;
	loControl
for lnI = This.Count to 1 step -1
	loControl = This.Item(lnI)
	loControl.Release()
next lnI

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*calledfromthisclass Return .T. if the method was called from this class
*cleanup Performs clean up task when the object is destroyed
*release Releases this object
*releasemembers Releases all member objects
_memberdata XML Metadata for customizable properties
cversion The release date in the form YYYY.MM.DD
lrelease .T. if the object is in the process of being destroyed
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfmenubase

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q411CW6I
[CLASS] custom
[BASECLASS] custom
[OBJNAME] sfmenufunction
[START PROPERTIES]

</VFPData>
<memberdata name="execute" type="method" display="Execute"/>
<memberdata name="lenabled" type="property" display="lEnabled"/>
<memberdata name="lvisible" type="property" display="lVisible"/>
Name = "sfmenufunction"
Width = 17
_memberdata =      212<VFPData>
lenabled = .T.
lvisible = .T.
[END PROPERTIES]
[START METHODS]
PROCEDURE execute
* Abstract method

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*execute Performs the action of a menu or toolbar function
_memberdata XML Metadata for customizable properties
lenabled .T. if the menu or toolbar item is enabled
lvisible .T. if the menu or toolbar item is visible
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfmenufunction

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0E90N5ZCH
[CLASS] sfbar
[CLASSLOC] sfmenu.vcx
[BASECLASS] collection
[OBJNAME] sfmrubar
[START PROPERTIES]
Name = "sfmrubar"
cmenuclauses = mru
conclickcommand = This.oParent.MRUSelected()
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfmrubar

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RFG0VX57W
[CLASS] sfmenubase
[CLASSLOC] sfmenu.vcx
[BASECLASS] collection
[OBJNAME] sfpad
[START PROPERTIES]

</VFPData>
<memberdata name="addbar" type="method" display="AddBar"/>
<memberdata name="addbars" type="method" display="AddBars" favorites="True"/>
<memberdata name="addseparatorbar" type="method" display="AddSeparatorBar"/>
<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
<memberdata name="cinstancename" type="property" display="cInstanceName"/>
<memberdata name="ckey" type="property" display="cKey" favorites="True"/>
<memberdata name="cmrubarclass" type="property" display="cMRUBarClass"/>
<memberdata name="cmrubarlibrary" type="property" display="cMRUBarLibrary"/>
<memberdata name="cpadposition" type="property" display="cPadPosition"/>
<memberdata name="cpopupname" type="property" display="cPopupName"/>
<memberdata name="cskipfor" type="property" display="cSkipFor" favorites="True"/>
<memberdata name="cstatusbartext" type="property" display="cStatusBarText" favorites="True"/>
<memberdata name="define" type="method" display="Define"/>
<memberdata name="definepad" type="method" display="DefinePad"/>
<memberdata name="definepopup" type="method" display="DefinePopup"/>
<memberdata name="hide" type="method" display="Hide"/>
<memberdata name="init" type="event" favorites="True"/>
<memberdata name="ldefined" type="property" display="lDefined"/>
<memberdata name="lmru" type="property" display="lMRU" favorites="True"/>
<memberdata name="lpaddefined" type="property" display="lPadDefined"/>
<memberdata name="lvisible" type="property" display="lVisible"/>
<memberdata name="lvisible_assign" type="method" display="lVisible_Assign"/>
<memberdata name="mruselected" type="method" display="MRUSelected"/>
<memberdata name="nseparatorbarcount" type="property" display="nSeparatorBarCount"/>
<memberdata name="oparent" type="property" display="oParent"/>
<memberdata name="refresh" type="method" display="Refresh"/>
<memberdata name="show" type="method" display="Show"/>
Name = "sfpad"
_memberdata =     1923<VFPData>
ccaption = 
cinstancename = 
ckey = 
cmrubarclass = SFMRUBar
cmrubarlibrary = SFMenu.vcx
cpadposition = 
cpopupname = 
cskipfor = 
cstatusbartext = 
ldefined = .F.
lmru = .F.
lpaddefined = .F.
lvisible = .T.
nseparatorbarcount = 0
oparent = .NULL.
[END PROPERTIES]
[START PROTECTED]
addbars
cpopupname
define
definepad
definepopup
ldefined
lpaddefined
nseparatorbarcount
[END PROTECTED]
[START METHODS]
PROCEDURE Init
* Define the popup for this pad if it wasn't already.

lparameters tcName
with This
	if vartype(tcName) = 'C' and not empty(tcName)
		.Name = tcName
	endif vartype(tcName) = 'C' ...
	if empty(.cPopupName)
		.cPopupName = .Name
	endif empty(.cPopupName)
endwith

ENDPROC
PROCEDURE addbar
lparameters tcClass, ;
	tcLibrary, ;
	tcName, ;
	tnBarNumber
local lnBarNumber, ;
	llSpecified, ;
	loBar
with This

* Create a bar number if one wasn't passed.

	if vartype(tnBarNumber) = 'N' and tnBarNumber <> 0
		lnBarNumber = tnBarNumber
		llSpecified = .T.
	else
		lnBarNumber = .Count + 1
	endif vartype(tnBarNumber) = 'N' ...

* Create the object as a member.

	if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
		loBar = createobject(tcClass, lnBarNumber, .cPopupName, tcName, ;
			llSpecified)
	else
		loBar = newobject(tcClass, tcLibrary, '', lnBarNumber, .cPopupName, ;
			tcName, llSpecified)
	endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
	loBar.oParent = This
	.AddProperty(tcName, loBar)

* Add the bar to the collection.

	.Add(loBar, tcName)
endwith
return loBar

ENDPROC
PROCEDURE addbars
* Abstract method

ENDPROC
PROCEDURE addseparatorbar
local lcName, ;
	loBar
with This
	.nSeparatorBarCount = .nSeparatorBarCount + 1
	lcName = 'Separator' + transform(.nSeparatorBarCount)
	loBar  = .AddBar('SFSeparatorBar', 'SFMenu.vcx', lcName)
endwith
return loBar

ENDPROC
PROCEDURE define
with This

* Get the object path and the names of the pad, menu, and popup.

	.cInstanceName = .oParent.cInstanceName + '.' + .Name

* Create a default status bar text if we don't have one.

	if empty(.cStatusBarText)
		.cStatusBarText = strtran(strtran(.cCaption, '\<'), '\')
	endif empty(.cStatusBarText)

* Define the pad and popup if necessary, then add bars to the popup.

	if not .lPadDefined
		.DefinePopup()
		.DefinePad()
	endif not .lPadDefined
	.AddBars()

* If this is an MRU menu, add an MRU bar at the end.

	if .lMRU
		.AddBar(.cMRUBarClass, .cMRUBarLibrary, 'MRUBar')
	endif .lMRU

* Flag that the pad and popup have been defined.

	.lDefined = .T.
endwith

ENDPROC
PROCEDURE definepad
* Define the pad.

local lcObjectPath, ;
	lcPadName, ;
	lcPopupName, ;
	lcPosition, ;
	lcSkipFor, ;
	lcClauses
with This
	lcObjectPath = .cInstanceName + '.'
	lcPadName    = .Name
	lcPopupName  = .cPopupName
	lcPosition   = alltrim(.cPadPosition)

* Set the SKIP FOR for the pad.

	if empty(.cSkipFor)
		lcSkipFor = ''
	else
		lcSkipFor = 'skip for ' + strtran(.cSkipFor, 'This.', lcObjectPath)
	endif not empty(.cSkipFor)

* Set the key clauses of the DEFINE PAD command.

	lcClauses = ''
	if not empty(.cKey)
		lcClauses = lcClauses + ' key ' + strtran(.cKey, '"', "'")
	endif not empty(.cKey)

* Define the pad.

	define pad &lcPadName of (.oParent.cMenuName) prompt .cCaption ;
		color scheme 3 &lcPosition &lcSkipFor message .cStatusBarText ;
		negotiate left, right &lcClauses
	on pad &lcPadName of (.oParent.cMenuName) activate popup &lcPopupName

* Flag that the pad has been defined.

	.lPadDefined = .T.
endwith

ENDPROC
PROCEDURE definepopup
define popup (This.cPopupName) margin relative shadow color scheme 4

ENDPROC
PROCEDURE hide
* Hide the pad by releasing it and its popup.

local lcPadName, ;
	lcPopupName
with This
	.lVisible    = .F.
	.lPadDefined = .F.
	lcPadName    = .Name
	lcPopupName = .cPopupName
	release pad &lcPadName of (.oParent.cMenuName)
	release popup &lcPopupName
endwith

ENDPROC
PROCEDURE lvisible_assign
lparameters tlValue
assert vartype(tlValue) = 'L'
with This
	if tlValue <> .lVisible
		.lVisible = tlValue
		do case
			case .CalledFromThisClass()
			case tlValue
				.Show()
			otherwise
				.Hide()
		endcase
	endif tlValue <> .lVisible
endwith

ENDPROC
PROCEDURE mruselected
local lnI, ;
	loBar, ;
	lcPopupName
with This

* Hide the MRU bar, then show all inverted bars.

	.MRUBar.Hide()
	for lnI = 1 to .Count
		loBar = .Item(lnI)
		if loBar.lInvert
			loBar.Show()
		endif loBar.lInvert
	next lnI

* Display the popup again.

	lcPopupName = .cPopupName
	activate popup &lcPopupName

* Now that the popup is closed, show the MRU bar and hide all inverted bars.

	.MRUBar.Show()
	for lnI = 1 to .Count
		loBar = .Item(lnI)
		if loBar.lInvert
			loBar.Hide()
		endif loBar.lInvert
	next lnI
endwith

ENDPROC
PROCEDURE refresh
* Refresh the pad by releasing and redefining the popup and refreshing each
* bar.

with This
	.Hide()
	.DefinePopup()
	.DefinePad()
	for lnI = 1 to .Count
		loBar = .Item(lnI)
		loBar.Refresh()
	next lnI
endwith

ENDPROC
PROCEDURE releasemembers
* Hide the pad and nuke our own parent reference.

local lcPopupName, ;
	lnI, ;
	loBar
This.Hide()
lcPopupName = This.cPopupName
if popup(lcPopupName)
	release popup &lcPopupName
endif popup(lcPopupName)
dodefault()
This.oParent = .NULL.

ENDPROC
PROCEDURE show
* Define the popup and show all bars (except inverted bars, which must be
* hidden).

local lnI, ;
	loBar
with This
	do case

* If the pad has never been defined, call Define.

		case not .lDefined
			.Define()

* If the pad has been defined but then released, call DefinePopup and
* DefinePad.

		case not .lPadDefined
			.DefinePopup()
			.DefinePad()
	endcase
	for lnI = 1 to .Count
		loBar = .Item(lnI)
		if loBar.lInvert
			loBar.Hide()
		else
			loBar.Show()
		endif loBar.lInvert
	next lnI
endwith

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addbar Adds a bar to the popup for this pad
*addbars Add bars to the popup attached to this pad
*addseparatorbar Adds a separator bar to the menu
*define Defines the pad
*definepad Define the pad
*definepopup Defines the popup for the pad
*hide Hide the pad
*lvisible_assign 
*mruselected Called when the MRU bar is clicked
*refresh Refreshes the pad
*show Shows the pad
ccaption The caption for the menu pad
cinstancename The complete object path to this object starting from the menu object
ckey The hotkey for the pad
cmrubarclass The class to use for the MRU bar
cmrubarlibrary The library containing the class specified in cMRUBarClass
cpadposition Optional 'before' or 'after' pad clause to use in defining the pad's location on the menu
cpopupname The name of the popup attached to this pad
cskipfor The logical expression used for the SKIP FOR clause
cstatusbartext Text displayed in the status bar when this pad is highlighted
ldefined .T. if the pad and popup for this object have been defined
lmru .T. to add an MRU bar at the bottom of the menu
lpaddefined .T. if the pad has been defined
lvisible .T. if the pad is visible
nseparatorbarcount The number of separator bars in the menu
oparent A reference to the parent for this pad
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
A pad in a menu[END RESERVED7]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfpad

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0BW0YPJKX
[CLASS] sfbar
[CLASSLOC] sfmenu.vcx
[BASECLASS] collection
[OBJNAME] sfseparatorbar
[START PROPERTIES]
Name = "sfseparatorbar"
ccaption = \-
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] sfseparatorbar
[EOF]
