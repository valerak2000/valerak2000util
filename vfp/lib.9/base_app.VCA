SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1251

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0IM287
[CLASS] base_form
[CLASSLOC] base_gui.vcx
[BASECLASS] form
[OBJNAME] _calendar
[START PROPERTIES]
AlwaysOnTop = .T.
BackColor = 255,255,255
BorderStyle = 2
Caption = " ‡ÎÂÌ‰‡¸"
DoCreate = .T.
Height = 457
Icon = ..\bmp\calendar.ico
Left = 0
Name = "_calendar"
Picture = ..\bmp\calendar.gif
TitleBar = 0
Top = 0
Width = 725
ncalendar = 0
saveset.Name = "saveset"
[END PROPERTIES]
[START METHODS]
PROCEDURE Activate
THIS.cntTitleband.lEnabled=.T.
DODEFAULT()
ENDPROC
PROCEDURE Deactivate
THIS.cntTitleband.lEnabled=.F.
DODEFAULT()
ENDPROC
PROCEDURE Init
LPARAMETERS toForm AS Object, tcAlias AS String, tnIdRecord AS Integer
LOCAL loButton AS Object
	* œŒƒÕ¿—“–Œ»Ã »ÕŒ–ŒƒÕŒ≈ “≈ÀŒ
	WITH THIS.oleCalendar
		* —“¿–“Œ¬¿ﬂ ƒ¿“¿ (¬€ƒ≈À≈Õ¿ —≈–€Ã ÷¬≈“ŒÃ)
		.Object.Value=DATE()
		* Œ“—“”œ —¬≈–’”
		.Top=THIS.cntTitleBand.Height
	ENDWITH
	* ¬Œ——“¿ÕŒ¬»Ã œŒÀ‹«Œ¬¿“≈À‹— ”ﬁ Õ¿—“–Œ… ” ¬»ƒ¿  ¿À≈Õƒ¿–ﬂ
	THIS.nCalendar=3
	loButton=GETPEM(THIS.cntTitleband, "cmd"+TRANSFORM(THIS.nCalendar))
	m.loButton.Click()

	DODEFAULT()
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
3[END RESERVED2]
[START RESERVED3]
ncalendar
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\calendar.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\calendar.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0KD7KR
[CLASS] cnttitleband
[CLASSLOC] base_gui.vcx
[BASECLASS] container
[OBJNAME] cntTitleband
[PARENT] _calendar
[START PROPERTIES]
Height = 18
ImageGradient.Name = "ImageGradient"
LBLTITLE.Caption = "  ‡ÎÂÌ‰‡¸"
LBLTITLE.Name = "LBLTITLE"
Name = "cntTitleband"
chkOnTop.Alignment = 0
chkOnTop.Name = "chkOnTop"
cmd1.Caption = "1"
cmd1.Name = "cmd1"
cmd1.ToolTipText = "ÃÂÒˇˆ"
cmd2.Caption = "3"
cmd2.Name = "cmd2"
cmd2.ToolTipText = " ‚‡Ú‡Î"
cmd3.Caption = "6"
cmd3.Name = "cmd3"
cmd3.ToolTipText = "œÓÎ„Ó‰‡"
cmdClose.Name = "cmdClose"
[END PROPERTIES]
[START METHODS]
PROCEDURE cmd1.Click
THISFORM.LockScreen=.T.

WITH THISFORM
	IF THIS.VisualEffect=0
		THIS.VisualEffect=2

		.oleCalendar.MonthColumns=1
		.oleCalendar.MonthRows=1
		.oleCalendar.Left=0
		.Height=172
		.Width=161
		.nCalendar=1
	ELSE
		THIS.VisualEffect=0
		.oleCalendar.MonthColumns=4
		.oleCalendar.MonthRows=3
		.oleCalendar.Left=.nLeftIndent
		.Height=457
		.Width=662+.nLeftIndent
		.nCalendar=0
	ENDIF
ENDWITH

WITH THIS.Parent
	.Width=THISFORM.Width
	.cmd2.VisualEffect=0
	.cmd3.VisualEffect=0
ENDWITH

THISFORM.LockScreen=.F.
ENDPROC
PROCEDURE cmd2.Click
THISFORM.LockScreen=.T.

WITH THISFORM
	IF THIS.VisualEffect=0
		THIS.VisualEffect=2
		.oleCalendar.MonthColumns=3
		.oleCalendar.MonthRows=1
		.oleCalendar.Left=0
		.Height=172
		.Width=495
		.nCalendar=2
	ELSE
		THIS.VisualEffect=0
		.oleCalendar.MonthColumns=4
		.oleCalendar.MonthRows=3
		.oleCalendar.Left=.nLeftIndent
		.Height=457
		.Width=662+.nLeftIndent
		.nCalendar=0
	ENDIF
ENDWITH

WITH THIS.Parent
	.Width=THISFORM.Width
	.cmd2.VisualEffect=0
	.cmd3.VisualEffect=0
ENDWITH

THISFORM.LockScreen=.F.
ENDPROC
PROCEDURE cmd3.Click
THISFORM.LockScreen=.T.

WITH THISFORM
	IF THIS.VisualEffect=0
		THIS.VisualEffect=2
		.oleCalendar.MonthColumns=3
		.oleCalendar.MonthRows=2
		.oleCalendar.Left=0
		.Height=315
		.Width=495
		.nCalendar=3
	ELSE
		THIS.VisualEffect=0
		.oleCalendar.MonthColumns=4
		.oleCalendar.MonthRows=3
		.oleCalendar.Left=.nLeftIndent
		.Height=457
		.Width=662+.nLeftIndent
		.nCalendar=0
	ENDIF
ENDWITH

WITH THIS.Parent
	.Width=THISFORM.Width
	.cmd2.VisualEffect=0
	.cmd3.VisualEffect=0
ENDWITH

THISFORM.LockScreen=.F.
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0IVNKR
[CLASS] olecalendar
[CLASSLOC] base_gui.vcx
[BASECLASS] olecontrol
[OBJNAME] Olecalendar
[PARENT] _calendar
[START PROPERTIES]
Height = 457
Left = 63
Name = "Olecalendar"
Top = 19
Width = 662
[END PROPERTIES]
[START METHODS]
PROCEDURE KeyPress
*** ActiveX Control Event ***
LPARAMETERS tnKeyCode
	IF m.tnKeyCode=27
		KEYBOARD '{ESC}'
	ENDIF
ENDPROC
[END METHODS]
[BINSTART OLE]
CHECKSUM=59953
[BINEND OLE]
[BINSTART OLE2]
CHECKSUM=5725
[BINEND OLE2]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] _calendar
[START PROPERTIES]
MS Sans Serif, 0, 8, 5, 13, 11, 11, 2, 0
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0ARL59
[CLASS] base_form
[CLASSLOC] base_gui.vcx
[BASECLASS] form
[OBJNAME] _clock
[START PROPERTIES]
AlwaysOnTop = .T.
BorderStyle = 0
Caption = "◊‡Ò˚"
Comment = "Design 640x480=632x295 800x600=792x415 1024x768=1016x583 –‡ÁÏÂ˚ ˝ÚÓÈ ÙÓÏ˚ 630ı288 Ë Í‡ÚÌ˚ 9"
DoCreate = .T.
Height = 144
Left = 0
Name = "_clock"
TitleBar = 0
Top = 0
Width = 144
dbcontainer.Name = "dbcontainer"
ohour = 
ominute = 
osecond = 
saveset_form.Name = "saveset_form"
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
LOCAL lnDiameter AS Integer, lnRegionHandle AS Integer
	DODEFAULT()
	* ƒ»¿Ã≈“≈–  –”√¿
	lnDiameter=MIN(THIS.Width, THIS.Height)
	* Œœ–≈ƒ≈À»Ã ’›ÕƒÀ  –”√Œ¬Œ… Œ¡À¿—“» Õ¿ ‘Œ–Ã≈
	lnRegionHandle=m.goApp.oWinAPI.CreateEllipticRgn(0, 0, m.lnDiameter, m.lnDiameter)
	* œŒœ€“¿≈Ã—ﬂ Œ√–¿Õ»◊»“‹ Œ¡À¿—“‹ ¬€¬Œƒ¿  –”√ŒÃ
	IF m.lnRegionHandle<>0
		m.goApp.oWinAPI.SetWindowRgn(THIS.HWnd, m.lnRegionHandle)
	ENDIF
ENDPROC
PROCEDURE addhmsobject
*  Œ–≈Õ‹ ¬ Õ¿«¬¿Õ»» Œ¡⁄≈ “¿-—“–≈À », –¿ƒ»”— —“–≈À », “ŒÀŸ»Õ¿ —“–≈À », ÷¬≈“ —“–≈À »
* .AddHMSObject('SEC', lnRadius, 1, COLOR_RED)
LPARAMETERS tcRoot AS String, tnRadius AS Integer, tnWidth AS Integer, tnColor AS Integer
LOCAL lnCount AS Integer, lnSinus AS Integer, lnCosinus AS Integer, lcName AS String, loLine AS Object
	lnLeft=THIS.cntClock.Width/2
	lnTop=THIS.cntClock.Height/2

	FOR lnCount=0 TO 59
		lnSinus=m.tnRadius*SIN(DTOR(6*m.lnCount))
		lnCosinus=m.tnRadius*COS(DTOR(6*m.lnCount))
		lcName="lin"+m.tcRoot+TRANSFORM(m.lnCount, "@L 99")

		THIS.cntClock.AddObject(m.lcName, 'Line')
		loLine=GETPEM(THIS.cntClock, m.lcName)

		WITH m.loLine AS Line
			.BorderWidth=m.tnWidth
			.BorderColor=m.tnColor

			DO CASE
			CASE BETWEEN(m.lnCount, 0, 14)
				.LineSlant	= '/'
				.Left		= m.lnLeft
				.Top		= m.lnTop-m.lnCosinus
				.Width		= m.lnSinus
				.Height		= m.lnCosinus
			CASE BETWEEN(m.lnCount, 15, 29)
				.LineSlant	= '\'
				.Left		= m.lnLeft
				.Top		= m.lnTop
				.Width		= m.lnSinus
				.Height		= -m.lnCosinus
			CASE BETWEEN(m.lnCount, 30, 44)
				.LineSlant	= '/'
				.Left		= m.lnLeft+m.lnSinus
				.Top		= m.lnTop
				.Width		= -m.lnSinus
				.Height		= -m.lnCosinus
			CASE BETWEEN(m.lnCount, 45, 59)
				.LineSlant	= '\'
				.Left		= m.lnLeft+m.lnSinus
				.Top		= m.lnTop-m.lnCosinus
				.Width		= -m.lnSinus
				.Height		= m.lnCosinus
			ENDCASE
		ENDWITH
	ENDFOR
ENDPROC
PROCEDURE showtime
LPARAMETERS tlFirstExecute AS Logical
LOCAL lnHour AS Integer, loHour AS Object, loMinute AS Object, loSecond AS Object
	* ¬€◊»—À»Ã ——€À » Õ¿ ÕŒ¬€≈ Œ¡⁄≈ “€
	lnHour=SECONDS()/60/60
	lnHour=IIF(m.lnHour>12, m.lnHour-12, m.lnHour)
	lnHour=FLOOR(5*m.lnHour)	&& 0-59
	loHour=GETPEM(THIS.cntClock, "linHOUR"+TRANSFORM(m.lnHour, "@L 99"))
	loMinute=GETPEM(THIS.cntClock, "linMIN"+SUBSTR(TIME(), 4, 2))
	loSecond=GETPEM(THIS.cntClock, "linSEC"+RIGHT(TIME(), 2))
	* — –Œ≈Ã —“¿–€≈ » œŒ ¿∆≈Ã ÕŒ¬€≈ Œ¡⁄≈ “€
	WITH THIS
		IF m.tlFirstExecute
			.oHour=m.loHour
			.oMinute=m.loMinute

			STORE .T. TO loHour.Visible, loMinute.Visible
		ELSE
			IF .oHour<>m.loHour
				.oHour.Visible=.F.
				.oHour=m.loHour
				.oHour.Visible=.T.
			ENDIF

			IF .oMinute<>m.loMinute
				.oMinute.Visible=.F.
				.oMinute=m.loMinute
				.oMinute.Visible=.T.
			ENDIF

			.oSecond.Visible=.F.
		ENDIF

		.oSecond=m.loSecond
		.oSecond.Visible=.T.
	ENDWITH
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
6[END RESERVED2]
[START RESERVED3]
*addhmsobject 
*showtime 
ohour
ominute
osecond
[END RESERVED3]
[START RESERVED4]
..\bmp\clock.ico[END RESERVED4]
[START RESERVED5]
..\bmp\clock.ico[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0GYLNY
[CLASS] commonbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdClose
[PARENT] _clock
[START PROPERTIES]
Anchor = 0
Caption = ""
Height = 18
Left = 63
Name = "cmdClose"
Picture = ..\bmp\release.bmp
Top = 63
Width = 18
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
THISFORM.Release()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0G4W7V
[CLASS] base_container
[CLASSLOC] base_gui.vcx
[BASECLASS] container
[OBJNAME] cntClock
[PARENT] _clock
[START PROPERTIES]
Anchor = 768
BackStyle = 0
Height = 144
Left = 0
Name = "cntClock"
Top = 0
Width = 144
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
LOCAL lnRadius as Integer
	DODEFAULT()

	WITH THIS
		* ”¡≈–≈Ã –¿Ã ” –≈—¿…«»Õ√¿
		.BorderWidth=0
		* Œ“Ã¿—ÿ“¿¡»–”≈Ã  ¿–“»Õ ”
		WITH .imgClock
			.Width=THIS.Width
			.Height=THIS.Height
			.Anchor=1+2+4+8
		ENDWITH
		* Ã¿ —»Ã¿À‹Õ€… –¿ƒ»”— —≈ ”ÕƒÕŒ… —“–≈À »
		lnRadius=MIN(.Height/2, .Width/2)
		*  Œ–≈Õ‹ ¬ Õ¿«¬¿Õ»», –¿ƒ»”—, “ŒÀŸ»Õ¿, ÷¬≈“
		THISFORM.AddHMSObject("HOUR", 0.5*m.lnRadius, 3, COLOR_BLACK)
		THISFORM.AddHMSObject("MIN", 0.7*m.lnRadius, 2, COLOR_BLACK)
		THISFORM.AddHMSObject("SEC", 0.8*m.lnRadius, 1, COLOR_YELLOW)
		* œŒ ¿∆≈Ã —“–≈À »
		THISFORM.ShowTime(.T.)
		* «¿œ”—“»Ã “¿…Ã≈–
		.tmrClock.Enabled=.T.
	ENDWITH
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0GO6N0
[CLASS] base_image
[CLASSLOC] base_gui.vcx
[BASECLASS] image
[OBJNAME] ImgClock
[PARENT] _clock.cntClock
[START PROPERTIES]
Height = 81
Left = 0
Name = "ImgClock"
Picture = ..\bmp\clock.gif
Stretch = 2
Top = 0
Width = 81
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0GQMXF
[CLASS] base_timer
[CLASSLOC] base_gui.vcx
[BASECLASS] timer
[OBJNAME] tmrClock
[PARENT] _clock.cntClock
[START PROPERTIES]
Interval = 1000
Left = 72
Name = "tmrClock"
Top = 108
[END PROPERTIES]
[START METHODS]
PROCEDURE Timer
* œ≈–≈ƒ¬»Õ≈Ã —“–≈À »
THISFORM.ShowTime()
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0GT3GF
[CLASS] base_shape
[CLASSLOC] base_gui.vcx
[BASECLASS] shape
[OBJNAME] shpClock
[PARENT] _clock
[START PROPERTIES]
BackStyle = 0
BorderStyle = 0
Height = 144
Name = "shpClock"
SpecialEffect = 0
Width = 144
[END PROPERTIES]
[START METHODS]
PROCEDURE MouseDown
* Œ–√¿Õ»«”≈Ã œ≈–≈“¿— »¬¿Õ»≈ ‘Œ–Ã€
LPARAMETERS tnButton, tnShift, tnXCoord, tnYCoord
	DO CASE
	CASE m.tnButton=1	&& Left Button
		m.goApp.oWinApi.ReleaseCapture()
		m.goApp.oWinApi.SendMessage(THISFORM.HWnd, WM_SYSCOMMAND, SC_MOVE+HTCAPTION, 0)

		NODEFAULT
	OTHERWISE
		DODEFAULT(m.tnButton, m.tnShift, m.tnXCoord, m.tnYCoord)
	ENDCASE
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] _clock
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RY07WLOI
[CLASS] base_form_szgr
[CLASSLOC] base_gui.vcx
[BASECLASS] form
[OBJNAME] _messages
[START PROPERTIES]

Caption = "—ÔËÒÓÍ ÒÓÓ·˘ÂÌËÈ"
DoCreate = .T.
Dockable = 1
HalfHeightCaption = .T.
Height = 250
Icon = ..\bmp\user_headset.ico
Left = 0
MinHeight = 60
Name = "_messages"
ShowWindow = 0
Top = 0
Width = 375
_memberdata =      221<VFPData><memberdata name="msgtxt" type="property" display="MsgTxt"/><memberdata name="msgtxt_assign" type="method" display="MsgTxt_Assign"/><memberdata name="clearmsgtxt" type="method" display="ClearMsgTxt"/></VFPData>
dbcontainer.Enabled = .F.
dbcontainer.Name = "dbcontainer"
msgtxt =  
resizecorner.Image.Height = 16
resizecorner.Image.Name = "Image"
resizecorner.Image.Width = 16
resizecorner.Name = "resizecorner"
resizecorner.resize_timer.Name = "resize_timer"
resizecorner.tmrRefresh.Name = "tmrRefresh"
saveset_form.Name = "saveset_form"
[END PROPERTIES]
[START METHODS]
PROCEDURE AfterDock
THIS.BorderStyle = 2
ENDPROC
PROCEDURE Init
DODEFAULT()

THIS.MsgTxt = ''
THIS.Dock(3)
ENDPROC
PROCEDURE UnDock
THIS.BorderStyle = 3
ENDPROC
PROCEDURE clearmsgtxt
THIS.editboxMsg.Value = ''
THIS.editboxMsg.Refresh()
ENDPROC
PROCEDURE msgtxt_assign
LPARAMETERS tcNewVal
*To do: Modify this routine for the Assign method
	WITH THIS
		IF !EMPTY(m.tcNewVal)
			.editboxMsg.Value = .editboxMsg.Value + m.tcNewVal + CRLF
		ENDIF
		*‚ÒÚ‡Ú¸ Ì‡ ÔÓÒÎÂ‰ÌËÈ ÒËÏ‚ÓÎ
		.editboxMsg.SelStart = LENC(.editboxMsg.Value)
		.editboxMsg.Refresh()
	ENDWITH
ENDPROC
PROCEDURE saveset_form.loadset
NODEFAULT
ENDPROC
PROCEDURE saveset_form.saveset
NODEFAULT
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*clearmsgtxt 
*msgtxt_assign 
msgtxt
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RY0822RE
[CLASS] base_editbox
[CLASSLOC] base_gui.vcx
[BASECLASS] editbox
[OBJNAME] editboxMsg
[PARENT] _messages
[START PROPERTIES]
Anchor = 15
BackStyle = 0
Height = 236
HideSelection = .F.
Left = 5
Name = "editboxMsg"
NullDisplay = " "
ReadOnly = .T.
Top = 5
Width = 362
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] _messages
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Z210IUUY
[CLASS] aboutbox
[CLASSLOC] aboutbox.vcx
[BASECLASS] form
[OBJNAME] about_app
[START PROPERTIES]
Applications_pageframe.Base_Page1.Name = "Base_Page1"
Applications_pageframe.Base_Page1.imgLogo.Name = "imgLogo"
Applications_pageframe.Base_Page1.lblAppName.Name = "lblAppName"
Applications_pageframe.Base_Page1.lblCopyright.Name = "lblCopyright"
Applications_pageframe.Base_Page1.lblLicense.Name = "lblLicense"
Applications_pageframe.Base_Page1.lblTrademark.Name = "lblTrademark"
Applications_pageframe.Base_Page1.lblUserCorp.Caption = "GNU"
Applications_pageframe.Base_Page1.lblUserCorp.Name = "lblUserCorp"
Applications_pageframe.Base_Page1.lblUserName.Name = "lblUserName"
Applications_pageframe.Base_Page1.lblVersion.Name = "lblVersion"
Applications_pageframe.Base_Page1.shpRectangle.Name = "shpRectangle"
Applications_pageframe.Base_Page2.Name = "Base_Page2"
Applications_pageframe.ErasePage = .T.
Applications_pageframe.Name = "Applications_pageframe"
DoCreate = .T.
Name = "about_app"
cmdOK.Left = 273
cmdOK.Name = "cmdOK"
cmdOK.Top = 260
cmdSysInfo.Name = "cmdSysInfo"
dbcontainer.Name = "dbcontainer"
registry.Name = "registry"
resizecorner.Image.Height = 16
resizecorner.Image.Name = "Image"
resizecorner.Image.Width = 16
resizecorner.Name = "resizecorner"
resizecorner.resize_timer.Name = "resize_timer"
resizecorner.tmrRefresh.Name = "tmrRefresh"
saveset_form.Name = "saveset_form"
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
LPARAMETERS tcAppName, tcVersion, tcCopyright, tcTrademark, tcLogoBMP
LOCAL lnElem, lcVer
LOCAL ARRAY laFile[1]
	lnElem = AGETFILEVERSION(laFile, m.goApp.oVars.cAppExeName)
	
	IF m.lnElem > 0
		lcVer = laFile(4)
	ELSE
		lcVer = 'Not found EXE!'
	ENDIF
	
	DODEFAULT(m.goApp.oVars.cTaskCaption + CHR(169), m.lcVer, "All Rights Reserved", "Copyright" + CHR(169) + " 2004-2009  ÓÁÎËÚËÌ ¬.¿.", "..\bmp\infernus.gif")
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] about_app
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1S01C6OH8
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] activitybar
[START PROPERTIES]
Enabled = .F.
Height = 44
Left = 0
Name = "activitybar"
Top = 0
Width = 48
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1S01CED89
[CLASS] base_image
[CLASSLOC] base_gui.vcx
[BASECLASS] image
[OBJNAME] status_anim
[PARENT] activitybar
[START PROPERTIES]
Height = 38
Left = 5
Name = "status_anim"
Picture = ..\bmp\trafficlight_off.ico
Stretch = 2
ToolTipText = "»Ì‰ËÍ‡ÚÓ Á‡ÔÓÒÓ‚ Í ÒÂ‚ÂÛ"
Top = 3
Width = 38
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] activitybar

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1OL10ND6W
[CLASS] container
[BASECLASS] container
[OBJNAME] base_app
[START PROPERTIES]

Height = 97
Name = "base_app"
Width = 135
_memberdata =     4199<VFPData><memberdata name="goform" type="Method" display="goForm" favorites="True"/><memberdata name="go" type="Method" display="go" favorites="True"/><memberdata name="ctaskcaption" type="property" display="cTaskCaption"/><memberdata name="cappcurpaths" type="property" display="cAppCurPaths"/><memberdata name="cappname" type="property" display="cAppName"/><memberdata name="closeallwindows" type="method" display="CloseAllWindows"/><memberdata name="ctaskcaption_assign" type="method" display="cTaskCaption_Assign"/><memberdata name="ctaskicon_assign" type="method" display="cTaskIcon_Assign"/><memberdata name="ctaskname" type="property" display="cTaskName"/><memberdata name="domenu" type="method" display="DoMenu"/><memberdata name="loadsettings" type="method" display="loadSettings"/><memberdata name="load_ini" type="method" display="load_Ini"/><memberdata name="savesettings" type="method" display="saveSettings"/><memberdata name="save_ini" type="method" display="save_Ini"/><memberdata name="setenvironment" type="method" display="setEnvironment"/><memberdata name="ctaskicon" type="property" display="cTaskIcon"/><memberdata name="ctaskdesktoppicture" type="property" display="cTaskDesktopPicture"/><memberdata name="ctaskdesktoppicture_assign" type="method" display="cTaskDesktopPicture_Assign"/><memberdata name="release" type="method" display="release"/><memberdata name="gomenu" type="method" display="goMenu"/><memberdata name="addwindow" type="method" display="addWindow"/><memberdata name="arraypointer" type="method" display="ArrayPointer"/><memberdata name="asavedlls" type="property" display="aSaveDlls"/><memberdata name="eventloaded" type="property" display="EventLoaded"/><memberdata name="handlewinmsg" type="method" display="handleWinMsg"/><memberdata name="lcleanalldlls" type="property" display="lCleanallDlls"/><memberdata name="loadevent" type="method" display="loadEvent"/><memberdata name="lscreenhwnd" type="property" display="lScreenHwnd"/><memberdata name="releaseevent" type="method" display="releaseEvent"/><memberdata name="removewindow" type="method" display="removeWindow"/><memberdata name="wndproc" type="property" display="Wndproc"/><memberdata name="div" type="method" display="Div"/><memberdata name="removedll" type="method" display="removeDll"/><memberdata name="showerrmsg" type="method" display="ShowErrMsg"/><memberdata name="ltaskbar" type="property" display="lTaskBar"/><memberdata name="otaskbar" type="property" display="oTaskBar"/><memberdata name="tasklist" type="property" display="TaskList"/><memberdata name="otasklist" type="property" display="oTaskList"/><memberdata name="lkeepdlls" type="property" display="lKeepDlls"/><memberdata name="cdbname" type="property" display="cDBName"/><memberdata name="cdbpath" type="property" display="cDBPath"/><memberdata name="ndbtype" type="property" display="nDBType"/><memberdata name="ocurrenttask" type="property" display="oCurrentTask"/><memberdata name="ocurrenttask_assign" type="method" display="oCurrentTask_Assign"/><memberdata name="odbconnect" type="property" display="oDBConnect"/><memberdata name="nidsession" type="property" display="nIdSession"/><memberdata name="login" type="method" display="login"/><memberdata name="logout" type="method" display="logout"/><memberdata name="schema" type="property" display="Schema"/><memberdata name="otoolbar" type="property" display="oToolBar"/><memberdata name="checkmenu" type="method" display="CheckMenu"/><memberdata name="onmenuevents" type="method" display="onMenuEvents"/><memberdata name="showmsg" type="method" display="showMsg"/><memberdata name="timeterminate" type="property" display="TimeTerminate"/><memberdata name="ndatasessionid" type="property" display="nDataSessionId"/><memberdata name="ltoolbar" type="property" display="lToolBar"/><memberdata name="cappexename" type="property" display="cAppExeName"/><memberdata name="vars" type="property" display="Vars"/><memberdata name="createmenu" type="method" display="CreateMenu"/><memberdata name="lstorepassword" type="property" display="lStorePassword"/><memberdata name="stop" type="method" display="stop"/><memberdata name="goproc" type="method" display="goProc"/></VFPData>
ndatasessionid = 0
otaskbar = .NULL.
otoolbar = .NULL.
[END PROPERTIES]
[START PROTECTED]
ActiveControl^
AddProperty^
Anchor^
BackColor^
BackStyle^
BorderColor^
BorderWidth^
ColorSource^
ControlCount^
Controls^
DblClick^
DragDrop^
DragIcon^
DragMode^
DragOver^
Drag^
Draw^
ForeColor^
GotFocus^
LostFocus^
MiddleClick^
MouseDown^
MouseEnter^
MouseIcon^
MouseLeave^
MouseMove^
MousePointer^
MouseUp^
MouseWheel^
Move^
Moved^
OLECompleteDrag^
OLEDragDrop^
OLEDragMode^
OLEDragOver^
OLEDragPicture^
OLEDrag^
OLEDropEffects^
OLEDropHasData^
OLEDropMode^
OLEGiveFeedback^
OLESetData^
OLEStartDrag^
Picture^
Refresh^
Resize^
RightClick^
SetFocus^
SpecialEffect^
StatusBarText^
Style^
ndatasessionid^
[END PROTECTED]
[START METHODS]
PROCEDURE AddObject
LPARAMETERS toForms as Form
	IF VARTYPE(m.toForms) = 'O' AND m.toForms.BaseClass == "Form"
		THIS.oApp_collection.Add(m.toForms)
	ENDIF

	NODEFAULT
ENDPROC
PROCEDURE Destroy
THIS.Release()
ENDPROC
PROCEDURE Init
LPARAMETERS tcNameApp, tcCaption, tcIcon, tcCurPaths
LOCAL loExc as Exception
	NODEFAULT
#IF !_DEVELOP_MODE
	TRY
#ENDIF
		*ÒÓÁ‰‡ÂÏ Ò‡Ï˚Â "Ò‚ÂÊËÂ" Ó·˙ÂÍÚ˚
		Container::AddObject("oVars", "cstVars")
		Container::AddObject("oMenu", "SFMenu_app", "m.goApp.oMenu")

		WITH THIS
			.oVars.cAppExeName = SYS(16, 0)

			IF !EMPTY(m.tcNameApp)
				.oVars.cAppName = ALLTRIM(m.tcNameApp)
			ENDIF

			IF EMPTY(m.tcCurPaths)
				.oVars.cAppCurPaths = SYS(5) + SYS(2003) + '\'
			ELSE
				.oVars.cAppCurPaths = ADDBS(m.tcCurPaths)
			ENDIF

			IF !EMPTY(m.tcCaption)
				.oVars.cTaskCaption = m.tcCaption
			ENDIF

			IF !EMPTY(m.tcIcon)
				.oVars.cTaskIcon = m.tcIcon
			ENDIF

			IF VARTYPE(_Screen) = 'O'
				_Screen.WindowState = 2
				_Screen.ShowTips = .T.
			ENDIF

			.oVars.lTaskBar = .T.

			.setEnvironment()
			.loadSettings()

			.nDataSessionId = SET("Datasession")

			IF .oVars.lToolBar
#IF !_DEVELOP_MODE
				TRY
#ENDIF
					.oToolBar = CREATEOBJECT("Collection")
					.oToolBar.Add(CREATEOBJECT("editbar"), "TBEdit")
					.oToolBar.Item["TBEdit"].Dock(0, 0, 0)
					.oToolBar.Item["TBEdit"].Show()

					.oToolBar.Add(CREATEOBJECT("servicebar"), "TBService")
					.oToolBar.Item["TBService"].Dock(0)
					.oToolBar.Item["TBService"].Show()

					.oToolBar.Add(CREATEOBJECT("basetuningbar"), "TBBaseTuning")
					.oToolBar.Item["TBBaseTuning"].Dock(0)
					.oToolBar.Item["TBBaseTuning"].Show()

					.oToolBar.Add(CREATEOBJECT("activitybar"), "TBActivity")
					.oToolBar.Item["TBActivity"].Dock(0)
					.oToolBar.Item["TBActivity"].Show()

					.oToolBar.Add(CREATEOBJECT("exitbar"), "TBExit")
					.oToolBar.Item["TBExit"].Dock(0)
					.oToolBar.Item["TBExit"].Show()
#IF !_DEVELOP_MODE
				CATCH TO loExc
					.oFunction.showErrMsg(m.loExc)

					.oToolBar = .NULL.
				ENDTRY
#ENDIF
			ENDIF

			IF .oVars.lTaskBar
#IF !_DEVELOP_MODE
				TRY
#ENDIF
					.oTaskBar = CREATEOBJECT("taskbar")
#IF !_DEVELOP_MODE
				CATCH TO loExc
					.oFunction.showErrMsg(m.loExc)

					.oVars.lTaskBar = .F.
					.oTaskBar = .NULL.
				ENDTRY
#ENDIF
			ENDIF
		ENDWITH
#IF !_DEVELOP_MODE
	CATCH TO loExc
		THIS.oFunction.showErrMsg(m.loExc)
	ENDTRY
#ENDIF
ENDPROC
PROCEDURE RemoveObject
LPARAMETERS toForms as Object
	IF VARTYPE(m.toForms) = 'O' AND m.toForms.BaseClass = "Form"
		LOCAL lnI as Integer

		FOR lnI = 1 TO THIS.oApp_Collection.Count
			IF THIS.oApp_Collection.Item[m.lnI] = m.toForms
				THIS.oApp_Collection.Remove(m.lnI)

				EXIT
			ENDIF
		ENDFOR
	ENDIF

	NODEFAULT
ENDPROC
PROCEDURE addwindow
LPARAMETERS thWnd as Integer
LOCAL loForm as Form, llAddFormOK as Logical
	IF m.thWnd = _VFP.hWnd
		RETURN
	ENDIF

	lAddFormOK = .F.
	*first, scan forms collection to see if hWnd is from some active form
	FOR EACH loForm IN _Screen.Forms 
		IF m.loForm.hWnd = m.thWnd
			IF !(EMPTY(m.loForm.Caption) OR INLIST(m.loForm.Caption, "Debugger",;
																	 "Watch",;
																	 "Locals",;
																	 "Trace",;
																	 "Call Stack",;
																	 "Debug Output",;
																	 "Report Preview"));
			   AND m.loForm.BaseClass == "Form"
				llAddFormOK = .T.
			ENDIF

			EXIT
		ENDIF
	ENDFOR

	IF m.llAddFormOK
		LOCAL lnI as Integer

		llAddFormOK = .F.

		WITH THIS
			FOR lnI = 1 TO .oApp_Collection.Count
				IF .oApp_Collection.Item[m.lnI] = m.loForm
					llAddFormOK = .T.

					EXIT
				ENDIF
			ENDFOR

			IF !m.llAddFormOK
				.AddObject(m.loForm)

				IF .oVars.lTaskBar			
				*ÔÂÂı‚‡Ú ÓÍÓÌÌ˚ı ÒÓ·˚ÚËÈ ÔÓÍ‡ ÚÓÎ¸ÍÓ ÂÒÎË ÌÛÊÂÌ Ú‡ÒÍ ·‡
				*‰Îˇ report ÓÍÓÌ fox Ô‡‰‡ÂÚ
*!*				BINDEVENT(m.loForm, "Release", THIS, "RemoveWindow", 0)
					BINDEVENT(m.thWnd, WM_DESTROY, THIS, "handlewinmsg", 4)
					BINDEVENT(m.thWnd, WM_SETTEXT, THIS, "handlewinmsg", 4)
					BINDEVENT(m.thWnd, WM_SETFOCUS, THIS, "handlewinmsg", 4)
*!*				BINDEVENT(m.thWnd, WM_WINDOWPOSCHANGED, THIS, "handlewinmsg", 4)
				ENDIF

				IF .oVars.lTaskBar
					.oTaskBar.addFormButton(m.loForm)
				ENDIF
			ENDIF
		ENDWITH
	ENDIF
ENDPROC
PROCEDURE go
LPARAMETERS tcUserName as String, tcUserPassword as String, tv3, tv4, tv5, tv6, tv7, tv8
LOCAL loForm as login_form OF ..\lib.9\base_app, loExc as Exception
	WITH THIS
		*ÔÓ‚ÂËÚ¸ - Á‡ÔÛ˘ÂÌ‡ ÎË Â˘Â Ó‰Ì‡ ÍÓÔËˇ?
		IF .oVars.oCurrentTask.oVars.lOnceStart AND .oWinApi.findWindow(.oVars.cTaskCaption) <> 0
			RETURN .F.
		ENDIF
		*ÔÓ‚ÂÒÚË Ë‰ÂÌÚËÙËÍ‡ˆË˛ ÔÓÎ¸ÁÓ‚‡ÚÂÎˇ
		IF !EMPTY(m.tcUserName) AND !ISNULL(.oVars.oCurrentTask)
			*ÒÓı‡ÌËÚ¸ ÎÓ„ËÌ Ë Ô‡ÓÎ¸ ÚÂÍÛ˘Û˛ Á‡‰‡˜Û
			.oVars.oCurrentTask.oVars.cUserName = ALLTRIM(m.tcUserName)
			.oVars.oCurrentTask.oVars.cUserPassword = ALLTRIM(m.tcUserPassword)
			.oVars.oCurrentTask.oVars.lStorePassword = .T.
		ENDIF

		IF .Login()
		*Û‰‡˜ÌÓ ÔÓ‰ÍÓÌÌÂÍÚËÎËÒ¸ Ë Á‡ÎÓ„ËÌËÎËÒ¸
		*ÌÂÛ‰‡˜Ì‡ˇ ÔÓÔ˚ÚÍ‡ ÔÓ‰ÍÎ˛˜ÂÌËˇ Í ·‡ÁÂ Ó·‡·‡Ú˚‚‡ÂÚÒˇ ‚ login_form, ÂÒÎË ÔÓÎ¸ÁÓ‚‡ÚÂÎ¸ Á‡‰‡Ì ÊÂÒÚÍÓ,
		*ÚÓ - ÁÌ‡˜ËÚ Ì‡ÒÚÓÂÌ ‡‚ÚÓÏ‡ÚË˜ÂÒÍËÈ Á‡ÔÛÒÍ - Ë ‚ÒÂ Ë‰ÛÚ ÎÂÒÓÏ
		*ÒÓı‡ÌËÏ ÔÓ‰ ÍÂÏ Á‡¯ÎË
			*ÒÓı‡ÌËÚ¸ Ì‡ÒÚÓÈÍË
			.saveSettings()

			IF .oVars.lToolBar
				LOCAL loObj as Object

				FOR EACH loObj IN .oToolBar
					loObj.Enabled = .T.
				ENDFOR
			ENDIF
#IF !_DEVELOP_MODE
			TRY
#ENDIF
				IF .oVars.lMenuBar AND EMPTY(m.tcUserName)
				*ÂÒÎË ‚˚Á‚‡ÎË Ò Ô‡‡ÏÂÚ‡ÏË ÚÓ ÏÂÌ˛ ÌÂ ‡ÍÚË‚ËÓ‚‡Ú¸.
					.goMenu()

					READ EVENTS
					*ÒÓı‡ÌËÚ¸ Ì‡ÒÚÓÈÍË
					.saveSettings()
				ENDIF
#IF !_DEVELOP_MODE
			CATCH TO loExc
				.oFunction.showErrMsg(m.loExc)
			ENDTRY
#ENDIF
			.logout()
		ELSE
			RETURN .F.
		ENDIF
	ENDWITH
ENDPROC
PROCEDURE goform
*‚˚ÔÓÎÌËÚ¸ ÙÓÏÛ ‚ ÂÂ ‰‡Ú‡ÒÂÒÒËË
PARAMETERS tcFormName as String, tndsid as Integer, tcFormPtr as String, tcVar as String, tvp1, tvp2, tvp3, tvp4,;
		   tvp5, tvp6, tvp7, tvp8
LOCAL lcRun as String, lnI as Integer, loExc as Exception, lvVar as Variant
PRIVATE poFormPtr as Form
#IF !_DEVELOP_MODE
	TRY
#ENDIF
		lvVar = .F.
		poFormPtr = .NULL.

*!*			lcRun = "DO FORM "+IIF(_VFP.StartMode = 0, THIS.oVars.cAppCurPaths+"\FORMS\", '')+m.tcFormName+;
*!*					IIF(!ISNULL(m.tcFormPtr), " NAME m.poFormPtr", '')+;
*!*					IIF(!ISNULL(m.tcVar), " TO m.lvVar", '')

		lcRun = "DO FORM " + m.tcFormName +;
				IIF(!ISNULL(m.tcFormPtr), " NAME m.poFormPtr", '') +;
				IIF(!ISNULL(m.tcVar), " TO m.lvVar", '')

		IF PCOUNT() > 4
			lcRun = m.lcRun+" WITH "

			FOR lnI = 1 TO PCOUNT() - 4
				lcRun = m.lcRun + "m.tvp" + LTRIM(TRANSFORM(m.lnI)) + ','
				*TRANSFORM(EVALUATE("m.tvp"+LTRIM(TRANSFORM(lnI))))+','
			ENDFOR

			lcRun = LEFT(m.lcRun, LEN(m.lcRun) - 1)
		ENDIF

		IF m.tndsid <> 0
			SET DATASESSION TO m.tndsid
		ENDIF

*!*			EXECSCRIPT(m.lcRun)
		&lcRun

*!*			lcRun = "DO FORM "+IIF(_VFP.StartMode = 0, THIS.oVars.cAppCurPaths+"\FORMS\", '')+m.tcFormName+;
*!*					IIF(!ISNULL(m.tcFormPtr), " NAME m.poFormPtr", '')+;
*!*					IIF(!ISNULL(m.tcVar), " TO m.lvVar", '')

		lcRun = "DO FORM " + m.tcFormName +;
				IIF(!ISNULL(m.tcFormPtr), " NAME m.poFormPtr", '') +;
				IIF(!ISNULL(m.tcVar), " TO m.lvVar", '')

*!*			IF !(VARTYPE(m.tvvar) = 'O' AND ISNULL(m.tvvar))
		IF VARTYPE(m.tcVar) = 'O' AND !ISNULL(m.tcVar)
			STORE m.lvVar TO (m.tcVar)
		ENDIF

		IF VARTYPE(m.tcFormPtr) = 'O' AND !ISNULL(m.tcFormPtr)
			STORE m.poFormPtr TO (m.tcFormPtr)
		ENDIF

		IF m.tndsid <> 0
			SET DATASESSION TO THIS.nDataSessionId
		ENDIF
#IF !_DEVELOP_MODE
	CATCH TO loExc
		THIS.oFunction.showErrMsg(m.loExc)
	ENDTRY
#ENDIF
ENDPROC
PROCEDURE gomenu
LOCAL loExc as Exception
	WITH THIS.oVars
		IF .lToolBar
		*‚˚ÒÚ‡‚ËÚ¸ "ÔÚË˜ÍË" Ì‡ ‡ÍÚË‚Ì˚ı ÚÛÎ·‡‡ı
*!*					*Â‰‡ÍÚËÓ‚‡ÌËÂ
*!*					SET MARK OF BAR 1 OF toolbr_pop TO .T.
*!*					*ÒÂ‚ËÒ
*!*					SET MARK OF BAR 3 OF toolbr_pop TO .T.
*!*					*Ì‡ÒÚÓÈÍË
*!*					SET MARK OF BAR 4 OF toolbr_pop TO .T.
*!*					*‡ÍÚË‚ÌÓÒÚ¸ ÒÓÂ‰ËÌÂÌËˇ
*!*					SET MARK OF BAR 6 OF toolbr_pop TO .T.

*!*					IF THIS.oVars.lTaskBar
*!*					*taskbar
*!*						SET MARK OF BAR 5 OF toolbr_pop TO .T.
*!*					ENDIF
		ENDIF

		IF .lMenuBar
			THIS.oMenu.Show()
		ENDIF
	ENDWITH
ENDPROC
PROCEDURE goproc
*‚˚ÔÓÎÌËÚ¸ ÙÛÌÍˆË˛ ‚ ÓÚ‰ÂÎ¸ÌÓÈ ‰‡Ú‡ÒÂÒÒËË
PARAMETERS tcProcName as String, tndsid as Integer, tvp1, tvp2, tvp3, tvp4, tvp5, tvp6, tvp7, tvp8
LOCAL lcRun as String, lnI as Integer, loExc as Exception, lvVar as Variant, loSession as Session
PRIVATE poFormPtr as Form
#IF !_DEVELOP_MODE
	TRY
#ENDIF
		lvVar = .F.
		lcRun = "lvVar = " + m.tcProcName + "("

		IF PCOUNT() > 2
			FOR lnI = 1 TO PCOUNT() - 2
				lcRun = m.lcRun + "m.tvp" + LTRIM(TRANSFORM(m.lnI)) + ','
			ENDFOR

			lcRun = LEFT(m.lcRun, LEN(m.lcRun) - 1)
		ENDIF

		lcRun = m.lcRun + ')'

		IF m.tndsid = 0
			loSession = NEWOBJECT("base_session", "base_session.prg")
			
			tndsid = m.loSession.DataSessionId
		ENDIF

		SET DATASESSION TO m.tndsid

*!*				EXECSCRIPT(m.lcRun)
		&lcRun

		IF m.tndsid > 0
			SET DATASESSION TO THIS.nDataSessionId
		ENDIF
#IF !_DEVELOP_MODE
	CATCH TO loExc
		THIS.oFunction.showErrMsg(m.loExc)
	ENDTRY
#ENDIF
RETURN m.lvVar
ENDPROC
PROCEDURE handlewinmsg
LPARAMETERS thWnd as Integer, tnMsg as Integer, tnwParam as Integer, tnlParam as Integer
LOCAL lnRetvalue
	lnRetvalue = 0

	WITH THIS.oVars
		DO CASE
		CASE m.tnMsg = WM_WINDOWPOSCHANGED
		*z-order change
			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)
	*!*			lhwndInsAfter = CTOBIN(SYS(2600, m.tnlParam+(4*1), 4), "4rs")

	*!*			i = THIS.FindAWindow(hWnd)
	*!*			IF i >0
	*!*				THIS.otView.nodes(i).Selected = 1
	*!*			ENDIF 
		CASE m.tnMsg = WM_SETFOCUS
		*focus
			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)

			IF .lTaskBar 
				THIS.oTaskBar.activateFormButton(m.thWnd)

				IF TYPE("_Screen.ActiveForm") = 'O' AND !ISNULL(_Screen.ActiveForm) AND _Screen.ActiveForm.WindowType = 1
				*‡ÍÚË‚Ì‡ ÏÓ‰‡Î¸Ì‡ˇ ÙÓÏ‡
					THIS.oTaskBar.Enabled = .F.
				ELSE
					THIS.oTaskBar.Enabled = .T.
				ENDIF
			ENDIF
		CASE m.tnMsg = WM_SETTEXT
		*title change
			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)

			IF .lTaskBar
				LOCAL loForm as Form

				FOR EACH loForm IN THIS.oApp_Collection
					IF m.loForm.HWnd = m.thWnd
						THIS.oTaskBar.captionAssignHandler(m.loForm)

						EXIT
					ENDIF
				ENDFOR
			ENDIF
	*!*		CASE m.tnMsg = WM_ACTIVATE
	*!*				DO CASE
	*!*				CASE m.tnwParam = WA_INACTIVE
	*!*					*Activated by some method other than a mouse click .
	*!*				CASE m.tnwParam = WA_CLICKACTIVE
	*!*					*Activated by a mouse click.
	*!*				CASE m.tnwParam = WA_INACTIVE
	*!*					*Deactivated.
	*!*				ENDCASE
		CASE m.tnMsg = WM_SHOWWINDOW
		*show
	*!*			IF m.tnwParam! = 0
			IF .lTaskBar 
			*‰Ó·‡‚ËÚ¸ ‚ Ú‡ÒÍ·‡
			*activate
				THIS.addWindow(m.thWnd)

	*!*				DO CASE
	*!*				CASE m.tnlParam = SW_OTHERUNZOOM
	*!*					*The window is being uncovered because a maximize window was restored or minimized.
	*!*				CASE m.tnlParam = SW_OTHERZOOM
	*!*					*The window is being covered by another window that has been maximized.
	*!*				CASE m.tnlParam = SW_PARENTCLOSING
	*!*					*The window's owner window is being minimized.
	*!*				CASE m.tnlParam = SW_PARENTOPENING
	*!*					*The window's owner window is being restored.
	*!*				ENDCASE

				UNBINDEVENTS(m.thWnd, m.tnMsg)	
	*!*			ELSE
	*!*			*Û·‡Ú¸ ËÁ Ú‡ÒÍ·‡‡
	*!*			*hide
	*!*				IF THIS.oVars.lTaskBar
	*!*					THIS.oTaskBar.DeactivateHandler(m.thWnd)
	*!*				ENDIF
			ENDIF

			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)

			IF .lTaskBar AND VARTYPE(THIS.oTaskBar) = 'O'
				IF TYPE("_Screen.ActiveForm") = 'O' AND !ISNULL(_Screen.ActiveForm) AND _Screen.ActiveForm.WindowType = 1
				*‡ÍÚË‚Ì‡ ÏÓ‰‡Î¸Ì‡ˇ ÙÓÏ‡
					THIS.oTaskBar.Enabled = .F.
				ELSE
					THIS.oTaskBar.Enabled = .T.
				ENDIF
			ENDIF
		CASE m.tnMsg = WM_CREATE
			LOCAL lndwStyle
			lndwStyle = CTOBIN(SYS(2600, m.tnlParam + (4 * 8), 4), "4rs")

			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)

			IF BITAND(m.lndwStyle, WS_BORDER) = WS_BORDER
				BINDEVENT(m.thWnd, WM_SHOWWINDOW, THIS, "handlewinmsg", 4)
			ENDIF

			lnRetvalue = 0
		CASE m.tnMsg = WM_DESTROY
			THIS.removeWindow(m.thWnd)

			lnRetvalue = callWindowProc(.WndProc, m.thWnd, m.tnMsg, m.tnwParam, m.tnlParam)
		ENDCASE
	ENDWITH
RETURN m.lnRetvalue
ENDPROC
PROCEDURE load_ini
LPARAMETERS tcSection, tcKey, tcKeyValue, tcFields, toFieldsValue
	THIS.oXml_Ini.getXmlIniEntry(THIS.oVars.cAppCurPaths + THIS.oVars.cAppName + ".XML", m.tcSection, m.tcKey, m.tcKeyValue,;
								 m.tcFields, @toFieldsValue)
ENDPROC
PROCEDURE loadevent
LOCAL ARRAY laDLLs[1]
	WITH THIS
		ADLLS(laDLLs)
		ACOPY(laDLLs, .oVars.aSaveDlls)

		DECLARE integer CallWindowProc IN WIN32API;
			integer lpPrevWndFunc,;
			integer hWnd, integer Msg,;
			integer wParam,;
			integer lParam

		.oVars.wndProc = .oWinApi.getWindowLong(IIF(.oVars.lScreenhWnd, _Screen.HWnd, _VFP.HWnd), GWL_WNDPROC)

		BINDEVENT(0, WM_CREATE, THIS, "handlewinmsg", 4)

		.oVars.Eventloaded = .T.
	ENDWITH
ENDPROC
PROCEDURE loadsettings
#INCLUDE "..\lib.9\base_idb.h"
LOCAL loExc as Exception, lctask_name as String, lnI as Integer, lnJ as Integer, lnK as Integer, lnL as Integer,;
		loFields as xml_fields OF ..\lib.9\xml_ini, lnIdVars, lnRow, lnCol
LOCAL ARRAY laTmp[1], laTmp1[1, 1]
	WITH THIS
#IF !_DEVELOP_MODE
		TRY
#ENDIF
			LOCAL loProgrammProperties as Collection

			.load_ini("ProgrammProperties", .F., .F., '', @loProgrammProperties)

			IF VARTYPE(m.loProgrammProperties) = 'O' AND (!ISNULL(m.loProgrammProperties);
														  AND m.loProgrammProperties.Count > 0)
				FOR lnI = 1 TO m.loProgrammProperties.Count
					loFields = m.loProgrammProperties.Item[m.lnI]
					
					FOR lnJ = 1 TO ALEN(m.loFields.aFields, 1)
						IF m.loFields.aFields[m.lnJ, 1] = "Name"
							lvValue = ''

							FOR lnK = 1 TO ALEN(m.loFields.aFields, 1)
								IF m.loFields.aFields[m.lnK, 1] = "Value"
									lvValue = VAL(m.loFields.aFields[m.lnK, 2])

									EXIT
								ENDIF
							ENDFOR
							
							IF !EMPTY(m.lvValue)
								DO CASE
								CASE m.loFields.aFields[m.lnJ, 2] = "SystemTimerInterval"
									.oApp_Timer.Interval = m.lvValue

									EXIT
								OTHERWISE
								ENDCASE
							ENDIF
						ENDIF
					ENDFOR
				ENDFOR
			ELSE
			ENDIF
#IF !_DEVELOP_MODE
		CATCH TO loExc
			.Function.showErrMsg(m.loExc)
		ENDTRY
#ENDIF
#IF !_DEVELOP_MODE
		TRY
#ENDIF
			LOCAL loDataBases as Collection

			.load_ini("TaskList", .F., .F., '', @loDataBases)

			IF VARTYPE(m.loDataBases) = 'O' AND (!ISNULL(m.loDataBases) AND m.loDataBases.Count > 0)
				LOCAL lotask as tasklist OF ..\lib.9\base_app

				FOR lnI = 1 TO m.loDataBases.Count
				*ˆËÍÎ ÔÓ Á‡‰‡˜‡Ï
					loFields = m.loDataBases.Item[m.lnI]
					*ıÓÓ¯Ó ·˚ Ò‰ÂÎ‡Ú¸ ÍÓÔËÓ‚‡ÌËÂ tasklist-a „Î‡‚ÌÓ„Ó Ó·˙ÂÍÚ‡ ÔÓ„‡ÏÏ˚
					lotask = NEWOBJECT("tasklist")

					FOR lnJ = 1 TO ALEN(m.loFields.aFields, 1)
					*ˆËÍÎ ÔÓ ÔÓÎˇÏ Á‡‰‡˜Ë
						*Û·‡Ú¸ ÔÓ·ÂÎ˚
						loFields.aFields[m.lnJ, 2] = ALLTRIM(m.loFields.aFields[m.lnJ, 2])
						*Ì‡ÈÚË ‚ Ï‡ÒÒË‚Â ‰‡ÌÌÓÂ ÔÓÎÂ
						lnIdVars = ASCAN(m.lotask.oVars.aStoreXmlVars, m.loFields.aFields[m.lnJ, 1],;
										 -1, -1, 2, 15)
						
						IF m.lnIdVars <> 0
							*‚˚ÔÓÎÌËÚ¸ ÔÂÓ·‡ÁÓ‚‡ÌËÂ ÚËÔÓ‚
							DO CASE
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'd' &&ÚËÔ‡ date
								lvValue = CTOD(m.loFields.aFields[m.lnJ, 2])
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'c' &&ÚËÔ‡ char
								lvValue = IIF(VARTYPE(m.loFields.aFields[m.lnJ, 2]) = 'C',;
											  ALLTRIM(m.loFields.aFields[m.lnJ, 2]),;
											  '')
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'n' &&ÚËÔ‡ numeric
								lvValue = IIF(VARTYPE(m.loFields.aFields[m.lnJ, 2]) = 'C',;
											  VAL(m.loFields.aFields[m.lnJ, 2]),;
											  0)
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'v' &&ÚËÔ‡ variable
								lvValue = IIF(VARTYPE(m.loFields.aFields[m.lnJ, 2]) = 'C',;
											  ALLTRIM(m.loFields.aFields[m.lnJ, 2]),;
											  m.loFields.aFields[m.lnJ, 2])
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'l' &&ÚËÔ‡ logical
								lvValue = IIF(VARTYPE(m.loFields.aFields[m.lnJ, 2]) = 'C',;
											  m.loFields.aFields[m.lnJ, 2] == "TRUE",;
											  .F.)
							CASE m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] = 'a' &&ÚËÔ‡ array
								*‡ÒÔ‡ÍÓ‚‡Ú¸ ‡ıË‚
								ALINES(laTmp, SUBSTR(m.loFields.aFields[m.lnJ, 2],;
													 3,;
									   				 LEN(m.loFields.aFields[m.lnJ, 2]) - 4),;
									   2, '"]["')

								lnRow = ALEN(laTmp, 1)
								lnCol = THIS.oFunction.getWordCount(laTmp[1], '";"')
								*ÌÓ‚˚È Ï‡ÒÒË‚˜ËÍ
								DIMENSION laTmp1[m.lnRow, m.lnCol]

								FOR lnK = 1 TO m.lnRow
									FOR lnL = 1 TO m.lnCol
										laTmp1[m.lnK, m.lnL] = THIS.oFunction.getWordNum(laTmp[m.lnK], m.lnL, '";"')
									ENDFOR
								ENDFOR

								lcExp = "DIMENSION m.lotask.oVars." + m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 1];
										+ '[' + TRANSFORM(m.lnRow) + ',' + TRANSFORM(m.lnCol) + ']'
								&lcExp

								lcExp = "ACOPY(laTmp1, m.lotask.oVars." + m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 1] + ')'
								&lcExp
							OTHERWISE
								lvValue = IIF(VARTYPE(m.loFields.aFields[m.lnJ, 2]) = 'C',;
											  ALLTRIM(m.loFields.aFields[m.lnJ, 2]),;
											  m.loFields.aFields[m.lnJ, 2])
							ENDCASE
							*ÒÓı‡ÌËÚ¸ ‚ ÔÂÂÏÂÌÌÛ˛ Ó·˙ÂÍÚ‡ Vars
							IF m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 3] <> 'a'
								STORE m.lvValue TO ("m.lotask.oVars." + m.lotask.oVars.aStoreXmlVars[m.lnIdVars, 1])
							ENDIF
						ENDIF
					ENDFOR

					lotask.oVars.cTaskCaption = m.lotask.oVars.cTaskName

					IF !m.lotask.oVars.lStorePassword
						lotask.oVars.cUserPassword = ''
					ENDIF

					.oTaskList.Add(m.lotask)

					IF m.lotask.oVars.lActive
						.oVars.oCurrentTask = m.lotask
					ENDIF
				ENDFOR
			ELSE
				lotask = NEWOBJECT("tasklist")

				.oTaskList.Add(m.lotask)
			ENDIF

			IF ISNULL(.oVars.oCurrentTask)
				.oVars.oCurrentTask = .oTaskList.Item[1]
			ENDIF
#IF !_DEVELOP_MODE
		CATCH TO loExc
			.oFunction.showErrMsg(m.loExc)
		ENDTRY
#ENDIF
	ENDWITH
ENDPROC
PROCEDURE login
*ÙÓÏ‡ ‡‚ÚÓËÁ‡ˆËË
LOCAL llreslogin as Logical, lcCursorName as String, llResult as Logical, llsuccess as Logical,;
	  loExc as Exception
	llreslogin = .F.

	WITH THIS
		IF !ISNULL(.oVars.oCurrentTask)
			IF .oVars.oCurrentTask.oVars.lStorePassword
				*ÔÓ‰ÍÎ˛˜‡Ú¸Òˇ ·ÂÁ ‚˚‚Ó‰‡ ÙÓÏ˚ "ÎÓ„ËÌ‡"
#IF !_DEVELOP_MODE
				TRY
#ENDIF
					.oVars.oDBConnect = NEWOBJECT("DbConnect", "..\lib.9\base_idb", '', .oVars.oCurrentTask.oVars.nDBType)

					llsuccess = .oVars.oDBConnect.connect(.oVars.oCurrentTask.oVars.cDBPath,;
														  .oVars.oCurrentTask.oVars.cDBName,;
														  .oVars.oCurrentTask.oVars.cUserName,;
														  .oVars.oCurrentTask.oVars.cUserPassword)
#IF !_DEVELOP_MODE
				CATCH TO loExc
					.Function.showErrMsg(m.loExc)
				ENDTRY
#ENDIF
			ENDIF

			IF !m.llsuccess AND !.oVars.oCurrentTask.oVars.lStorePassword
			*ÔÓ‰ÍÎ˛˜ËÚ¸Òˇ ÌÂ Û‰‡ÎÓÒ¸ ÎË·Ó ÚÂ·ÛÂÚÒˇ ‚‚ÂÒÚË Ô‡ÓÎ¸ - Á‡ÔÛÒÍ‡ÂÏ ÙÓÏÛ "ÎÓ„ËÌ‡"
				loForm = CREATEOBJECT("login_form", THIS)

				WITH m.loForm
					IF !.lPassVerification
						.Show(1)
					ENDIF

					llsuccess = .lPassVerification
					THIS.oVars.oDBConnect = .oDBConnect

					.Release()
				ENDWITH
			ENDIF

			IF !ISNULL(.oVars.oDBConnect)
				DO CASE
				CASE .oVars.oCurrentTask.oVars.nDBType = DB_FoxPro
					.oVars.oCurrentTask.nIdSession = .oVars.oDBConnect.nId_Connection
				CASE .oVars.oCurrentTask.oVars.nDBType = DB_PostgreSQL
					LOCAL loSql as dbsql OF ..\lib.9\base_idb
					lcCursorName = SYS(2015)

					loSql = NEWOBJECT("dbsql", "..\lib.9\base_idb", '', .oVars.oDBConnect)
					llResult = m.loSql.execute("SELECT " + .oVars.oCurrentTask.oVars.cDBSchema;
											   + ".login_user()", m.lcCursorName)

					RELEASE m.loSql

					.oVars.oCurrentTask.nIdSession = IIF(m.llResult,;
														EVALUATE(m.lcCursorName + ".login_user"),;
														0)

					USE IN SELECT(m.lcCursorName)
				CASE .oVars.oCurrentTask.oVars.nDBType = DB_MSSQL
					.oVars.oCurrentTask.nIdSession = .oVars.oDBConnect.nId_Connection
				CASE .oVars.oCurrentTask.oVars.nDBType = DB_Oracle
				CASE .oVars.oCurrentTask.oVars.nDBType = DB_Access
					.oVars.oCurrentTask.nIdSession = .oVars.oDBConnect.nId_Connection
				OTHERWISE
					.oVars.oCurrentTask.nIdSession = .oVars.oDBConnect.nId_Connection
				ENDCASE

				IF .oVars.oCurrentTask.nIdSession < 1
					.oVars.oDBConnect.Destroy()
					.oVars.oDBConnect = .NULL.
					.oApp_timer.Enabled = .F.

					.showMsg("Cannot login!")
				ELSE
*!*						.SaveSettings()
					llreslogin = .T.
					.oApp_timer.Enabled = .T.
				ENDIF
			ENDIF
		ENDIF
	ENDWITH
RETURN m.llreslogin
ENDPROC
PROCEDURE logout
WITH THIS
	IF !ISNULL(.oVars.oCurrentTask) AND !ISNULL(.oVars.oDBConnect) AND !ISNULL(.oVars.oCurrentTask.nIdSession)
		.oApp_timer.Enabled = .F.

		DO CASE
		CASE .oVars.oCurrentTask.oVars.nDBType = DB_FoxPro
		CASE .oVars.oCurrentTask.oVars.nDBType = DB_PostgreSQL
			LOCAL loSql as Object, lnnIdSession as Integer
			lcCursorName = SYS(2015)
			lnIdSession = .oVars.oCurrentTask.nIdSession

			loSql = NEWOBJECT("dbsql", "..\lib.9\base_idb", '', .oVars.oDBConnect)
			llResult = m.loSql.execute("SELECT " + .oVars.oCurrentTask.oVars.cDBSchema;
									   + ".logout_user(CAST("+TRANSFORM(m.lnIdSession) + " AS INTEGER))",;
									   m.lcCursorName)

			RELEASE m.loSql

			USE IN SELECT(m.lcCursorName)

			.oVars.oCurrentTask.nIdSession = .NULL.
		CASE .oVars.oCurrentTask.oVars.nDBType = DB_MSSQL
		CASE .oVars.oCurrentTask.oVars.nDBType = DB_Oracle
		CASE .oVars.oCurrentTask.oVars.nDBType = DB_Access
		ENDCASE
	ENDIF
ENDWITH
ENDPROC
PROCEDURE onmenuevents
LPARAMETERS tcNameMenu as String
LOCAL loExc as Exception
#IF !_DEVELOP_MODE
	TRY
#ENDIF
		DO CASE
		CASE m.tcNameMenu = "Find"
			IF TYPE("_Screen.ActiveForm") = 'O' AND;
				_Screen.ActiveForm.Baseclass = "Form" AND;
				_Screen.ActiveForm.Class = "Main_form"
				_Screen.ActiveForm.cntToolbars.cntFind.Click()
			ENDIF
		CASE m.tcNameMenu = "Replace"
		CASE m.tcNameMenu = "Clock"
			LOCAL loClock as Form

			loClock = NEWOBJECT("_Clock", "..\lib.9\base_app")
			m.loClock.Show()

			THIS.AddWindow(m.loClock.HWnd)
		CASE m.tcNameMenu = "Calendar"
			LOCAL loCalendar as Form

			loCalendar = NEWOBJECT("_Calendar", "..\lib.9\base_app")
			m.loCalendar.Show()

			THIS.addWindow(m.loCalendar.HWnd)
		CASE m.tcNameMenu = "TBEdit"
		*Â‰‡ÍÚËÓ‚‡ÌËÂ
			IF THIS.oMenu.FacePad.ToolBarPad.Item["ToolBar"].lMarked
				THIS.oMenu.FacePad.ToolBarPad.Item["ToolBar"].lMarked = .F.

				THIS.oToolBar.Item["TBEdit"].Visible = .F.
			ELSE
				THIS.oMenu.FacePad.ToolBarPad.Item["ToolBar"].lMarked = .T.

				THIS.oToolBar.Item["TBEdit"].Visible = .T.
			ENDIF
		CASE m.tcNameMenu = "TBService"
		*ÒÂ‚ËÒ
			IF THIS.oMenu.FacePad.ToolBarPad.Item["ServiceBar"].lMarked
				THIS.oMenu.FacePad.ToolBarPad.Item["ServiceBar"].lMarked = .F.

				THIS.oToolBar.Item["TBService"].Visible = .F.
			ELSE
				THIS.oMenu.FacePad.ToolBarPad.Item["ServiceBar"].lMarked = .T.

				THIS.oToolBar.Item["TBService"].Visible = .T.
			ENDIF
		CASE m.tcNameMenu = "TBBaseTuning"
		*Ì‡ÒÚÓÈÍË
			IF THIS.oMenu.FacePad.ToolBarPad.Item["BaseTuningBar"].lMarked
				THIS.oMenu.FacePad.ToolBarPad.Item["BaseTuningBar"].lMarked = .F.

				THIS.oToolBar.Item["TBBaseTuning"].Visible = .F.
			ELSE
				THIS.oMenu.FacePad.ToolBarPad.Item["BaseTuningBar"].lMarked = .T.

				THIS.oToolBar.Item["TBBaseTuning"].Visible = .T.
			ENDIF
		CASE m.tcNameMenu = "TBActivity"
		*Ì‡ÒÚÓÈÍË
			IF THIS.oMenu.FacePad.ToolBarPad.Item["ActivityBar"].lMarked
				THIS.oMenu.FacePad.ToolBarPad.Item["ActivityBar"].lMarked = .F.

				THIS.oToolBar.Item["TBActivity"].Visible = .F.
			ELSE
				THIS.oMenu.FacePad.ToolBarPad.Item["ActivityBar"].lMarked = .T.

				THIS.oToolBar.Item["TBActivity"].Visible = .T.
			ENDIF
		ENDCASE
#IF !_DEVELOP_MODE
	CATCH TO loExc
		THIS.showErrMsg(m.loExc)
	ENDTRY
#ENDIF
ENDPROC
PROCEDURE release
LOCAL laDLLs, lni, lnCount, loObj as Toolbar
	*Á‡Í˚Ú¸ ÓÍÌ‡
	WITH THIS
		.oFunction.closeAllWindows()

		IF !ISNULL(.oVars.oDBConnect)
			.oVars.oDBConnect.Destroy()
		ENDIF
		*status bar
#IF !_DEVELOP_MODE
		TRY
#ENDIF
			IF !ISNULL(.oTaskBar)
				.oTaskBar.Release()
			ENDIF
#IF !_DEVELOP_MODE
		CATCH TO loExc
		FINALLY
#ENDIF
			THIS.oTaskBar = .NULL.
#IF !_DEVELOP_MODE
		ENDTRY
#ENDIF
		*toolbars
		IF .oVars.lToolBar
#IF !_DEVELOP_MODE
			TRY
#ENDIF
				FOR EACH loObj IN .oToolBar
					m.loObj.RemoveObject()
				ENDFOR
#IF !_DEVELOP_MODE
			CATCH TO loExc
			FINALLY
#ENDIF
				.oToolBar = .NULL.
#IF !_DEVELOP_MODE
			ENDTRY
#ENDIF
		ENDIF
		*windows
		FOR EACH loObj IN .oApp_Collection
			IF TYPE("m.loObj.BaseClass") = 'C' AND m.loObj.BaseClass == "Form"
				m.loObj.Release()
			ELSE
				RELEASE m.loObj
			ENDIF
		ENDFOR

		DIMENSION laDLLs[1]

		IF .oVars.EventLoaded
			.releaseEvent()
		ENDIF

		IF .oVars.lCleanAllDlls
			lnCount = ADLLS(laDLLs)

			FOR lni = 1 TO m.lnCount
				.removeDLL(laDLLs[m.lni, 1])
			ENDFOR
		ENDIF

		.removeDLL("CallWindowProc")	

		CLEAR EVENTS
	ENDWITH
ENDPROC
PROCEDURE releaseevent
THIS.oVars.Eventloaded = .F.

UNBINDEVENTS(0, WM_CREATE)
*!*	UNBINDEVENTS(0, WM_DESTROY)
*!*	UNBINDEVENTS(0, WM_SETTEXT)
*!*	UNBINDEVENTS(0, WM_SETFOCUS)
*!*	UNBINDEVENTS(0, WM_WINDOWPOSCHANGED)
*!*	UNBINDEVENTS(0, WM_SHOWWINDOW)
ENDPROC
PROCEDURE removedll
LPARAMETERS tcDLLName as String
	IF VARTYPE(THIS.oVars.lKeepDlls) = 'L' AND THIS.oVars.lKeepDlls
		RETURN
	ENDIF

	IF ASCAN(THIS.oVars.aSaveDLLs, m.tcDLLName, -1, -1, 1, 1) = 0
		CLEAR DLLS &tcDLLName
	ENDIF
ENDPROC
PROCEDURE removewindow
LPARAMETERS thWnd as Integer
LOCAL loForm as Form
	IF m.thWnd = _VFP.hWnd
		RETURN
	ENDIF
	*first, scan forms collection to see if hWnd is from some active form
*!*		FOR EACH loForm IN THIS.oApp_Collection
*!*			IF m.loForm.hWnd = larrEv[1,1].hWnd &&m.thWnd
*!*				UNBINDEVENTS(m.loForm, "Release", THIS, "RemoveWindow")
*!*				UNBINDEVENTS(m.thWnd, WM_WINDOWPOSCHANGED)
*!*				
*!*				THIS.RemoveObject(m.loForm)

			IF THIS.oVars.lTaskBar
				UNBINDEVENTS(m.thWnd, WM_DESTROY)
				UNBINDEVENTS(m.thWnd, WM_SETTEXT)
				UNBINDEVENTS(m.thWnd, WM_SETFOCUS)

				IF VARTYPE(THIS.oTaskBar) = 'O'
					THIS.oTaskBar.removeFormButton(m.thWnd)
				ENDIF
			ENDIF
*!*				
*!*				EXIT
*!*			ENDIF
*!*		ENDFOR
ENDPROC
PROCEDURE save_ini
LPARAMETERS tcSection, tcKey, tcKeyValue, tcFields, taFieldsValue
	THIS.oXml_Ini.writeXmlIniEntry(THIS.oVars.cAppCurPaths + THIS.oVars.cAppName + ".XML", m.tcSection, m.tcKey, m.tcKeyValue,;
								   m.tcFields, @taFieldsValue)
ENDPROC
PROCEDURE savesettings
#INCLUDE "..\lib.9\base_idb.h"
LOCAL loExc as Exception, lcDBType as String, lcVars, lcValues, lnI, lnJ, lnK, lvValue, lnCol
#IF !_DEVELOP_MODE
	TRY
#ENDIF
		*Ó·˘ËÂ Ì‡ÒÚÓÈÍË
		THIS.save_ini("ProgrammProperties", "Name", "SystemTimerInterval", "Value", TRANSFORM(THIS.oApp_Timer.Interval))

		WITH THIS.oVars.oCurrentTask.oVars
			*Ì‡ÒÚÓÈÍË ÚÂÍÛ˘ÂÈ Á‡‰‡˜Ë
			IF !ISNULL(THIS.oVars.oCurrentTask)
				*Í‡ÒÚÓÏÌ˚Â ÔÂÂÏÂÌÌ˚Â
				lcVars = ''
				lcValues = ''
				*ˆËÍÎ ÔÓ ÔÓÎˇÏ ÍÓÚÓ˚Â Ì‡‰Ó ÒÓı‡ÌˇÚ¸
				FOR lnI = 1 TO ALEN(.aStoreXmlVars, 1)
					lcVars = m.lcVars + ',' + .aStoreXmlVars[m.lnI, 2]
					
					DO CASE
					CASE .aStoreXmlVars[m.lnI, 3] = 'd' &&ÚËÔ‡ date
						lcValues = m.lcValues + ',' + TRANSFORM(EVALUATE("." + .aStoreXmlVars[m.lnI, 1]))
					CASE .aStoreXmlVars[m.lnI, 3] = 'c' &&ÚËÔ‡ char
						lvValue = EVALUATE("." + .aStoreXmlVars[m.lnI, 1])
						lcValues = m.lcValues + ',' + IIF(VARTYPE(m.lvValue) = 'C', ALLTRIM(m.lvValue), '')
					CASE .aStoreXmlVars[m.lnI, 3] = 'n' &&ÚËÔ‡ numeric
						lcValues = m.lcValues + ',' + TRANSFORM(EVALUATE("." + .aStoreXmlVars[m.lnI, 1]))
					CASE .aStoreXmlVars[m.lnI, 3] = 'v' &&ÚËÔ‡ variable
						lcValues = m.lcValues + ',' + TRANSFORM(EVALUATE("." + .aStoreXmlVars[m.lnI, 1]))
					CASE .aStoreXmlVars[m.lnI, 3] = 'l' &&ÚËÔ‡ logical
						lcValues = m.lcValues + ',' + IIF(EVALUATE("." + .aStoreXmlVars[m.lnI, 1]),;
														  "TRUE", "FALSE")
					CASE .aStoreXmlVars[m.lnI, 3] = 'a' &&ÚËÔ‡ array
						lcValues = m.lcValues + ','

						FOR lnJ = 1 TO EVALUATE("ALEN(." + .aStoreXmlVars[m.lnI, 1] + ", 1)")
							lcValues = m.lcValues + '["'
							lnCol = EVALUATE("ALEN(." + .aStoreXmlVars[m.lnI, 1] + ", 2)")

							FOR lnK = 1 TO IIF(m.lnCol = 0, 1, m.lnCol)
								lvValue = EVALUATE("." + .aStoreXmlVars[m.lnI, 1];
												   + '[' + TRANSFORM(m.lnJ) + ',' + TRANSFORM(m.lnK) +']')
								lcValues = m.lcValues + ALLTRIM(IIF(VARTYPE(m.lvValue) <> 'C', TRANSFORM(m.lvValue), m.lvValue)) + '";"'
							ENDFOR

							
*!*								lcValues = IIF(EVALUATE("ALEN(." + .aStoreXmlVars[m.lnI, 1] + ", 2)") > 0,;
*!*											   LEFT(m.lcValues, LEN(m.lcValues) - 3),;
*!*											   m.lcValues);
*!*										   + '"]'
							lcValues = LEFT(m.lcValues, LEN(m.lcValues) - 3) + '"]'
						ENDFOR
					OTHERWISE
						lcValues = m.lcValues + ',' + ALLTRIM(EVALUATE("." + .aStoreXmlVars[m.lnI, 1]))
					ENDCASE
				ENDFOR
				*Û·‡Ú¸ ÎË¯Ì˛˛ ','
				lcVars = SUBSTR(m.lcVars, 2)
				lcValues = SUBSTR(m.lcValues, 2)

				THIS.save_ini("TaskList", "Name", .cTaskName, m.lcVars, m.lcValues)
			ENDIF
		ENDWITH
#IF !_DEVELOP_MODE
	CATCH TO loExc
		THIS.oFunction.showErrMsg(m.loExc)
	ENDTRY
#ENDIF
ENDPROC
PROCEDURE setenvironment
LPARAMETERS tnDataSessionId as Integer
	IF VARTYPE(m.tnDataSessionId) <> 'N'
		tnDataSessionId = 0
	ELSE
		IF m.tnDataSessionId <> 0
			SET DATASESSION TO m.tnDataSessionId
		ENDIF
	ENDIF

	SET ANSI OFF
	SET CENTURY ON
	SET SYSFORMATS ON
	SET DATE DMY
	SET SECONDS ON
	SET HOURS TO 24 
	SET EXCLUSIVE OFF
	SET EXACT OFF
	SET TALK OFF
	SET SAFETY OFF
	SET COMPATIBLE OFF
	SET NOTIFY OFF
	SET CONFIRM ON
	SET DELETE ON
	SET NEAR ON
	SET POINT TO '.'
	SET DECIMAL TO 6
	SET MULTILOCKS ON
	SET ESCAPE OFF
	SET STATUS BAR OFF
	SET ECHO OFF
*!*		SET NULL ON

	IF m.tnDataSessionId <> 0
		SET DATASESSION TO THIS.nDataSessionId
	ENDIF
ENDPROC
PROCEDURE showmsg
LPARAMETERS tcMsg as String
LOCAL loPanelMsg as _messages OF ..\lib.9\base_app, lnI as Integer,;
	  llfou as Logical, loExc as Exception
	TRY
		FOR lnI = 1 TO _Screen.FormCount
			IF _Screen.Forms[m.lnI].Class == "_messages"
				llfou = .T.

				EXIT
			ENDIF
		ENDFOR
	CATCH TO loExc
		THIS.oFunction.showErrMsg(m.loExc)
	ENDTRY

	IF m.llfou
		loPanelMsg = _Screen.Forms[m.lnI]
	ELSE
		loPanelMsg = CREATEOBJECT("_messages")
*!*			
*!*			IF !THIS.oVars.lTaskBar
*!*			*Ú.Í. ÒÓÓ·˘ÂÌËˇ ÌÂ ÎÓ‚ËÏ - ÚÓ ‰Ó·‡‚ËÚ¸ ‚ ÍÓÎÎÂÍˆË˛ ÛÍ‡ÏË
*!*				THIS.AddObject(m.loPanelMsg)
*!*			ENDIF

		m.loPanelMsg.Show()
	ENDIF

	loPanelMsg.MsgTxt = m.tcMsg
ENDPROC
PROCEDURE stop
	ON SHUTDOWN

	IF TYPE("m.goApp") = 'O'
		m.goApp.Release()
		RELEASE m.goApp
	ENDIF

	ON ERROR err = .t.
*!*		CLEAR ALL
	SET STATUS BAR ON
	SET MESSAGE TO
	SET BELL ON
	POP KEY ALL
	RESTORE MACROS
	SET CLASSLIB TO
	SET SYSMENU TO DEFAULT
	ON ERROR
	CLEAR EVENTS

	IF _VFP.StartMode = 0
		CANCEL
	ELSE
		QUIT
	ENDIF
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
7[END RESERVED2]
[START RESERVED3]
*addwindow 
*go 
*goform 
*gomenu 
*goproc 
*handlewinmsg 
*load_ini 
*loadevent 
*loadsettings 
*login 
*logout 
*onmenuevents 
*release Releases a FormSet or Form from memory.
*releaseevent 
*removedll 
*removewindow 
*save_ini 
*savesettings 
*setenvironment 
*showmsg 
*stop 
_memberdata XML Metadata for customizable properties
ndatasessionid
otaskbar
otoolbar
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\factory.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\factory.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1PJ0VMLBI
[CLASS] base_collection
[CLASSLOC] base_gui.vcx
[BASECLASS] collection
[OBJNAME] oapp_collection
[PARENT] base_app
[START PROPERTIES]
Left = 8
Name = "oapp_collection"
Top = 64
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1PJ0U50MI
[CLASS] base_timer
[CLASSLOC] base_gui.vcx
[BASECLASS] timer
[OBJNAME] oApp_timer
[PARENT] base_app
[START PROPERTIES]
Enabled = .F.
Interval = 10000
Left = 8
Name = "oApp_timer"
Top = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Timer
#INCLUDE ..\lib.9\base_idb.h
LOCAL loSql as Object, lcCursorName as String, llResult as Logical,;
	  lcOldAlias as String, lcUserName as String, lnIdUser as Integer,;
	  lcSql as String, lnIdSession as Integer
	WITH THIS.Parent
		IF !ISNULL(.oVars.TimeTerminate) AND DATETIME() >= .oVars.TimeTerminate
			KEYBOARD "{ALT+F4}"
		ENDIF

		IF !ISNULL(.oVars.oCurrentTask) AND !ISNULL(.oVars.oDBConnect) AND .oVars.oDBConnect.lock()
			THIS.Enabled = .F.
			lcOldAlias = ALIAS()
			loSql = NEWOBJECT("dbsql", "..\lib.9\base_idb", "", .oVars.oDBConnect)
			lcCursorName = SYS(2015)
			lnIdSession = .oVars.oCurrentTask.nIDSession

			DO CASE
			CASE .oVars.oCurrentTask.oVars.nDBType = DB_FoxPro
			CASE .oVars.oCurrentTask.oVars.nDBType = DB_PostgreSQL
				llResult = m.loSql.execute("SELECT * FROM " + .oVars.oCurrentTask.oVars.cDBSchema;
										   + ".get_messages_to(" + TRANSFORM(.oVars.oCurrentTask.nIDSession) + ", 'L')",;
										   m.lcCursorName)
			CASE .oVars.oCurrentTask.oVars.nDBType = DB_MSSQL
			CASE .oVars.oCurrentTask.oVars.nDBType = DB_Oracle
			OTHERWISE
				llResult = .F.
			ENDCASE

			IF m.llResult
				SELECT (m.lcCursorName)

				SCAN
					lnIdSession = ID_Session_From

					DO CASE
					CASE .oVars.oCurrentTask.oVars.nDBType = DB_FoxPro
					CASE .oVars.oCurrentTask.oVars.nDBType = DB_PostgreSQL
TEXT TO m.lcSql NOSHOW TEXT
SELECT NAME
FROM <<.oVars.oCurrentTask.oVars.cDBSchema>>.View_Users
WHERE ID = (SELECT ID_User
		  FROM <<.oVars.oCurrentTask.oVars.cDBSchema>>.Sessions
		  WHERE ID = <<TRANSFORM(ID_Session_From)>>)
ENDTEXT

						llResult = m.loSql.execute(m.lcsql, m.lcCursorName + "_u")
					CASE .oVars.oCurrentTask.oVars.nDBType = DB_MSSQL
					CASE .oVars.oCurrentTask.oVars.nDBType = DB_Oracle
					ENDCASE

					IF m.llResult
						lcUserName = ALLTRIM(EVALUATE(m.lcCursorName+"_u.NAME")) + " : "
						USE IN (m.lcCursorName + "_u")

						SELECT (m.lcCursorName)
					ELSE
						lcUserName = ''
					ENDIF

					DO CASE
					CASE TYPEMSG = 'M'
					*‚˚‚ÂÒÚË ÏÂÒÒ‡„Û
						.showMsg("—ÓÓ·˘ÂÌËÂ ÓÚ " + m.lcUserName + ALLTRIM(MESSAGE))
						.oWinApi.messageBeep()
*						MESSAGEBOX("—ÓÓ·˘ÂÌËÂ ÓÚ "+m.lcUserName+CHR(10)+ALLTRIM(MESSAGE), 64, .cTaskCaption)
					CASE TYPEMSG = 'A'
					*Á‡Í˚Ú¸ ÔËÎÓÊÂÌËÂ
						LOCAL lnposmes as Integer
						lnposmes = AT("DATETIME:", MESSAGE)

						.TimeTerminate = CTOT(SUBSTRC(MESSAGE, m.lnposmes + 9, 16))

						.showMsg(m.lcUserName + MSG_ALERT_EXIT + " " + TTOC(.oVars.nTimeTerminate, 2) + "! "+SUBSTRC(MESSAGE, m.lnposmes + 9 + 18))
						.oWinApi.messageBeep()
					CASE TYPEMSG = 'C'
					ENDCASE
				ENDSCAN

				USE IN (m.lcCursorName)
			ENDIF

			RELEASE m.loSql

			IF !EMPTY(m.lcOldAlias)
				SELECT (m.lcOldAlias)
			ENDIF

			.oVars.oDBConnect.unLock()
			THIS.Enabled = .T.
		ENDIF
	ENDWITH
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0KYGSG
[CLASS] cstfunction
[CLASSLOC] base_app.vcx
[BASECLASS] custom
[OBJNAME] oFunction
[PARENT] base_app
[START PROPERTIES]
Left = 72
Name = "oFunction"
Top = 8
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QC0CNAY3
[CLASS] base_collection
[CLASSLOC] base_gui.vcx
[BASECLASS] collection
[OBJNAME] oTaskList
[PARENT] base_app
[START PROPERTIES]
Left = 40
Name = "oTaskList"
Top = 64
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RU0BT33K
[CLASS] cstwinapi
[CLASSLOC] base_app.vcx
[BASECLASS] custom
[OBJNAME] oWinApi
[PARENT] base_app
[START PROPERTIES]
Left = 40
Name = "oWinApi"
Top = 8
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1PJ0VS2Y9
[CLASS] xml_ini
[CLASSLOC] xml_ini.vcx
[BASECLASS] custom
[OBJNAME] oXml_ini
[PARENT] base_app
[START PROPERTIES]
Height = 17
Left = 8
Name = "oXml_ini"
Top = 32
Width = 24
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] base_app

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM01C8TQ
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] basetuningbar
[START PROPERTIES]
Enabled = .F.
Height = 44
Left = 0
Name = "basetuningbar"
Top = 0
Width = 48
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM01FW5W
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdBaseTuning
[PARENT] basetuningbar
[START PROPERTIES]
Left = 5
Name = "cmdBaseTuning"
Picture = ..\bmp\preferences.ico
ToolTipText = "¡‡ÁÓ‚˚Â Ì‡ÒÚÓÈÍË ÔÓ„‡ÏÏ˚"
Top = 3
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
m.goApp.goForm("base_tuning", 0, .NULL., .NULL.)
*!*	m.goApp.goForm("FORMS\base_tuning", 0, .NULL., .NULL.)
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] basetuningbar
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0SZ0L98A3
[CLASS] custom
[BASECLASS] custom
[OBJNAME] cstfunction
[START PROPERTIES]

Name = "cstfunction"
Width = 20
_memberdata =     2531<VFPData><memberdata name="addprinter" type="method" display="addPrinter"/><memberdata name="colortorgb" type="method" display="colorToRGB"/><memberdata name="directorytoarray" type="method" display="directoryToArray"/><memberdata name="erasefile" type="method" display="eraseFile"/><memberdata name="fddformat" type="method" display="fddFormat"/><memberdata name="getfileattributes" type="method" display="getFileAttributes"/><memberdata name="getfilesize" type="method" display="getFileSize"/><memberdata name="getwordcount" type="method" display="getWordCount"/><memberdata name="getwordnum" type="method" display="getWordNum"/><memberdata name="hextodec" type="method" display="hexToDec"/><memberdata name="isfileequal" type="method" display="isFileEqual"/><memberdata name="isfileused" type="method" display="isFileUsed"/><memberdata name="ispicturevalid" type="method" display="isPictureValid"/><memberdata name="longtostring" type="method" display="longToString"/><memberdata name="monthbetween" type="method" display="monthBetween"/><memberdata name="pixeltofoxel" type="method" display="pixelToFoxel"/><memberdata name="pixeltotwip" type="method" display="pixelToTwip"/><memberdata name="playwav" type="method" display="playWav"/><memberdata name="spelling" type="method" display="spelling"/><memberdata name="writelogfile" type="method" display="writeLogFile"/><memberdata name="div" type="method" display="div"/><memberdata name="closeallwindows" type="method" display="closeAllWindows"/><memberdata name="arraypointer" type="method" display="arrayPointer"/><memberdata name="transform_my" type="method" display="transform_my"/><memberdata name="showerrmsg" type="method" display="showErrMsg"/><memberdata name="openlog" type="method" display="openLog"/><memberdata name="writelog" type="method" display="writeLog"/><memberdata name="getfont" type="method" display="getFont"/><memberdata name="gettagstring" type="method" display="getTagString"/><memberdata name="divmat" type="method" display="divMat"/><memberdata name="showerrdialog" type="method" display="showErrDialog"/><memberdata name="removedirectory" type="method" display="removeDirectory"/><memberdata name="removefolder" type="method" display="removeFolder"/><memberdata name="resourcetopath" type="method" display="resourceToPath"/><memberdata name="secondtotime" type="method" display="secondToTime"/><memberdata name="showerrdlg" type="method" display="showErrDlg"/><memberdata name="getnextfilename" type="method" display="getNextFileName"/></VFPData>
[END PROPERTIES]
[START METHODS]
PROCEDURE addprinter
* ADD PRINTER WIZARD

RUN /N rundll32.exe shell32.dll, SHHelpShortcuts_RunDLL AddPrinter

ENDPROC
PROCEDURE arraypointer
LPARAMETERS tcArray
RETURN @&tcArray
ENDPROC
PROCEDURE closeallwindows
LOCAL loExc as Exception, loI as Object
	FOR EACH loI IN _Screen.Forms
		TRY 
			m.loI.Release()
		CATCH TO loExc
			THIS.ShowErrMsg(m.loExc)
		ENDTRY
	ENDFOR
	
*!*	LOCAL lncntobj, lnobj, loExc as Exception, loI as Object
*!*		lncntobj=_Screen.FormCount
*!*		lnobj=1
*!*		DO WHILE m.lncntobj>0
*!*			TRY 
*!*				IF TYPE("_Screen.Forms")='O' AND _Screen.Forms[m.lnobj].BaseClass="Form"
*!*					_Screen.Forms[m.lnobj].Release()
*!*				ELSE
*!*					_Screen.Objects[m.lnobj].Release()

*!*					lnobj=m.lnobj+1
*!*				ENDIF
*!*			CATCH TO loExc
*!*				THIS.ShowErrMsg(m.loExc)
*!*			ENDTRY

*!*			lncntobj=m.lncntobj-1
*!*		ENDDO
ENDPROC
PROCEDURE colortorgb
* LOCAL lnRed, lnGreen, lnBlue
* This.ColorToRGB(256*256*256-1, @lnRed, @lnGreen, @lnBlue)
* DEBUGOUT lnRed, lnGreen, lnBlue -> 255, 255, 255
LPARAMETERS tnColor AS Integer, vnRed AS Byte, vnGreen AS Byte, vnBlue AS Byte
LOCAL lcHexadecimal
	lcHexadecimal = SUBSTR(TRANSFORM(m.tnColor, '@0'), 5)
	vnRed = EVALUATE('0x' + RIGHT(m.lcHexadecimal, 2))
	vnGreen = EVALUATE('0x' + SUBSTR(m.lcHexadecimal, 3, 2))
	vnBlue = EVALUATE('0x' + LEFT(m.lcHexadecimal, 2))

*!* ¬¿–»¿Õ“ 1
*!*	R  =  MOD(INT(RGB(...)/(256^0)),256)
*!*	G  =  MOD(INT(RGB(...)/(256^1)),256)
*!*	B  =  MOD(INT(RGB(...)/(256^2)),256)

*!* ¬¿–»¿Õ“ 2
*!*	vnBlue  =  INT(tnColor/(256^2))
*!*	tnColor  =  MOD(tnColor,(256^2))
*!*	vnGreen  =  INT(tnColor/256)
*!*	vnRed  =  MOD(tnColor,256)

ENDPROC
PROCEDURE complexperc
* –¿—◊≈“ —ÀŒ∆ÕŒ√Œ œ–Œ÷≈Õ“¿ (%% Õ¿ %%)
LPARAMETERS tnPerc, tnPeriod, tnRegim	&& —Ú‡‚Í‡, œÂËÓ‰Ë˜ÌÓÒÚ¸ ‚ ÏÂÒˇˆ‡ı, –ÂÊËÏ
LOCAL llClnd, llLeap, lnYear, lnSumm, lnBase, lnCount, lnDays
	IF m.tnPerc <= 0 OR 12 % m.tnPeriod # 0 OR !BETWEEN(m.tnRegim,1,3)
		RETURN -1							&& œÂËÓ‰Ë˜ÌÓÒÚ¸ Ì‡˜ËÒÎÂÌËÈ : 1, 2, 3, 4, 6, 12
	ENDIF 									&& –ÂÊËÏ˚ 1-360 ·ÌÍ.‰Ì, 2-365 Í‡Î.‰Ì, 3-366 Í‡Î.‰Ì

	llClnd = m.tnRegim <> 1					&&  ‡ÎÂÌ‰‡ÌÓÒÚ¸
	llLeap = m.tnRegim = 3					&& ¬ËÒÓÍÓÒÌÓÒÚ¸
	lnYear = IIF(m.llLeap, 2000, 1999)		&& ÀÓÏ˚ ‰ÂÎ‡Ú¸ Ï‡ÒÒË‚ - ÔÛÒÚ¸ ÔÂÂ‚˚˜ËÒÎˇÂÚ ;)
	lnSumm = 0								&& Õ‡˜ËÒÎÂÌÓ Á‡ ÔÂËÓ‰
	lnBase = 1								&& ¡‡Á‡ ‰Îˇ Ì‡˜ËÒÎÂÌËÈ ‚ Û·Îˇı (ÓÒÚ‡ÚÓÍ)

	FOR lnCount = 1 TO 12 / m.tnPeriod
		lnDays = IIF(!m.llClnd,;
					 m.tnPeriod * 30,;
					 GOMONTH(CTOD('01/' + TRANSFORM(m.lnCount * m.tnPeriod, '@L 99') + '/';
					 			  + TRANSFORM(m.lnYear, '@L 9999')), 1) - CTOD('01/';
					 + TRANSFORM((m.lnCount - 1) * tnPeriod + 1, '@L 99') + '/';
					 + TRANSFORM(m.lnYear, '@L 9999')))
		lnSumm = m.lnBase * m.tnPerc * m.lnDays / IIF(!m.llClnd, 360, IIF(m.llLeap, 366, 365)) / 100
		lnBase = m.lnBase + m.lnSumm
	ENDFOR
RETURN m.lnBase * 100 - 100

ENDPROC
PROCEDURE copyfile
*  Œœ»–Œ¬¿Õ»≈ ‘¿…À¿ ¬Ã≈—“≈ — ¿“–»¡”“¿Ã» » ¬Œ«ÃŒ∆ÕŒ—“‹ﬁ œ≈–≈«¿œ»—»
* œ¿–¿Ã≈“–€ : ‘¿…À-»—“Œ◊Õ» , ‘¿…À-œ–»≈ÃÕ» , –≈∆»Ã œ≈–≈«¿œ»—»
* –≈«”À‹“¿“ : œ”—“¿ﬂ —“–Œ ¿ »À» —“–Œ ¿ — —ŒŒ¡Ÿ≈Õ»≈Ã Œ¡ Œÿ»¡ ≈
LPARAMETERS tcSourceFile AS String, tcTargetFile AS String, tlOverwrite AS Logical
	ASSERT VARTYPE(m.tcSourceFile) = 'C' AND VARTYPE(m.tcTargetFile) = 'C' AND VARTYPE(m.tlOverwrite) = 'L'
	* ≈—À» ‘¿…À-»—“Œ◊Õ»  —”Ÿ≈—“¬”≈“
	IF FILE(m.tcSourceFile, 1)
		* — Œœ»–”≈Ã ¬Ã≈—“≈ — ¿“–»¡”“¿Ã»
		IF This.Parent.oWinAPI.CopyFile(m.tcSourceFile, m.tcTargetFile, m.tlOverwrite)
			RETURN ''
		ENDIF
		* Œÿ»¡ ¿  Œœ»–Œ¬¿Õ»ﬂ ‘¿…À¿
		RETURN MSG_FILECOPYERROR + CHR_CR + m.tcSourceFile + ' -> ' + m.tcTargetFile
	ENDIF
* Õ≈ Õ¿…ƒ≈Õ ‘¿…À
RETURN MSG_FILENOTFOUND + CHR_CR + m.tcSourceFile

ENDPROC
PROCEDURE copyproperties
* ƒŒ¡¿¬»Ã » œ–»—¬Œ»Ã —¬Œ…—“¬¿  ŒÕ“≈…Õ≈–”
* This.CopyProperties(loSource, loTarget)
LPARAMETERS toSource AS Object, toTarget AS Object
LOCAL lcProperty AS String, luValue AS Variant
LOCAL ARRAY laProperty[1]
* ¬€¡≈–≈Ã ¬ Ã¿——»¬ “ŒÀ‹ Œ —¬Œ…—“¬¿
	ASSERT VARTYPE(m.toSource) = 'O' AND VARTYPE(m.toTarget) = 'O'
	AMEMBERS(laProperty, m.toSource)

	FOR EACH lcProperty IN laProperty
		* ¬€◊»—À»Ã «Õ¿◊≈Õ»≈ —¬Œ…—“¬¿ Œ¡⁄≈ “¿-»—“Œ◊Õ» ¿
		luValue = EVALUATE('toSource.' + m.lcProperty)

		IF VARTYPE(m.luValue) = 'C'
			luValue = ALLTRIM(m.luValue)
		ENDIF
		* ≈—À» ” ÷≈À≈¬Œ√Œ Œ¡⁄≈ “¿ Õ≈“ “¿ Œ√Œ —¬Œ…—“¬¿
		IF !PEMSTATUS(m.toTarget, m.lcProperty, 5)
			* ƒŒ¡¿¬»Ã —¬Œ…—“¬Œ » œ–»—¬Œ»Ã «Õ¿◊≈Õ»≈
			toTarget.AddProperty(m.lcProperty, m.luValue)
		ELSE
			* œ≈–≈œ–»—¬Œ»Ã «Õ¿◊≈Õ»≈, ≈—À» Õ≈ READONLY
			IF !PEMSTATUS(m.toTarget, m.lcProperty, 1)
				toTarget.&lcProperty = m.luValue
			ENDIF
		ENDIF
	ENDFOR

ENDPROC
PROCEDURE cryptkey
* Œ¡–¿“»ÃŒ≈ ÿ»‘–Œ¬¿Õ»≈ XOR œŒ —“–Œ Œ¬ŒÃ”  Àﬁ◊”.
* Ã¿ —»Ã¿À‹Õ”ﬁ  –»œ“Œ—“Œ… Œ—“‹ ƒ¿≈“  Àﬁ◊, —Œ—“ŒﬂŸ»… »« —À”◊¿…ÕŒ√Œ
* Õ¿¡Œ–¿ ASCII —»Ã¬ŒÀŒ¬ » –¿¬Õ€… œŒ ƒÀ»Õ≈ ÿ»‘–”≈ÃŒ… —“–Œ ≈.
* Õ¿œ–»Ã≈–  Œ√ƒ¿ —“–¿Õ»÷” –”—— Œ√Œ “≈’Õ»◊≈— Œ√Œ “≈ —“¿
* ÿ»‘–”≈Ã —“–¿Õ»÷≈… »« –ŒÃ¿Õ¿ Õ¿ ¿Õ√À»…— ŒÃ ﬂ«€ ≈ ;)
* CryptKey([#;-=!'], 'urfin') = 'VIKTOR'
* CryptKey('VIKTOR', 'urfin') = [#;-=!']
LPARAMETERS tcSourceString AS String, tÒKeyString AS String
LOCAL lÒCryptString AS String, lnKeyPosition AS Integer, lnSourcePosition AS Integer
	ASSERT VARTYPE(m.tcSourceString) = 'C' AND VARTYPE(m.tÒKeyString) = 'C'
	lÒCryptString = ''

	IF LEN(m.tcSourceString) > 0
		lnKeyPosition = 1

		FOR lnSourcePosition = 1 TO LEN(m.tcSourceString)
			lÒCryptString = m.lÒCryptString;
							+ CHR(BITXOR(ASC(SUBSTR(m.tcSourceString, m.lnSourcePosition, 1)),;
								  		 ASC(SUBSTR(m.tÒKeyString, m.lnKeyPosition, 1))))
			lnKeyPosition = IIF(m.lnKeyPosition = LEN(m.tÒKeyString), 1, m.lnKeyPosition + 1)
		ENDFOR
	ENDIF
RETURN m.lÒCryptString
ENDPROC
PROCEDURE cryptxor
* œ–Œ—“≈…ÿ¿ﬂ Œ¡–¿“»Ã¿ﬂ ÿ»‘–Œ¬ ¿ XOR ¡≈«  Àﬁ◊¿ 
* CryptXor('VIKTOR')) = 'WKHPJT'
* CryptXor('WKHPJT')) = 'VIKTOR'
LPARAMETERS tcString AS String
	ASSERT VARTYPE(tcString) = 'C'
	LOCAL lnCount AS Integer, lcResult AS String
	lcResult = ''

	FOR lnCount = 1 to LEN(m.tcString)
		lcResult = m.lcResult + CHR(BITXOR(MOD(m.lnCount, 255), ASC(SUBS(m.tcString, m.lnCount, 1))))
	ENDFOR
RETURN m.lcResult

ENDPROC
PROCEDURE datetostring
* ƒ¿“¿ —“–Œ Œ…
* StrDate(ldDate)			- ƒ¿“¿ + Ã≈—ﬂ÷ + √Œƒ = SET DATE LONG
* StrDate(ldDate, .T., .T.)	- Ã≈—ﬂ÷ + √Œƒ
* StrDate(ldDate, .T.)		- “ŒÀ‹ Œ Ã≈—ﬂ÷
* StrDate(ldDate, .F., T.)	- “ŒÀ‹ Œ √Œƒ
LPARAMETERS tdDate AS Date, tlMonth AS Logical, tlYear AS Logical
	IF VARTYPE(m.tdDate) = 'D' AND m.tdDate <> {}
		IF !tlMonth AND m.tlYear				&& “ŒÀ‹ Œ √Œƒ
			RETURN TRANSFORM(YEAR(m.tdDate)) + ' „.'
		ELSE
			LOCAL lnMonth AS Integer, lcString AS String
			lnMonth = MONTH(m.tdDate)                   

			DO CASE
			CASE m.lnMonth = 01
				lcString = 'ˇÌ‚‡'	+ IIF(m.tlMonth, '¸', 'ˇ')
			CASE m.lnMonth = 02
				lcString = 'ÙÂ‚‡Î'	+ IIF(m.tlMonth, '¸', 'ˇ')
			CASE m.lnMonth = 03
				lcString = 'Ï‡Ú'	+ IIF(m.tlMonth, '',  '‡')
			CASE m.lnMonth = 04
				lcString = '‡ÔÂÎ'	+ IIF(m.tlMonth, '¸', 'ˇ')
			CASE m.lnMonth = 05
				lcString = 'Ï‡'		+ IIF(m.tlMonth, 'È', 'ˇ')
			CASE m.lnMonth = 06
				lcString = 'Ë˛Ì'	+ IIF(m.tlMonth, '¸', 'ˇ')
			CASE m.lnMonth = 07
				lcString = 'Ë˛Î'	+ IIF(m.tlMonth, '¸', 'ˇ')
			CASE m.lnMonth = 08
				lcString = '‡‚„ÛÒÚ'	+ IIF(m.tlMonth, '',  '‡')
			CASE m.lnMonth = 09
				lcString = 'ÒÂÌÚˇ·'+ IIF(m.tlMonth, '¸', 'ˇ')
			CASE m.lnMonth = 10
				lcString = 'ÓÍÚˇ·'	+ IIF(m.tlMonth, '¸', 'ˇ')
			CASE m.lnMonth = 11
				lcString = 'ÌÓˇ·'	+ IIF(m.tlMonth, '¸', 'ˇ')
			CASE m.lnMonth = 12
				lcString = '‰ÂÍ‡·'	+ IIF(m.tlMonth, '¸', 'ˇ')
			ENDCASE

			DO CASE
			CASE !m.tlMonth AND !m.tlYear		&& ƒ¿“¿ + Ã≈—ﬂ÷ + √Œƒ
				RETURN LTRIM(STR(DAY(m.tdDate))) + ' ' + m.lcString + ' ';
					   + TRANSFORM(YEAR(m.tdDate)) + ' „.'
			CASE m.tlMonth AND m.tlYear		&& Ã≈—ﬂ÷ + √Œƒ
				RETURN m.lcString + ' ' + TRANSFORM(YEAR(m.tdDate)) + ' „.'
			OTHERWISE						&& “ŒÀ‹ Œ Ã≈—ﬂ÷
				RETURN m.lcString
			ENDCASE
		ENDIF
	ENDIF
RETURN ''
ENDPROC
PROCEDURE dectohex
* DEC -> HEX
* 15			-> '0000000F'
* 4294967295	-> 'FFFFFFFF'
LPARAMETERS lnDecimal AS Integer
	ASSERT VARTYPE(m.lnDecimal) = 'N'
	ASSERT BETWEEN(m.lnDecimal, -TYPE_INTEGER, TYPE_INTEGER)
RETURN SUBSTR(TRANSFORM(m.lnDecimal, '@0'), 3)
ENDPROC
PROCEDURE directorytoarray
* ƒŒœŒÀÕ»Ã Ã¿——»¬ TAFILENAME »Ã≈Õ¿Ã» ‘¿…ÀŒ¬,
* ”ƒŒ¬À≈“¬Œ–ﬂﬁŸ»’ Ã¿— ≈ TCPATHFILEMASK
* –≈«”À‹“¿“ -  ŒÀ»◊≈—“¬Œ ƒŒ¡¿¬À≈ÕÕ€’ ›À≈Ã≈Õ“Œ¬ Ã¿——»¬¿
* LOCAL ARRAY laFileName[1] && Ã‡ÒÒË‚ ËÏÂÌ Ù‡ÈÎÓ‚
* This.DirectoryToArray(@laFileName, lcPath + '*.DBF')
* P.S. œ–»Ã≈Õﬂ≈“—ﬂ –≈ƒ Œ »À» Õ» Œ√ƒ¿ ;)
LPARAMETERS taFileName, tcPathFileMask AS String, tcAttribute AS String
LOCAL lnFileCount AS Integer, lnArraySize AS Integer
LOCAL ARRAY laDirectory[1, 5]
	ASSERT TYPE('taFileName', 1) = 'A'
	tcPathFileMask = IIF(VARTYPE(m.tcPathFileMask) = 'C',;
						 m.tcPathFileMask,;
						 FULLPATH('') + '*.*')
	tcAttribute = IIF(VARTYPE(m.tcAttribute) = 'C', m.tcAttribute, "HS")
	lnArraySize = IIF(VARTYPE(m.taFileName) = 'C', ALEN(taFileName, 1), 0)

	FOR lnFileCount = 1 TO ADIR(laDirectory, m.tcPathFileMask, m.tcAttribute)
		DIMENSION taFileName[m.lnArraySize + m.lnFileCount]
		taFileName[m.lnArraySize + m.lnFileCount] = laDirectory[m.lnFileCount, 1]
	ENDFOR
RETURN m.lnFileCount - 1
ENDPROC
PROCEDURE div
*‰ÂÎÂÌËÂ Ò Û˜ÂÚÓÏ „‡ÌË˜Ì˚ı ÒËÚÛ‡ˆËÈ
LPARAMETERS tn1, tn2
LOCAL lnResult
	IF m.tn2 = 0
		RETURN .0
	ELSE
		RETURN m.tn1 / m.tn2
	ENDIF
RETURN m.lnResult
ENDPROC
PROCEDURE divmat
*‰ÂÎÂÌËÂ Ò Û˜ÂÚÓÏ „‡ÌË˜Ì˚ı ÒËÚÛ‡ˆËÈ(ÔÓ Ï‡ÚÏ‡ÚËÍÂ)
LPARAMETERS tn1, tn2
LOCAL lnResult
	TRY
		lnResult = m.tn1 / m.tn2
	CATCH
		lnResult = 9999999999999999999.
	ENDTRY
RETURN m.lnResult
ENDPROC
PROCEDURE erasefile
* ”ƒ¿À≈Õ»≈ ‘¿…À¿ C œ–≈ƒ¬¿–»“≈À‹Õ€Ã —Õﬂ“»≈Ã ¿“–»¡”“Œ¬ R/S/H
* –≈«”À‹“¿“ : œ”—“¿ﬂ —“–Œ ¿ »À» —“–Œ ¿ — —ŒŒ¡Ÿ≈Õ»≈Ã Œ¡ Œÿ»¡ ≈
LPARAMETERS tcPathFile AS String
LOCAL lcMessage AS String
*!*		ASSERT VARTYPE(m.tcPathFile) = 'C'
	lcMessage = ''

	IF FILE(m.tcPathFile, 1)
		* ¬€—“¿¬»Ã ¿“–»¡”“ NORMAL
		IF This.Parent.oWinAPI.SetAttributes(m.tcPathFile)
			TRY
				* ”ƒ¿À»Ã ‘¿…À
				ERASE (m.tcPathFile)
			CATCH
				* Œÿ»¡ ¿ ”ƒ¿À≈Õ»ﬂ ‘¿…À¿
				lcMessage = MSG_FILEERASEERROR + CHR_CR + m.tcPathFile
			ENDTRY
		ELSE
			* Œÿ»¡ ¿ ”—“¿ÕŒ¬ » ¿“–»¡”“Œ¬ ‘¿…À¿
			lcMessage = MSG_FILESETATTRERROR + CHR_CR + m.tcPathFile
		ENDIF
	ENDIF
RETURN m.lcMessage
ENDPROC
PROCEDURE fddformat
* FORMAT FLOPPY DRIVE (Õ≈ œ¿ÿ≈“ œŒƒ XP)

RUN /N rundll32.exe shell32.dll, SHFormatDrive
ENDPROC
PROCEDURE getbias
* –¿«Õ»÷¿ ¬ Ã»Õ”“¿’ Ã≈∆ƒ” COORDINATED UNIVERSAL TIME (UTC) AND LOCAL TIME 
* PS1 : ƒÀﬂ ŒÃ— ¿ = - 360 Ã»Õ”“
* PS2 : UTC = LOCAL TIME + BIAS 

RETURN This.StringToLong(LEFT(This.Parent.oWinApi.GetTimeZoneInformation(), 4))
ENDPROC
PROCEDURE getfileattributes
* ¬Œ«¬–¿Ÿ¿≈“ —“–Œ ” — ¿“–»¡”“¿Ã» ‘¿…À¿ »À»  ¿“¿ÀŒ√¿
* Õ¿œ–»Ã≈– 'RASHD' »À» '.....', »À» œ”—“”ﬁ —“–Œ ”,
* ≈—À» ‘¿…À »À»  ¿“¿ÀŒ√ Õ≈ Õ¿…ƒ≈Õ
LPARAMETERS tcPathFileOrFolderName AS String
LOCAL ARRAY laDir[1, 5]
	IF ADIR(laDir, m.tcPathFileOrFolderName, 'SHD') = 1
		RETURN laDir[1, 5]
	ELSE
		RETURN ''
	ENDIF

ENDPROC
PROCEDURE getfilesize
* –¿«Ã≈– ‘¿…À¿ ¬ ¡¿…“¿’
* ≈—À» ‘¿…À Õ≈ Õ¿…ƒ≈Õ ¬Œ«¬–¿Ÿ¿≈“ -1
LPARAMETERS lcPathName AS Character
ASSERT VARTYPE(m.lcPathName) = 'C'
LOCAL lcCompatible, lnFileSize
	lnFileSize = -1

	IF FILE(m.lcPathName, 1)
		lcCompatible = SET('COMPATIBLE')
		SET COMPATIBLE ON
		lnFileSize = FSIZE(m.lcPathName)
		SET COMP &lcCompatible
	ENDIF
RETURN m.lnFileSize
ENDPROC
PROCEDURE getfont
* ¬€¡Œ– »=“¿ÕŒ¬ ¿ ÿ–»‘“¿ ƒÀﬂ Œ¡⁄≈ “¿ loObject »À» ¿ “»¬ÕŒ√Œ
LPARAMETERS loObject AS Object
LOCAL lcGetFont AS String
	IF VARTYPE(m.loObject) <> 'O'
		IF TYPE('Application.ActiveForm.ActiveControl') <> 'O'
			RETURN
		ELSE
			loObject = Application.ActiveForm.ActiveControl
		ENDIF
	ENDIF

	IF PEMSTATUS(m.loObject, 'FontName', 5)
		* Õ¿«¬¿Õ»≈, –¿«Ã≈–, —“»À‹
		WITH loObject
			lcGetFont = GETFONT(.FontName, .FontSize,;
								IIF(.FontBold,'B','') + IIF(.FontItalic,'I',''))

			IF !EMPTY(m.lcGetFont)
				.FontName = GETWORDNUM(m.lcGetFont, 1, ',')
				.FontSize = VAL(GETWORDNUM(m.lcGetFont, 2, ','))
				.FontBold = 'B' $ GETWORDNUM(m.lcGetFont, 3, ',')
				.FontItalic = 'I' $ GETWORDNUM(m.lcGetFont, 3, ',')
			ENDIF
		ENDWITH
	ENDIF

ENDPROC
PROCEDURE getgdiguiddescription
*  –¿“ ¿ﬂ »À» œŒÀÕ¿ﬂ –¿—ÿ»‘–Œ¬ ¿ GDIPLUS GUID
* œ¿–¿Ã≈“–€ : —“–Œ ¿ VARBINARY 16,  –¿“ ¿ﬂ »À» œŒÀÕ¿ﬂ –¿—ÿ»‘–Œ¬ ¿
LPARAMETERS tqGUID AS Variant, tlFullDescription AS Logical
	DO CASE
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_BMP
		RETURN IIF(!m.tlFullDescription, 'BMP', 'Windows bitmap format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_JPEG
		RETURN IIF(!m.tlFullDescription, 'JPG', 'Joint Photographic Experts Group format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_GIF
		RETURN IIF(!m.tlFullDescription, 'GIF', 'Graphics Interchange Format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_ICON
		RETURN IIF(!m.tlFullDescription, 'ICO', 'Icon format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_TIFF
		RETURN IIF(!m.tlFullDescription, 'TIF', 'Tag Image File Format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_PNG
		RETURN IIF(!m.tlFullDescription, 'PNG', 'Portable Network Graphics format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_WMF
		RETURN IIF(!m.tlFullDescription, 'WMF', 'Windows Metafile format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_EMF
		RETURN IIF(!m.tlFullDescription, 'EMF', 'Enhanced Metafile format')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_EXIF
		RETURN IIF(!m.tlFullDescription, 'JPE', 'Exchangeable Image File format')	&& Exif is a variation of JPEG, used by almost all digital cameras
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_MEMORYBMP
		RETURN IIF(!m.tlFullDescription, 'BMP', 'Image was constructed from a memory bitmap')
	CASE m.tqGUID = GDIPLUS_IMAGEFORMAT_UNDEFINED
		RETURN IIF(!m.tlFullDescription, '', 'GDI+ is unable to determine the format')
	OTHERWISE
		RETURN IIF(!m.tlFullDescription, '', 'GDI+ GUID not recognized')
	ENDCASE

ENDPROC
PROCEDURE getimageinformation
* —“–Œ ¿ — »Õ‘Œ–Ã¿÷»≈… Œ ‘¿…À≈ — »«Œ¡–¿∆≈Õ»≈Ã
LPARAMETERS tcPathFileExt AS String
LOCAL lcInfo AS String, lnSize AS String
	ASSERT VARTYPE(m.tcPathFileExt) = 'C'

	IF !FILE(m.tcPathFileExt)
		* Õ≈ Õ¿…ƒ≈Õ ‘¿…À
		RETURN MSG_FILENOTFOUND
	ENDIF

	WITH This.Parent
		IF !EMPTY(.oWinAPI.GdipGetImageRawFormat(m.tcPathFileExt))
			* –¿«Ã≈– ¬ œ» —≈Àﬂ’
			lcInfo = TRANSFORM(.oWinAPI.GdipGetImageWidth(m.tcPathFileExt))
			lcInfo = m.lcInfo + 'x' + TRANSFORM(.oWinAPI.GdipGetImageHeight(m.tcPathFileExt))
			* –¿«Ã≈– ¬ ¡¿…“¿’
			lnSize = This.GetFileSize(m.tcPathFileExt)

			DO CASE
			CASE m.lnSize < 1024
				lcInfo = m.lcInfo + ' ' + TRANSFORM(m.lnSize) + ' Byte'
			CASE m.lnSize < 1024 * 1024
				lcInfo = m.lcInfo + ' ' + TRANSFORM(ROUND(m.lnSize / 1024, 0)) + ' Kb.'
			CASE m.lnSize < 1024 * 1024 * 1024
				lcInfo = m.lcInfo + ' ' + TRANSFORM(ROUND(m.lnSize / 1024 / 1024, 0)) + ' Mb.'
			OTHERWISE
				lcInfo = m.lcInfo + ' ' + TRANSFORM(ROUND(m.lnSize / 1024 / 1024 / 1024, 0)) + ' Gb.'
			ENDCASE
			* Õ¿«¬¿Õ»≈ ‘Œ–Ã¿“¿ »«Œ¡–¿∆≈Õ»ﬂ
			RETURN m.lcInfo + ' ' + This.GetGDIGUIDDescription(.oWinAPI.GdipGetImageRawFormat(m.tcPathFileExt), .T.)
		ELSE
			* Õ≈¬≈–Õ€… ‘Œ–Ã¿“ »«Œ¡–¿∆≈Õ»ﬂ
			RETURN MSG_PICTUREBADFORMAT
		ENDIF
	ENDWITH

ENDPROC
PROCEDURE getnextfilename
*ÒÎÂ‰Û˛˘ÂÂ ËÏˇ Ù‡ÈÎ‡ - ‰Ó·‡‚ÎˇÂÚ ÌÛÏÂ‡ÚÓ ‚ ÍÓÌÂˆ ËÏÂÌË
LPARAMETERS tcFileName
LOCAL lcPath, lcFileName, lcFileExt, lnI
	lcPath = JUSTPATH(m.tcFileName)
	lcFileName = JUSTSTEM(m.tcFileName)
	lcFileExt = JUSTEXT(m.tcFileName)
	lnI = 1

	DO WHILE FILE(m.lcPath + '\' + m.lcFileName + LTRIM(TRANSFORM(m.lnI)) + '.' + m.lcFileExt)
		lnI = m.lnI + 1
	ENDDO
RETURN m.lcPath + '\' + m.lcFileName + LTRIM(TRANSFORM(m.lnI)) + '.' + m.lcFileExt
ENDPROC
PROCEDURE getrandomnumber
* ¬Œ«¬P¿Ÿ¿≈“ ÷≈ÀŒ≈ »« »Õ“≈–¬¿À¿
* ‘”Õ ÷»ﬂ »« HELP FPD2.6 - VFP8.0 Õ≈¬≈–Õ¿ :
* INT((gnUpper - gnLower + 1) * RAND( ) + gnLower)
LPARAMETERS tnMinimum AS Integer, tnMaximum AS Integer
	ASSERT VARTYPE(m.tnMinimum) = 'N' AND VARTYPE(m.tnMaximum) = 'N'
RETURN ROUND(RAND() * (m.tnMaximum - m.tnMinimum) + m.tnMinimum, 0)

ENDPROC
PROCEDURE gettagstring
*¬˚ÌËÏ‡ÂÚ ÒÚÓÍÛ ÏÂÊ‰Û Á‡‰‡ÌÌ˚ÏË Ú˝„‡ÏË
LPARAMETERS tcString as String, tcTagBegin as String, tcTagEnd as String
LOCAL lnWordCount as Integer
	IF EMPTY(m.tcTagBegin)
		tcTagBegin = ' '
	ENDIF

	IF EMPTY(m.tcTagEnd)
		tcTagEnd = ' '
	ENDIF

	lnWordCount = OCCURS(m.tcDelimiter, m.tcString) + 1

	IF m.lnWordCount = 1 AND LENC(m.tcString) = 0
		lnWordCount = 0
	ENDIF
RETURN m.lnWordCount
ENDPROC
PROCEDURE gettempfile
* VFP TEMP FOLDER + ”Õ» ¿À‹ÕŒ≈ »Ãﬂ ‘¿…À¿ œŒ GUID ƒÀ»ÕÕŒ… 32 ¡¿…“¿ + '.TMP'
* Õ¿œ–»Ã≈– : 'C:\WINDOWS\TEMP\96C1E335B6C241C79602295CD99988E3.TMP'
LPARAMETERS tcExtention AS String
	tcExtention = '.' + IIF(VARTYPE(m.tcExtention)='C', ALLTRIM(m.tcExtention), 'tmp')
RETURN ADDBS(SYS(2023)) + This.GetTempName() + m.tcExtention
ENDPROC
PROCEDURE gettempname
* ”Õ» ¿À‹Õ¿ﬂ —“–Œ ¿ ƒÀ»ÕÕŒ… 32 ¡¿…“¿ œŒ GUID
* Õ¿œ–»Ã≈– : '96C1E335B6C241C79602295CD99988E3'
RETURN CHRTRAN(This.Parent.oWinAPI.GetGuid(), '{-}', '')

ENDPROC
PROCEDURE gettextstringwidth
* ÿ»–»Õ¿ “≈ —“Œ¬Œ… —“–Œ » ¬ œ» —≈Àﬂ’
* This.GetTextStringWidth('SomeTextString', 'Tahoma', 8, 'N')
LPARAMETERS tcString, tcFontName, tnFontSize, tcFontStyle
	ASSERT VARTYPE(m.tcString) = 'C'
	tcFontName = IIF(VARTYPE(m.tcFontName) = 'C', m.tcFontName, WFONT(1))
	tnFontSize = IIF(VARTYPE(m.tnFontSize) = 'C', m.tnFontSize, WFONT(2))
	tcFontStyle	 =  IIF(VARTYPE(m.tcFontStyle) = 'C', m.tcFontStyle, WFONT(3))
RETURN TXTWIDTH(m.tcString, m.tcFontName, m.tnFontSize, m.tcFontStyle);
	   * FONTMETRIC(6, m.tcFontName, m.tnFontSize, m.tcFontStyle)
ENDPROC
PROCEDURE getwordcount
*◊ËÒÎÓ ÒÎÓ‚ ‚ ÔÂ‰ÎÓÊÂÌËË
LPARAMETERS tcString as String, tcDelimiter as String
LOCAL lnWordCount as Integer
*!*		IF LEN(m.tcString) = 0
*!*			RETURN 1
*!*		ENDIF
	IF EMPTY(m.tcString) OR VARTYPE(m.tcString) <> 'C'
		tcString = ''
	ENDIF

	IF EMPTY(m.tcDelimiter) OR VARTYPE(m.tcDelimiter) <> 'C'
		tcDelimiter = ' '
	ENDIF
	*ÒÓÁ‰‡‰ËÏ ÍÂ¯Â‚Û˛ ÔÂÂÏÂÌÌÛ˛
	IF TYPE("THIS.Parent.oVars") = "O"
		WITH THIS.Parent.oVars
			IF TYPE("THIS.Parent.oVars.cGetWords") = "U"
				.AddProperty("cGetWords", '')
				.AddProperty("cGetDelimiter", '')
				.AddProperty("aGetWords[1]")
			ENDIF

			IF .cGetWords == m.tcString AND .cGetDelimiter == m.tcDelimiter
				lnWordCount = ALEN(.aGetWords, 1)
			ELSE
				.cGetWords = m.tcString
				.cGetDelimiter = m.tcDelimiter
				lnWordCount = ALINES(.aGetWords, m.tcString, 2, m.tcDelimiter)
			ENDIF
		ENDWITH
	ENDIF
*!*		lnWordCount = OCCURS(m.tcDelimiter, m.tcString) + 1

*!*		IF m.lnWordCount = 1 AND LENC(m.tcString) = 0
*!*			lnWordCount = 0
*!*		ENDIF
RETURN m.lnWordCount
ENDPROC
PROCEDURE getwordnum
*¬˚ÌËÏ‡ÂÚ N-ÓÂ ÒÎÓ‚Ó ËÁ ÔÂ‰ÎÓÊÂÌËˇ
LPARAMETERS tcString as String, tnNumWord as Integer, tcDelimiter as String
LOCAL lnCnt as Integer
*!*		lnFirst as Integer, lnSecond as Integer,, lnLenDelim as String;
*!*		  lnLenString as Integer, lcResult as String
	IF EMPTY(m.tcString) OR VARTYPE(m.tcString) <> 'C'
		tcString = ''
	ENDIF

	IF EMPTY(m.tcDelimiter) OR VARTYPE(m.tcDelimiter) <> 'C'
		tcDelimiter = ' '
	ENDIF

	lcResult = ''
	lnCnt = THIS.getWordCount(m.tcString, m.tcDelimiter)

	IF m.lnCnt <> 0 AND m.lnCnt >= m.tnNumWord
		lcResult = THIS.Parent.oVars.aGetWords[m.tnNumWord]
	ENDIF

*!*		IF !(m.tnNumWord=0 OR m.lnLenString=0 OR m.lnLenDelim=0)
*!*			IF m.tnNumWord=1
*!*				lnFirst=1
*!*			ELSE
*!*				lnFirst=ATC(m.tcDelimiter, m.tcString, m.tnNumWord-1)
*!*				lnFirst=IIF(m.lnFirst=0, m.lnLenString, m.lnFirst+m.lnLenDelim)
*!*			ENDIF

*!*			lnSecond=ATC(m.tcDelimiter, m.tcString, m.tnNumWord)
*!*			lnSecond=IIF(m.lnSecond=0, m.lnLenString+m.lnLenDelim, m.lnSecond)

*!*			IF m.lnFirst<>m.lnSecond
*!*				lcResult=SUBSTRC(m.tcString, m.lnFirst, m.lnSecond-m.lnFirst)
*!*			ENDIF
*!*		ENDIF
RETURN m.lcResult
ENDPROC
PROCEDURE hextodec
* HEX -> DEC
* 'F' -> 15
LPARAMETERS lcHexadecimal AS String    						 		&& '0' <= s <= 'FFFFFFFF'
	ASSERT VARTYPE(m.lcHexadecimal) = 'C'
RETURN EVALUATE('0x' + m.lcHexadecimal)

ENDPROC
PROCEDURE isdirectoryreadonly
* ﬂ¬Àﬂ≈“—ﬂ À»  ¿“¿ÀŒ√ ƒŒ—“”œÕ€Ã ƒÀﬂ «¿œ»—» ?
LPARAMETERS tcDirectory AS String
LOCAL lcPathFileName AS String
	ASSERT VARTYPE(m.tcDirectory) = 'C'
	lcPathFileName = ADDBS(ALLTRIM(m.tcDirectory)) + This.GetTempName()

	IF FCLOSE(FCREATE(m.lcPathFileName))
		ERASE (m.lcPathFileName)
		RETURN .F.
	ENDIF
ENDPROC
PROCEDURE isfileequal
* –¿«À»◊¿ﬁ“—ﬂ À» ‘¿…À€ TCPATHFILE1 » TCPATHFILE2
* œŒ ƒ¿“≈ » ¬–≈Ã≈Õ» ÃŒƒ»‘» ¿÷»», –¿«Ã≈–” »À» ¿“–»¡”“¿Ã ?
* P.S. —–¿¬Õ»¬¿≈Ã ¬–≈Ãﬂ ÃŒƒ»‘» ¿÷»» ‘¿…À¿ — “Œ◊ÕŒ—“‹ﬁ ƒŒ “–≈’ —≈ ”Õƒ !
* (–¿—’Œ∆ƒ≈Õ»ﬂ œŒﬂ¬Àﬂﬁ“—ﬂ œ–»  Œœ»–Œ¬¿Õ»» — FAT16/32 Õ¿ NTFS » Õ¿Œ¡Œ–Œ“)
LPARAMETERS tcPathFile1 as String, tcPathFile2 as String
LOCAL ltTime1 as Datetime, ltTime2 as Datetime,;
	lnSize1 as Integer, lnSize2 as Integer,;
	lcAttr1 as String, lcAttr2 as String
LOCAL ARRAY laFile1[1, 5], laFile2[1, 5]
	ASSERT FILE(m.tcPathFile1)
	ASSERT FILE(m.tcPathFile2)
	ADIR(laFile1, m.tcPathFile1, 'HS')
	ADIR(laFile2, m.tcPathFile2, 'HS')
	* ƒ¿“¿ » ¬–≈Ãﬂ
	ltTime1 = CTOD(LEFT(DTOS(laFile1[1, 3]), 4) + '-' + SUBSTR(DTOS(laFile1[1, 3]), 5, 2) +;
				   '-' + RIGHT(DTOS(laFile1[1, 3]), 2) + 'T' + laFile1[1, 4])
	ltTime2 = CTOD(LEFT(DTOS(laFile2[1, 3]), 4) + '-' + SUBSTR(DTOS(laFile2[1, 3]), 5, 2) +;
				   '-' + RIGHT(DTOS(laFile2[1, 3]), 2) + 'T' + laFile2[1, 4])
	* –¿«Ã≈–€
	lnSize1 = laFile1[1, 2]
	lnSize2 = laFile2[1, 2]
	* ¿“–»¡”“€
	lcAttr1 = laFile1[1, 5]
	lcAttr2 = laFile2[1, 5]
RETURN ABS(m.ltTime1 - m.ltTime2) < 4 AND m.lnSize1 = m.lnSize2 AND m.lcAttr1 = m.lcAttr2
ENDPROC
PROCEDURE isfileused
* ≈—“‹ À»  ¿ »≈ À»¡Œ œ–»◊»Õ€ Õ≈ œŒ«¬ŒÀﬂﬁŸ»≈ Œ“ –€“‹ ‘¿…À Õ¿ «¿œ»—‹ ?
* (”∆≈ Œ=€“ / Œ“ –€“ ƒ–”√»Ã / Õ≈“ ‘¿…À¿ / ¿“–»¡”“ RO » “.œ.)

LPARAMETERS tcFile AS String
LOCAL lnHandle AS Integer
	lnHandle = FOPEN(m.tcFile, 1)
RETURN !(m.lnHandle > 0 AND FCLOSE(m.lnHandle))
ENDPROC
PROCEDURE isinternetconnected
* œŒƒ Àﬁ◊≈Õ À»  ŒÃœ‹ﬁ“≈–   »Õ“≈–Õ≈“” ?
* 00 - œŒƒ Àﬁ◊≈Õ»≈ Œ“—”“—“¬”≈“
* 16 - RAS ”—“¿ÕŒ¬À≈Õ
* 32 - –¿¡Œ“¿≈Ã OFFLINE
RETURN !INLIST(This.Parent.oWinAPI.InternetGetConnectedState(), 0, 16, 32, 48)

ENDPROC
PROCEDURE ispicturevalid
* ﬂ¬Àﬂ≈“—ﬂ À» —Œƒ≈–∆»ÃŒ≈ ‘¿…À¿  ŒŒ–≈ “Õ€Ã — “Œ◊ » «–≈Õ»ﬂ GDI+
LPARAMETERS tcPathFileExt AS String
	ASSERT VARTYPE(m.tcPathFileExt)='C'

	IF FILE(m.tcPathFileExt)
		RETURN !EMPTY(This.Parent.oWinAPI.GdipGetImageRawFormat(m.tcPathFileExt))
	ENDIF
RETURN .F.
ENDPROC
PROCEDURE makedirectory
* —Œ«ƒ¿Õ»≈  ¿“¿ÀŒ√¿
* –≈«”À‹“¿“ : œ”—“¿ﬂ —“–Œ ¿ »À» —“–Œ ¿ — —ŒŒ¡Ÿ≈Õ»≈Ã Œ¡ Œÿ»¡ ≈
LPARAMETERS tcDirectory AS String
LOCAL lcMessage AS String
	ASSERT VARTYPE(m.tcDirectory)='C'
	lcMessage=''
	* ≈—À»  ¿“¿ÀŒ√¿ Õ≈“
	IF !DIRECTORY(m.tcDirectory, 1)
		TRY
			* —Œ«ƒ¿ƒ»Ã  ¿“¿ÀŒ√
			MKDIR (m.tcDirectory)
		CATCH
			* Œÿ»¡ ¿ —Œ«ƒ¿Õ»ﬂ  ¿“¿ÀŒ√¿
			lcMessage = MSG_FOLDERMAKEERROR + CHR_CR + m.tcDirectory
		ENDTRY
	ENDIF
RETURN m.lcMessage

ENDPROC
PROCEDURE makedirectorytree
* —Œ«ƒ¿Õ»≈ ÷≈œŒ◊ » ¬ÀŒ∆≈ÕÕ€’  ¿“¿ÀŒ√Œ¬ (Œ¡≈–“ ¿ ƒÀﬂ MKDIR)
* ¬—“–Œ≈ÕÕ¿ﬂ ‘”Õ ÷»ﬂ VFP MKDIR ¬€ƒ¿≈“ Œÿ»¡ ” - " ¿“¿ÀŒ√ ”∆≈ —”Ÿ≈—“¬”≈“",
* ≈—À» ¬Õ”“–» ÷≈œŒ◊ » œ¿œŒ  ≈—“‹ — –€“€…  ¿“¿ÀŒ√ » Õ¿ƒŒ —Œ«ƒ¿“‹ œŒ—À≈ Õ≈√Œ
* ¡ŒÀ≈≈ ŒƒÕŒ√Œ ¬ÀŒ∆≈ÕÕŒ√Œ œŒƒ ¿“¿ÀŒ√¿
LPARAMETERS tcDirectory AS String
LOCAL llSuccess AS Logical, lcDirectory AS String, lnCount AS Integer
	ASSERT VARTYPE(m.tcDirectory) = 'C'

	IF !DIRECTORY(m.tcDirectory, 1)
		llSuccess = .T.
		lcDirectory = ''

		FOR lnCount = 1 TO GETWORDCOUNT(m.tcDirectory, '\')
			lcDirectory = m.lcDirectory + GETWORDNUM(m.tcDirectory, m.lnCount, '\') + '\'

			IF !DIRECTORY(m.lcDirectory, 1)
				TRY
					MKDIR (m.lcDirectory)
				CATCH
					llSuccess = .F.
				ENDTRY

				IF !m.llSuccess
					RETURN .F.
				ENDIF
			ENDIF
		ENDFOR
	ENDIF
ENDPROC
PROCEDURE monthbetween
*  ŒÀ»◊≈—“¬Œ Ã≈—ﬂ÷≈¬ Ã≈∆ƒ” ƒ¬”Ãﬂ ƒ¿“¿Ã»
LPARAMETERS tdBegin AS Date, tdEnd AS Date
RETURN 12 * (YEAR(m.tdEnd) - YEAR(m.tdBegin)) + MONTH(m.tdEnd) - MONTH(m.tdBegin)

ENDPROC
PROCEDURE pixeltofoxel
* œ–≈Œ¡–¿«=Õ»≈ œ» —≈À≈… ¬ ‘Œ —≈À» : This.PixelToFoxel(@lnRow, @lnColumn)
*  ŒÀ»◊≈—“¬Œ œ» —≈À≈… Õ¿ ‘Œ —≈À‹ «¿¬»—»“ Œ“ –¿«–≈ÿ≈Õ»ﬂ › –¿Õ¿ » Õ¿—“–Œ≈  WINDOWS
* Foxels (A Visual FoxPro term. Equivalent to the maximum height and average width of a character in the current font.)
* Pixels (smallest unit of monitor or printer resolution)
LPARAMETERS tnPix AS Integer, tlY AS Integer
* –≈ÿ≈Õ»≈=–ŒœŒ–÷»» Œœ–≈ƒ≈À»Ã — ŒÀ‹ » ‘Œ —≈ÀﬂÃ –¿¬Õ€ tnRow » tnColumn œ» —≈À≈…
	IF m.tlY
		RETURN m.tnPix / FONTMETRIC(1, _Screen.FontName, _Screen.FontSize)
	ELSE
		RETURN m.tnPix / FONTMETRIC(6, _Screen.FontName, _Screen.FontSize)
	ENDIF
ENDPROC
PROCEDURE pixeltotwip
#DEFINE LOGPIXELSX 88 && Logical PIXELS/inch IN X  
#DEFINE LOGPIXELSY 90 && Logical PIXELS/inch IN Y  
LPARAMETERS tÒParam
LOCAL lhDC, lnRetVal  
	lnRetVal = 0  

	IF VARTYPE(m.tÒParam) = "C" AND !EMPTY(m.tÒParam);
	   AND (UPPER(m.tÒParam) == "X" OR UPPER(m.tÒParam) == "Y")
		tÒParam = UPPER(m.tÒParam)
	ELSE
		RETURN 0
	ENDIF

	lhDC = THIS.oWinApi.GetDC(_VFP.hWnd)

	IF m.tÒParam == "X"
		lnRetVal = 1440 / THIS.oWinApi.GetDeviceCaps(m.lhDC, LOGPIXELSX) &&*(13/FONTMETRIC(1,"MS Sans Serif",8,""))
	ENDIF

	IF m.tÒParam == "Y"
		lnRetVal = 1440 / THIS.oWinApi.GetDeviceCaps(m.lhDC, LOGPIXELSY) &&*(11/FONTMETRIC(7,"MS Sans Serif",8,""))
	ENDIF

	THIS.oWinApi.ReleaseDC(_VFP.hWnd, m.lhDC)
RETURN m.lnRetVal
ENDPROC
PROCEDURE playwav
* œ–Œ»√–¿“‹ WAV-‘¿…À

LPARAMETERS tcSoundFile
	ASSERT FILE(m.tcSoundFile)
	SET BELL TO (m.tcSoundFile)
	?? CHR(7)

ENDPROC
PROCEDURE pointertolong
* RETURN NUMBER FROM A POINTER TO DWORD
LPARAMETERS tnPointer
LOCAL lcStrDWORD
	lcStrDWORD = REPLICATE(CHR(0), 4)
	* Moves memory either forward or backward, aligned or unaligned, in 4-byte blocks, followed by any remaining bytes
	DECLARE RtlMoveMemory IN Kernel32 STRING @, INTEGER, INTEGER
	RtlMoveMemory(@lcStrDWORD, m.tnPointer, 4)
	CLEAR DLLS 'RtlMoveMemory'
RETURN This.StringToLong(m.lcStrDWORD)
ENDPROC
PROCEDURE pointertostring
* POINTE=O STRING
LPARAMETERS tnPointer
LOCAL lcResult, lnLPStr, lnSLen
	lnLPStr = PointerToLong(m.tnPointer)
	* Moves memory either forward or backward, aligned or unaligned, in 4-byte blocks, followed by any remaining bytes
	DECLARE RtlMoveMemory IN Kernel32 STRING @, INTEGER, INTEGER
	* Retrieves the length of the specified wide string
	DECLARE INTEGER lstrlenW IN Kernel32 INTEGER
	lnSLen = lstrlenW(m.lnLPStr) * 2
	lcResult = REPLICATE(CHR(0), m.lnSLen)
	RtlMoveMemory(@lcResult, m.lnLPStr, m.lnSLen)

	CLEAR DLLS 'lstrlenW', 'RtlMoveMemory'
RETURN STRCONV(STRCONV(m.lcResult, 6), 2)

ENDPROC
PROCEDURE removedirectory
* ”ƒ¿À≈Õ»≈  ¿“¿ÀŒ√¿
* –≈«”À‹“¿“ : œ”—“¿ﬂ —“–Œ ¿ »À» —“–Œ ¿ — —ŒŒ¡Ÿ≈Õ»≈Ã Œ¡ Œÿ»¡ ≈
LPARAMETERS tcDirectory AS String
LOCAL lcMessage AS String
	ASSERT VARTYPE(m.tcDirectory) = 'C'
	lcMessage = ''
	* ≈—À»  ¿“¿ÀŒ√ —”Ÿ≈—“¬”≈“
	IF DIRECTORY(m.tcDirectory, 1)
		* ¬€—“¿¬»Ã ¿“–»¡”“ NORMAL (RMDIR Õ≈ ”ƒ¿Àﬂ≈“ READONLY  ¿“¿ÀŒ√»)
		IF This.Parent.oWinAPI.setAttributes(m.tcDirectory)
			TRY
				* ”ƒ¿À»Ã  ¿“¿ÀŒ√
				RMDIR (m.tcDirectory)
			CATCH
				* Œÿ»¡ ¿ ”ƒ¿À≈Õ»ﬂ  ¿“¿ÀŒ√¿
				lcMessage = MSG_FOLDERREMOVEERROR + CHR_CR + m.tcDirectory
			ENDTRY
		ELSE
			* Œÿ»¡ ¿ ”—“¿ÕŒ¬ » ¿“–»¡”“Œ¬  ¿“¿ÀŒ√¿
			lcMessage = MSG_FOLDERSETATTRERROR + CHR_CR + m.tcDirectory
		ENDIF
	ENDIF
RETURN m.lcMessage

ENDPROC
PROCEDURE removefolder
* ”ƒ¿À≈Õ»≈  ¿“¿ÀŒ√¿ ¬Ã≈—“≈ —Œ ¬—≈Ã —Œƒ≈–∆»Ã€Ã
* –≈«”À‹“¿“ : œ”—“¿ﬂ —“–Œ ¿ »À» —“–Œ ¿ — —ŒŒ¡Ÿ≈Õ»≈Ã Œ¡ Œÿ»¡ ≈
LPARAMETERS tcPath AS String
LOCAL lcMessage AS String, lnCount AS Integer
LOCAL ARRAY laPathFile[1, 5]
	lcMessage=''
	tcPath=ADDBS(m.tcPath)

	FOR lnCount=1 TO ADIR(laPathFile, m.tcPath + '*.*', 'DHS')
		IF laPathFile[m.lnCount, 1]<>'.' AND laPathFile[m.lnCount, 1]<>'..'
			IF 'D' $ laPathFile[m.lnCount, 5]
				*  ¿“¿ÀŒ√
				lcMessage = This.removeFolder(m.tcPath + laPathFile(m.lnCount, 1))
			ELSE
				* ‘¿…À
				lcMessage = This.eraseFile(m.tcPath + laPathFile(m.lnCount, 1))
			ENDIF

			IF !EMPTY(m.lcMessage)
				RETURN m.lcMessage
			ENDIF
		ENDIF
	ENDFOR

	lcMessage = This.removeDirectory(m.tcPath)
RETURN m.lcMessage

ENDPROC
PROCEDURE resourcetopath
* œ≈–≈¬Œƒ œ”“» ¬ ¬»ƒ≈ –≈—”–—¿ ¬ —“¿Õƒ¿–“Õ”ﬁ ÕŒ“¿÷»ﬁ »Ã≈Õ»  ¿“¿ÀŒ√¿
* (Õ¿œ–»Ã≈– ¬ MICROSOFT WEBBROWSER CONTROL œ–» œ–Œ—ÃŒ“–≈  ¿“¿ÀŒ√Œ¬)
LPARAMETERS tcResource AS String
ASSERT VARTYPE(tcResource)='C'
* 'FILE:///C:/DOCUMENTS%20AND%20SETTINGS/ADMINISTRATOR/MY%20DOCUMENTS'
	IF LEFT(m.tcResource, 8) = 'FILE:///'
		tcResource = SUBSTR(m.tcResource, 9)
		tcResource = CHRTRAN(m.tcResource, '/','\')
		tcResource = STRTRAN(m.tcResource, '%20', ' ')
	ENDIF
RETURN m.tcResource
ENDPROC
PROCEDURE secondtotime
* œ≈–≈¬Œƒ —≈ ”Õƒ ¬ —“–Œ ” 'HH:MM:SS'
LPARAMETERS tnSecond
LOCAL lnHour, lnMinute, lnSecond
	lnHour = INT(m.tnSecond/ 60 / 60)
	lnMinute = m.tnSecond - m.lnHour * 60 * 60
	lnMinute = INT(m.lnMinute / 60)
	lnSecond = m.tnSecond - m.lnHour * 60 * 60 - m.lnMinute * 60
RETURN TRANSFORM(m.lnHour, '@L 99') + ':';
	   + TRANSFORM(m.lnMinute, '@L 99') + ':';
	   + TRANSFORM(m.lnSecond, '@L 99')
ENDPROC
PROCEDURE showerrdlg
*ÔÓÍ‡Á‡Ú¸ ‰Ë‡ÎÓ„ ÒÓÓ·˘ÂÌËÂ Ó ÒÓ·˚ÚËË Ë Â„Ó ‡Ò¯ËÂÌÌÓÂ ÓÔËÒ‡ÌËÂ
LPARAMETERS tcMsg as String, tcExtMsg as String
	MESSAGEBOX(m.tcMsg, 16, IIF(TYPE("THIS.Parent.oVars.cTaskCaption") = 'C',;
				   				THIS.Parent.oVars.cTaskCaption,;
				   				''))
ENDPROC
PROCEDURE showerrmsg
LPARAMETERS toExc as Exception
LOCAL lcErrMsg as String, lcExtErrMsg as String, lnI as Integer, lcTmpFileName as String,;
	  lcStackVars as String
LOCAL ARRAY laStackCall[1]
	IF VARTYPE(m.toExc) = 'C'
	*ÔÂÂ‰‡ÎË ÔÓÒÚÓ ÒÚÓÍÛ
		lcErrMsg = "Error: " + LTRIM(m.toExc) + CRLF;
				   + SYS(2018)
		lcExtErrMsg = ''

		lnStackLevel = 0
	ELSE
		lcErrMsg = "Error: " + LTRIM(TRANSFORM(m.toExc.ErrorNo)) + CRLF;
				   + "Procedure: " + m.toExc.Procedure + CRLF;
				   + "LineNo: " + LTRIM(TRANSFORM(m.toExc.LineNo)) + " LineContent: ";
				   + m.toExc.LineContents + CRLF;
				   + "Message: " + m.toExc.Message + CRLF;
			       + "Details: " + m.toExc.Details

		lnStackLevel = m.toExc.StackLevel
	ENDIF
	*ÒÚ˝Í ‚˚ÁÓ‚Ó‚
*!*		Array Element  Description  
*!*		1 Call Stack Level 
*!*		2 Current program filename 
*!*		3 Module or Object name 
*!*		4 Module or Object Source filename 
*!*		5 Line number in the object source file
*!*		6 Source line contents
	ASTACKINFO(laStackCall)

	lcExtErrMsg = "Programm call stack list: "

	IF m.lnStackLevel > ALEN(laStackCall, 1)
		FOR lnI = 1 TO m.lnStackLevel
			lcExtErrMsg = m.lcExtErrMsg + PROGRAM(m.lnI) + '.'
		ENDFOR

		lcExtErrMsg = LEFT(m.lcExtErrMsg, LEN(m.lcExtErrMsg) - 1)
	ELSE
		FOR lnI = 1 TO ALEN(laStackCall, 1)
			lcExtErrMsg = m.lcExtErrMsg;
						  + TRANSFORM(laStackCall[m.lnI, 1], "99") + ' ';
						  + laStackCall[m.lnI, 2] + ' ';
						  + laStackCall[m.lnI, 3] + ' ';
						  + laStackCall[m.lnI, 4] + ' ';
						  + TRANSFORM(laStackCall[m.lnI, 5], "9999") + ' ';
						  + laStackCall[m.lnI, 6] + ' ';
						  + CRLF
		ENDFOR

		lcExtErrMsg = LEFT(m.lcExtErrMsg, LEN(m.lcExtErrMsg) - 2)
	ENDIF
	*‰ÓÔÓÎÌËÚ¸ ÒÔËÒÍÓÏ ÔÂÂÏÂÌÌ˚ı
	lcTmpFileName = THIS.Parent.oVars.cAppCurPaths + SYS(3) + ".txt"

	DISPLAY MEMORY TO FILE (m.lcTmpFileName) NOCONSOLE

	lcStackVars = "Variables list: " + FILETOSTR(m.lcTmpFileName)
	*Û‰‡ÎËÚ¸ ‚ÂÏÂÌÌ˚È Ù‡ÈÎ
	DELETE FILE (m.lcTmpFileName)

	IF THIS.Parent.oVars.lDisplayErrMsg
		*ÔÓÍ‡Á‡Ú¸ ‰Ë‡ÎÓ„ Ò ÒÓÓ·˘ÂÌËÂÏ
		THIS.showErrDlg(m.lcErrMsg, m.lcExtErrMsg)
	ENDIF
	*Á‡ÔËÒ¸ ‚ ÎÓ„
	THIS.writeLog(m.lcErrMsg + CRLF + m.lcExtErrMsg + CRLF + m.lcStackVars)
ENDPROC
PROCEDURE spelling
* —”ÃÃ¿ ¬ –”¡Àﬂ’ œ–Œœ»—‹ﬁ
LPARAMETERS tnSumma
ASSERT VARTYPE(tnSumma)='N'
LOCAL lcSumma
	IF tnSumma >= 10 ** 12
		RETURN ALLTRIM(STR(m.tnSumma,20,2))
	ENDIF
	* k-ÍÓÔÂÈÍË, t-Ú˚Òˇ˜Ë, m-ÏËÎËÓÌ˚, M-ÏËÎÎË‡‰˚, e-Â‰ËÌËˆ˚, d-‰ÂÒˇÚÍË, c-ÒÓÚÌË
	lcSumma = TRANSFORM(m.tnSumma, '9c9d9eM9c9d9em9c9d9et9c9d9e.99k')
	lcSumma = STRTRAN(m.lcSumma, ' c d et', '')
	lcSumma = STRTRAN(m.lcSumma, ' c d em', '')
	lcSumma = STRTRAN(m.lcSumma, ' c d eM', '')

	lcSumma = STRTRAN(m.lcSumma, '0c0d0et', '')
	lcSumma = STRTRAN(m.lcSumma, '0c0d0em', '')
	lcSumma = STRTRAN(m.lcSumma, '0c0d0eM', '')

	lcSumma = STRTRAN(m.lcSumma, ' c', '')
	lcSumma = STRTRAN(m.lcSumma, '0c', '')
	lcSumma = STRTRAN(m.lcSumma, '1c', 'ÒÚÓ ')
	lcSumma = STRTRAN(m.lcSumma, '2c', '‰‚ÂÒÚË ')
	lcSumma = STRTRAN(m.lcSumma, '3c', 'ÚËÒÚ‡ ')
	lcSumma = STRTRAN(m.lcSumma, '4c', '˜ÂÚ˚ÂÒÚ‡ ')
	lcSumma = STRTRAN(m.lcSumma, '5c', 'ÔˇÚ¸ÒÓÚ ')
	lcSumma = STRTRAN(m.lcSumma, '6c', '¯ÂÒÚ¸ÒÓÚ ')
	lcSumma = STRTRAN(m.lcSumma, '7c', 'ÒÂÏ¸ÒÓÚ ')
	lcSumma = STRTRAN(m.lcSumma, '8c', '‚ÓÒÂÏ¸ÒÓÚ ')
	lcSumma = STRTRAN(m.lcSumma, '9c', '‰Â‚ˇÚ¸ÒÓÚ ')

	lcSumma = STRTRAN(m.lcSumma, '1d0e', '‰ÂÒˇÚ¸ ')
	lcSumma = STRTRAN(m.lcSumma, '1d1e', 'Ó‰ËÌÌ‡‰ˆ‡Ú¸ ')
	lcSumma = STRTRAN(m.lcSumma, '1d2e', '‰‚ÂÌ‡‰ˆ‡Ú¸ ')
	lcSumma = STRTRAN(m.lcSumma, '1d3e', 'ÚËÌ‡‰ˆ‡Ú¸ ')
	lcSumma = STRTRAN(m.lcSumma, '1d4e', '˜ÂÚ˚Ì‡‰ˆ‡Ú¸ ')
	lcSumma = STRTRAN(m.lcSumma, '1d5e', 'ÔˇÚÌ‡‰ˆ‡Ú¸ ')
	lcSumma = STRTRAN(m.lcSumma, '1d6e', '¯ÂÒÚÌ‡‰ˆ‡Ú¸ ')
	lcSumma = STRTRAN(m.lcSumma, '1d7e', 'ÒÂÏ¸Ì‡‰ˆ‡Ú¸ ')
	lcSumma = STRTRAN(m.lcSumma, '1d8e', '‚ÓÒÂÏÌ‡‰ˆ‡Ú¸ ')
	lcSumma = STRTRAN(m.lcSumma, '1d9e', '‰Â‚ˇÚÌ‡‰ˆ‡Ú¸ ')

	lcSumma = STRTRAN(m.lcSumma, ' d', '')
	lcSumma = STRTRAN(m.lcSumma, '0d', '')
	lcSumma = STRTRAN(m.lcSumma, '2d', '‰‚‡‰ˆ‡Ú¸ ')
	lcSumma = STRTRAN(m.lcSumma, '3d', 'ÚË‰ˆ‡Ú¸ ')
	lcSumma = STRTRAN(m.lcSumma, '4d', 'ÒÓÓÍ ')
	lcSumma = STRTRAN(m.lcSumma, '5d', 'ÔˇÚ¸‰ÂÒˇÚ ')
	lcSumma = STRTRAN(m.lcSumma, '6d', '¯ÂÒÚ¸‰ÂÒˇÚ ')
	lcSumma = STRTRAN(m.lcSumma, '7d', 'ÒÂÏ¸‰ÂÒˇÚ ')
	lcSumma = STRTRAN(m.lcSumma, '8d', '‚ÓÒÂÏ¸‰ÂÒˇÚ ')
	lcSumma = STRTRAN(m.lcSumma, '9d', '‰Â‚ˇÌÓÒÚÓ ')

	lcSumma = STRTRAN(m.lcSumma, '0e', '')
	lcSumma = STRTRAN(m.lcSumma, '5e', 'ÔˇÚ¸ ')
	lcSumma = STRTRAN(m.lcSumma, '6e', '¯ÂÒÚ¸ ')
	lcSumma = STRTRAN(m.lcSumma, '7e', 'ÒÂÏ¸ ')
	lcSumma = STRTRAN(m.lcSumma, '8e', '‚ÓÒÂÏ¸ ')
	lcSumma = STRTRAN(m.lcSumma, '9e', '‰Â‚ˇÚ¸ ')

	lcSumma = STRTRAN(m.lcSumma, '1e.', 'Ó‰ËÌ Û·Î¸ ')
	lcSumma = STRTRAN(m.lcSumma, '2e.', '‰‚‡ Û·Îˇ ')
	lcSumma = STRTRAN(m.lcSumma, '3e.', 'ÚË Û·Îˇ ')
	lcSumma = STRTRAN(m.lcSumma, '4e.', '˜ÂÚ˚Â Û·Îˇ ')

	lcSumma = STRTRAN(m.lcSumma, '1et', 'Ó‰Ì‡ Ú˚Òˇ˜‡ ')
	lcSumma = STRTRAN(m.lcSumma, '2et', '‰‚Â Ú˚Òˇ˜Ë ')
	lcSumma = STRTRAN(m.lcSumma, '3et', 'ÚË Ú˚Òˇ˜Ë ')
	lcSumma = STRTRAN(m.lcSumma, '4et', '˜ÂÚ˚Â Ú˚Òˇ˜Ë ')

	lcSumma = STRTRAN(m.lcSumma, '1em', 'Ó‰ËÌ ÏËÎÎËÓÌ ')
	lcSumma = STRTRAN(m.lcSumma, '2em', '‰‚‡ ÏËÎÎËÓÌ‡ ')
	lcSumma = STRTRAN(m.lcSumma, '3em', 'ÚË ÏËÎÎËÓÌ‡ ')
	lcSumma = STRTRAN(m.lcSumma, '4em', '˜ÂÚ˚Â ÏËÎÎËÓÌ‡ ')

	lcSumma = STRTRAN(m.lcSumma, '1eM', 'Ó‰ËÌ ÏËÎË‡‰ ')
	lcSumma = STRTRAN(m.lcSumma, '2eM', '‰‚‡ ÏËÎË‡‰‡ ')
	lcSumma = STRTRAN(m.lcSumma, '3eM', 'ÚË ÏËÎË‡‰‡ ')
	lcSumma = STRTRAN(m.lcSumma, '4eM', '˜ÂÚ˚Â ÏËÎË‡‰‡ ')

	lcSumma = STRTRAN(m.lcSumma, '11k', '11 ÍÓÔÂÂÍ')
	lcSumma = STRTRAN(m.lcSumma, '12k', '12 ÍÓÔÂÂÍ')
	lcSumma = STRTRAN(m.lcSumma, '13k', '13 ÍÓÔÂÂÍ')
	lcSumma = STRTRAN(m.lcSumma, '14k', '14 ÍÓÔÂÂÍ')

	lcSumma = STRTRAN(m.lcSumma, '1k', '1 ÍÓÔÂÈÍ‡')
	lcSumma = STRTRAN(m.lcSumma, '2k', '2 ÍÓÔÂÈÍË')
	lcSumma = STRTRAN(m.lcSumma, '3k', '3 ÍÓÔÂÈÍË')
	lcSumma = STRTRAN(m.lcSumma, '4k', '4 ÍÓÔÂÈÍË')

	lcSumma = STRTRAN(m.lcSumma, ' .', ' Û·ÎÂÈ ')
	lcSumma = STRTRAN(m.lcSumma, '.', '')
	lcSumma = STRTRAN(m.lcSumma, 't', 'Ú˚Òˇ˜ ')
	lcSumma = STRTRAN(m.lcSumma, 'm', 'ÏËÎÎËÓÌÓ‚ ')
	lcSumma = STRTRAN(m.lcSumma, 'M', 'ÏËÎË‡‰Ó‚ ')
	lcSumma = STRTRAN(m.lcSumma, 'k', ' ÍÓÔÂÂÍ')
RETURN UPPER(LEFT(m.lcSumma, 1)) + SUBSTR(m.lcSumma, 2)

ENDPROC
PROCEDURE stringtolong
* CONVERT A BINARY LONG INTEGER INTO A NUMBER
LPARAMETERS tcLong
RETURN BITLSHIFT(ASC(SUBSTR(m.tcLong, 4, 1)), 24);
	   + BITLSHIFT(ASC(SUBSTR(m.tcLong, 3, 1)), 16);
	   + BITLSHIFT(ASC(SUBSTR(m.tcLong, 2, 1)), 8);
	   + ASC(SUBSTR(m.tcLong, 1, 1))
ENDPROC
PROCEDURE timestumptodatetime
* VFP TIMESTAMP FIELD TO DATETIME
LPARAMETERS tnStamp
#DEFINE Secondsmasks	0x0000001F
#DEFINE MinutesMasks	0x000
#DEFINE HoursMasks		0x0000F800
#DEFINE DaysMasks		0x001F0000
#DEFINE MonthsMasks		0x01E00000
#DEFINE YearsMasks		0x3E000000

#DEFINE SecondsOffset	1
#DEFINE MinutesOffset	5
#DEFINE HoursOffset		11
#DEFINE SysOffset		16
#DEFINE MonthsOffset	21
#DEFINE YearsOffset		25

#DEFINE t2Month			BITRSHIFT(BITAND(tnStamp, MonthsMasks), MonthsOffset)
#DEFINE t2Day			BITRSHIFT(BITAND(tnStamp, DaysMasks), DaysOffset)
#DEFINE t2Year  		1980 + BITRSHIFT(BITAND(tnStamp, YearsMasks), YearsOffset)
#DEFINE t2Hour			BITRSHIFT(BITAND(tnStamp, HoursMasks), HoursOffset)
#DEFINE t2Min			BITRSHIFT(BITAND(tnStamp, MinutesMasks), MinutesOffset)
#DEFINE t2Sec			BITRSHIFT(BITAND(tnStamp, Secondsmasks), SecondsOffset)
RETURN DATETIME(t2Year, t2Month, t2Day, t2Hour, t2Min, t2Sec)

*!*	********************************************************************
*!*	* Program....: STAMP2T6.PRG
*!*	* Version....: 1.0
*!*	* Author.....: Ted Roche
*!*	* Date.......: May 31, 1998
*!*	* Notice.....: Copyright È 1998 Ted Roche, All Rights Reserved.
*!*	* Compiler...: Visual FoxPro 06.00.8093.00 for Windows
*!*	* Abstract...: VERSION SIX AND LATER ONLY!!!
*!*	* ...........: Simpler version of Stamp2DT written for HackFox3 and
*!*	* ...........: also published in FoxPro Advisor magazine
*!*	* Changes....:
*!*	********************************************************************

*!*	LPARAMETERS tnStamp

*!*	#DEFINE SecondsMask 15  && 00001111
*!*	#DEFINE MinutesMask 63  && 00111111
*!*	#DEFINE HoursMask   31  && 00011111
*!*	#DEFINE DaysMask    31  && 00011111
*!*	#DEFINE MonthsMask  15  && 00001111
*!*	#DEFINE YearsMask   63  && 00111111

*!*	#DEFINE SecondsOff= 1  && Note this is a LEFT shift, not RIGHT
*!*	#DEFINE MinutesOffset 5
*!*	#DEFINE HoursOffset   11
*!*	#DEFINE DaysOffset    16
*!*	#DEFINE MonthsOffset  21
*!*	#DEFINE YearsOffset   25

*!*	#DEFINE fMonth       BITAND(bitrshift(tnStamp,MONTHSOFFSET ),MONTHSMASK)
*!*	#DEFINE fDay         BITAND(bitrshift(tnStamp,DAYSOFFSET   ),DAYSMASK)
*!*	#DEFINE fYear   1980+BITAND(bitrshift(tnStamp,YEARSOFFSET  ),YEARSMASK)
*!*	#DEFINE fHour        BITAND(bitrshift(tnStamp,HOURSOFFSET  ),HOURSMASK)
*!*	#DEFINE fMinute     =TAND(bitrshift(tnStamp,MINUTESOFFSET),MINUTESMASK)
*!*	#DEFINE fSecond      BITAND(bitLshift(tnStamp,SECONDSOFFSET),SECONDSMASK)

*!*	IF TYPE("VERSION(5)") = "U" 
*!*	  = MESSAGEBOX("This routine only works with Visual FoxPro 6.x or later.")
*!*	  RETURN .F.
*!*	ENDIF

*!*	LOCAL ltReturn
*!*	ltReturn = IIF(tnStamp = 0, {//::}, ;
*!*	               DATETIME(fYear, fMonth, fDay, fHour, fMinute, fSecond)) 
*!*	return ltReturn

ENDPROC
PROCEDURE timetostring
* œ≈–≈¬Œƒ DATETIME ¬ —“–Œ ” FILETIME FORMAT C ”◊≈“ŒÃ ◊¿—Œ¬Œ√Œ œŒﬂ—¿
LPARAMETERS ttDateTime AS Datetime
LOCAL lnTime, lcTime, lnCount, lnTemp
	lnTime = (m.ttDateTime - {^1601/01/01 0:0:0} + This.GetBias() * 60) * 10 ^ 7
	lcTime = ''

	FOR lnCount = 56 TO 0 STEP -8
		lnTemp = INT(m.lnTime / (2 ^ m.lnCount))
		lnTime = (m.lnTime - m.lnTemp * (2 ^ m.lnCount))
		lcTime = CHR(m.lnTemp) + m.lcTime
	ENDFOR
RETURN m.lcTime
ENDPROC
PROCEDURE transform_my
LPARAMETERS tnnum
LOCAL lcstr as String, lnpoint as Integer, lnpos as Integer
	lcstr = LTRIM(TRANSFORM(m.tnnum, "@Z"))
	
	lnpoint = RATC('.', m.lcstr)
	
	IF m.lnpoint > 0
		lnpos = LENC(m.lcstr)

		DO WHILE m.lnpos >= m.lnpoint
			IF INLIST(SUBSTRC(m.lcstr, m.lnpos, 1), '0', '.', ' ')
				lcstr = LEFTC(m.lcstr, m.lnpos - 1)
			ELSE
				EXIT
			ENDIF

			lnpos = m.lnpos - 1
		ENDDO
	ENDIF
RETURN m.lcstr
ENDPROC
PROCEDURE transliterate
* –”—— Œ-¿Õ√À»…— ¿ﬂ “–¿Õ—À»“≈–¿÷»ﬂ 'À˛‰ÏËÎ‡'->'Lyudmila'
LPARAMETERS tcString
	ASSERT VARTYPE(m.tcString) = 'C'
	tcString = CHRTRAN(m.tcString, '‡·‚„‰Â∏ÁËÈÍÎÏÌÓÔÒÚÛÙ˙˚˝', 'abvgdeeziiklmnoprstuf"ye')
	tcString = CHRTRAN(m.tcString, '¿¡¬√ƒ≈®«»… ÀÃÕŒœ–—“”‘⁄€›', 'ABVGDEEZIIKLMNOPRSTUF"YE')
	tcString = STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(CHRTRAN(m.tcString,;
					   '¸',"'"),'Ê','zh'),'ı','kh'),'ˆ','ts'),'˜','ch'),'¯','sh'),'˘','shch'),'˛','yu'),'ˇ','ya')
	tcString = STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(STRTRAN(CHRTRAN(m.tcString,;
					   '‹',"'"),'∆','Zh'),'’','Kh'),'÷','Ts'),'◊','Ch'),'ÿ','Sh'),'Ÿ','Shch'),'ﬁ','Yu'),'ﬂ','Ya')
RETURN m.tcString

ENDPROC
PROCEDURE trimarray
* Œ“—≈◊≈Õ»≈ œ–Œ¡≈ÀŒ¬ ” ›À≈Ã≈Õ“Œ¬ N - Ã≈–ÕŒ√Œ Ã¿——»¬¿
* This.TrimArray(@MyArray)
LPARAMETERS taSource
LOCAL lnCount
EXTERNAL ARRAY taSource
	FOR lnCount = 1 TO ALEN(taSource)
		IF VARTYPE(taSource(m.lnCount)) = 'C'
			taSource(m.lnCount) = ALLTRIM(taSource(m.lnCount))
		ENDIF
	ENDFOR
ENDPROC
PROCEDURE writelog
* ¬≈ƒ≈Õ»≈ ‘¿…À¿-œ–Œ“Œ ŒÀ¿
LPARAMETERS tcMessage as String, tcFile as String
	IF VARTYPE(m.tcMessage) = 'C'
		IF EMPTY(m.tcFile)
			tcFile = THIS.Parent.oVars.cAppCurPaths + THIS.Parent.oVars.cTaskName
		ENDIF

		STRTOFILE(CRLF + DTOC(DATE()) + '-' + TIME() + ':' + m.tcMessage,;
				  FORCEEXT(m.tcFile, "LOG"),;
				  1)
	ENDIF
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*addprinter 
*arraypointer 
*closeallwindows 
*colortorgb 
*complexperc 
*copyfile 
*copyproperties 
*cryptkey 
*cryptxor 
*datetostring ƒ‡Ú‡ ÒÚÓÍÓÈ
*dectohex 
*directorytoarray 
*div 
*divmat 
*erasefile 
*fddformat 
*getbias 
*getfileattributes 
*getfilesize 
*getfont 
*getgdiguiddescription 
*getimageinformation 
*getnextfilename 
*getrandomnumber 
*gettagstring 
*gettempfile 
*gettempname 
*gettextstringwidth Returns the width of a text string as it would be printed in the current font.
*getwordcount 
*getwordnum 
*hextodec 
*isdirectoryreadonly 
*isfileequal 
*isfileused 
*isinternetconnected 
*ispicturevalid 
*longtostring 
*makedirectory 
*makedirectorytree 
*monthbetween 
*pixeltofoxel 
*pixeltotwip 
*playwav 
*pointertolong 
*pointertostring 
*removedirectory 
*removefolder 
*resourcetopath 
*secondtotime 
*showerrdlg 
*showerrmsg 
*spelling 
*stringtolong 
*timestumptodatetime 
*timetostring 
*transform_my –‡Ò¯ËˇÂÚ ‚ÓÁÏÓÊÌÓÒÚË transform - Û·Ë‡ÂÚ ÌÂ ÁÌ‡˜‡˘ËÂ ÌÛÎË ËÁ ‰Ó·ÌÓÈ ˜‡ÒÚË.
*transliterate –ÛÒÒÍÓ-‡Ì„ÎËÈÒÍ‡ˇ Ú‡ÌÒÎËÚÂ‡ˆËˇ 'À˛‰ÏËÎ‡'->'Lyudmila'
*trimarray 
*writelog —‰ÂÎ‡Ú¸ Á‡ÔËÒ¸ ‚ ÎÓ„
_memberdata XML Metadata for customizable properties
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\cstfunction.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\cstfunction.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Œ·˘ËÂ ÙÛÌÍˆËË ÔÓ„‡ÏÏ˚[END RESERVED7]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] cstfunction

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1YB0ZDG8R
[CLASS] base_custom
[CLASSLOC] base_gui.vcx
[BASECLASS] custom
[OBJNAME] cstvars
[START PROPERTIES]

Name = "cstvars"
_memberdata =     3825<VFPData><memberdata name="islock" type="method" display="IsLock"/><memberdata name="lockobject" type="property" display="LockObject"/><memberdata name="clistvars" type="property" display="cListVars"/><memberdata name="cappcurpaths" type="property" display="cAppCurPaths"/><memberdata name="cappexename" type="property" display="cAppExeName"/><memberdata name="cappname" type="property" display="cAppName"/><memberdata name="cdbname" type="property" display="cDBName"/><memberdata name="cdbpath" type="property" display="cDBPath"/><memberdata name="ctaskcaption" type="property" display="cTaskCaption"/><memberdata name="ctaskdesktoppicture" type="property" display="cTaskDesktopPicture"/><memberdata name="ctaskicon" type="property" display="cTaskIcon"/><memberdata name="ctaskname" type="property" display="cTaskName"/><memberdata name="eventloaded" type="property" display="eventLoaded"/><memberdata name="lcleanalldlls" type="property" display="lCleanAllDlls"/><memberdata name="lkeepdlls" type="property" display="lKeepDlls"/><memberdata name="lscreenhwnd" type="property" display="lScreenHwnd"/><memberdata name="ltaskbar" type="property" display="lTaskBar"/><memberdata name="ltoolbar" type="property" display="lToolBar"/><memberdata name="ndbtype" type="property" display="nDBType"/><memberdata name="ocurrenttask" type="property" display="oCurrentTask"/><memberdata name="odbconnect" type="property" display="oDBConnect"/><memberdata name="otaskbar" type="property" display="oTaskbar"/><memberdata name="otoolbar" type="property" display="oToolbar"/><memberdata name="timeterminate" type="property" display="timeTerminate"/><memberdata name="wndproc" type="property" display="wndProc"/><memberdata name="ctaskcaption_assign" type="method" display="cTaskCaption_Assign"/><memberdata name="ctaskdesktoppicture_assign" type="method" display="cTaskDesktopPicture_Assign"/><memberdata name="ctaskicon_assign" type="method" display="cTaskIcon_Assign"/><memberdata name="ocurrenttask_assign" type="method" display="oCurrentTask_Assign"/><memberdata name="asavedlls" type="property" display="aSaveDlls"/><memberdata name="dfltdatebegin" type="property" display="dFltDateBegin"/><memberdata name="dfltdateend" type="property" display="dFltDateEnd"/><memberdata name="lactive" type="property" display="lActive"/><memberdata name="cdbschema" type="property" display="cDBSchema"/><memberdata name="omenu" type="property" display="oMenu"/><memberdata name="astorexmlvars" type="property" display="aStoreXmlVars"/><memberdata name="cdbtype" type="property" display="cDBType"/><memberdata name="cver" type="property" display="cVer"/><memberdata name="cdbtype_assign" type="method" display="cDBType_Assign"/><memberdata name="lstorepassword" type="property" display="lStorePassword"/><memberdata name="lstorestatewindows" type="property" display="lStoreStateWindows"/><memberdata name="cusername" type="property" display="cUserName"/><memberdata name="cuserpassword" type="property" display="cUserPassword"/><memberdata name="lmenubar" type="property" display="lMenuBar"/><memberdata name="lsuo" type="property" display="lSuo"/><memberdata name="cdbpath_assign" type="method" display="cDBPath_Assign"/><memberdata name="cpop3_host" type="property" display="cPop3_Host"/><memberdata name="cpop3_log" type="property" display="cPop3_Log"/><memberdata name="cpop3_port" type="property" display="cPop3_Port"/><memberdata name="cpop3_pwd" type="property" display="cPop3_Pwd"/><memberdata name="csmtp_host" type="property" display="cSmtp_Host"/><memberdata name="csmtp_port" type="property" display="cSmtp_Port"/><memberdata name="lsearchmode" type="property" display="lSearchMode"/><memberdata name="ldisplayerrmsg" type="property" display="lDisplayErrMsg"/><memberdata name="loncestart" type="property" display="lOnceStart"/></VFPData>
cappcurpaths = 
cappexename = 
cappname = GLOBAL
cdbname = 
cdbpath = 
cdbschema = 
cdbtype = 
cpop3_host = 
cpop3_log = 
cpop3_port = "110"
cpop3_pwd = 
csmtp_host = 
csmtp_port = "25"
ctaskcaption = "—”Œ:"
ctaskdesktoppicture = 
ctaskicon = ..\bmp\components.ico
ctaskname = GLOBAL
cusername = 
cuserpassword = 
cver = 0
dfltdatebegin = (DATE())
dfltdateend = (DATE())
eventloaded = .F.
lactive = .F.
lcleanalldlls = .F.
ldisplayerrmsg = .T.
lkeepdlls = .F.
lmenubar = .T.
loncestart = .F.
lscreenhwnd = .F.
lsearchmode = .F.
lstorepassword = .F.
lstorestatewindows = .F.
lsuo = .F.
ltoolbar = .T.
ndbtype = 0
ocurrenttask = .NULL.
odbconnect = .NULL.
timeterminate = .NULL.
wndproc = 0
[END PROPERTIES]
[START PROTECTED]
Picture^
lsuo^
[END PROTECTED]
[START METHODS]
PROCEDURE Init
*!*	Custom::AddObject("oMenu", "SFMenu_app", "m.goApp.oVars.oMenu")
*‰Ó·‡‚ËÚ¸ ÒÔËÒÓÍ ÔÓÎÂÈ ÍÓÚÓ˚Â Ì‡‰Ó ˜ËÚ‡Ú¸/ÒÓı‡ÌˇÚ¸ ‚ xml
WITH THIS
	DIMENSION .aStoreXmlVars[20, 3]
	*ËÏˇ Á‡‰‡˜Ë
	.aStoreXmlVars[1, 1] = "cTaskName"
	.aStoreXmlVars[1, 2] = "Name"
	.aStoreXmlVars[1, 3] = "c"
	*Í‡ÚËÌÍ‡ Á‡‰‡˜Ë
	.aStoreXmlVars[2, 1] = "cTaskIcon"
	.aStoreXmlVars[2, 2] = "Icon"
	.aStoreXmlVars[2, 3] = "c"
	*ÔÛÚ¸ Í ·‡ÁÂ/ÒÂÚÂ‚ÓÈ ‡‰ÂÒ
	.aStoreXmlVars[3, 1] = "cDBPath"
	.aStoreXmlVars[3, 2] = "database_path"
	.aStoreXmlVars[3, 3] = "c"
	*ËÏˇ ·‡Á˚
	.aStoreXmlVars[4, 1] = "cDBName"
	.aStoreXmlVars[4, 2] = "database_name"
	.aStoreXmlVars[4, 3] = "c"
	*ËÏˇ ÒıÂÏ˚ ‚ ·‡ÁÂ
	.aStoreXmlVars[5, 1] = "cDBSchema"
	.aStoreXmlVars[5, 2] = "database_schema"
	.aStoreXmlVars[5, 3] = "c"
	*ÚËÔ ·‡Á˚
	.aStoreXmlVars[6, 1] = "cDBType"
	.aStoreXmlVars[6, 2] = "database_type"
	.aStoreXmlVars[6, 3] = "c"
	*Í‡Í ı‡ÌËÚ¸ Ì‡ÒÚÓÈÍË ÓÍÓÌ - Ë‰Ë‚Ë‰Û‡Î¸ÌÓ ‰Îˇ Á‡‰‡˜Ë ËÎË ËÒÔÓÎ¸ÁÓ‚‡Ú¸ „ÎÓ·‡Î¸Ì˚Â
	.aStoreXmlVars[7, 1] = "lStoreStateWindows"
	.aStoreXmlVars[7, 2] = "store_statewin"
	.aStoreXmlVars[7, 3] = "l"
	*ËÏˇ ÔÓÎ¸ÁÓ‚‡ÚÂÎˇ - ÔÓÒÎÂ‰ÌËÈ Û‰‡˜ÌÓ Á‡ÎÓ„ËÌË‚¯ËÈÒˇ
	.aStoreXmlVars[8, 1] = "cUserName"
	.aStoreXmlVars[8, 2] = "login"
	.aStoreXmlVars[8, 3] = "c"
	*Ô‡ÓÎ¸
	.aStoreXmlVars[9, 1] = "cUserPassword"
	.aStoreXmlVars[9, 2] = "password"
	.aStoreXmlVars[9, 3] = "c"
	*ı‡ÌËÚ¸ Ô‡ÓÎ¸?
	.aStoreXmlVars[10, 1] = "lStorePassword"
	.aStoreXmlVars[10, 2] = "store_password"
	.aStoreXmlVars[10, 3] = "l"
	*‡ÍÚË‚Ì‡ˇ Á‡‰‡˜‡
	.aStoreXmlVars[11, 1] = "lActive"
	.aStoreXmlVars[11, 2] = "last_connected"
	.aStoreXmlVars[11, 3] = "l"
	*Ì‡˜‡ÎÓ ÔÂËÓ‰‡
	.aStoreXmlVars[12, 1] = "dFltDateBegin"
	.aStoreXmlVars[12, 2] = "work_interval_begin"
	.aStoreXmlVars[12, 3] = "d"
	*ÓÍÓÌ˜‡ÌËÂ ÔÂËÓ‰‡
	.aStoreXmlVars[13, 1] = "dFltDateEnd"
	.aStoreXmlVars[13, 2] = "work_interval_end"
	.aStoreXmlVars[13, 3] = "d"
	*smtp_host
	.aStoreXmlVars[14, 1] = "csmtp_host"
	.aStoreXmlVars[14, 2] = "smtp_host"
	.aStoreXmlVars[14, 3] = "c"
	*smtp_port
	.aStoreXmlVars[15, 1] = "csmtp_port"
	.aStoreXmlVars[15, 2] = "smtp_port"
	.aStoreXmlVars[15, 3] = "c"
	*pop3_host
	.aStoreXmlVars[16, 1] = "cpop3_host"
	.aStoreXmlVars[16, 2] = "pop3_host"
	.aStoreXmlVars[16, 3] = "c"
	*pop3_port
	.aStoreXmlVars[17, 1] = "cpop3_port"
	.aStoreXmlVars[17, 2] = "pop3_port"
	.aStoreXmlVars[17, 3] = "c"
	*pop3_log
	.aStoreXmlVars[18, 1] = "cpop3_log"
	.aStoreXmlVars[18, 2] = "pop3_log"
	.aStoreXmlVars[18, 3] = "c"
	*pop3_pwd
	.aStoreXmlVars[19, 1] = "cpop3_pwd"
	.aStoreXmlVars[19, 2] = "pop3_pwd"
	.aStoreXmlVars[19, 3] = "c"
	*ÂÊËÏ ÔÓËÒÍ‡ ÔÓ ÔÓ‰ÒÚÓÍÂ
	.aStoreXmlVars[20, 1] = "lSearchMode"
	.aStoreXmlVars[20, 2] = "SearchMode"
	.aStoreXmlVars[20, 3] = "l"
ENDWITH
ENDPROC
PROCEDURE cdbpath_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
	THIS.cDBPath = m.vNewVal
	*ÔÂÂÍÓÌÌÂÍÚËÚ¸Òˇ
	IF TYPE("m.goApp") = 'O'
		m.goApp.login()
	ENDIF
ENDPROC
PROCEDURE cdbtype_assign
LPARAMETERS tcNewVal
*To do: Modify this routine for the Assign method
	WITH THIS
		.cDBType = m.tcNewVal

		DO CASE
		CASE m.tcNewVal = "FoxPro"
			.nDBType = DB_FoxPro
		CASE m.tcNewVal = "PostgreSQL"
			.nDBType = DB_PostgreSQL
		CASE m.tcNewVal = "MSSQL"
			.nDBType = DB_MSSQL
		CASE m.tcNewVal = "Oracle"
			.nDBType = DB_Oracle
		CASE m.tcNewVal = "Access"
			.nDBType = DB_Access
		OTHERWISE
			.nDBType = DB_None
		ENDCASE
	ENDWITH
ENDPROC
PROCEDURE ctaskcaption_assign
LPARAMETERS tvNewVal
	THIS.cTaskCaption = IIF(VARTYPE(m.tvNewVal) <> 'C', '', m.tvNewVal)

	IF VARTYPE(_Screen) = 'O'
		_Screen.Caption = IIF(THIS.lSuo, "—”Œ: ", '') + m.tvNewVal
	ENDIF
ENDPROC
PROCEDURE ctaskdesktoppicture_assign
LPARAMETERS tvNewVal
	THIS.cTaskDesktopPicture = m.tvNewVal

	IF VARTYPE(_Screen) = 'O'
		_Screen.Picture = m.tvNewVal
	ENDIF
ENDPROC
PROCEDURE ctaskicon_assign
LPARAMETERS tvNewVal
	THIS.cTaskIcon = m.tvNewVal

	IF VARTYPE(_Screen) = 'O'
		_Screen.Icon = m.tvNewVal
	ENDIF
ENDPROC
PROCEDURE ltaskbar_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
	THIS.lTaskBar = m.vNewVal

	IF PEMSTATUS(THIS.Parent, "loadEvent", 5)
		IF m.vNewVal			
		*ÔÂÂı‚‡Ú ÓÍÓÌÌ˚ı ÒÓ·˚ÚËÈ ÔÓÍ‡ ÚÓÎ¸ÍÓ ÂÒÎË ÌÛÊÂÌ Ú‡ÒÍ ·‡
		*‰Îˇ report ÓÍÓÌ fox Ô‡‰‡ÂÚ
			THIS.Parent.loadEvent()
		ELSE
			THIS.Parent.releaseEvent()
		ENDIF
	ENDIF
ENDPROC
PROCEDURE ocurrenttask_assign
LPARAMETERS tvNewVal as tasklist of ..\lib.9\base_app
*To do: Modify this routine for the Assign method
	WITH THIS
		.oCurrentTask = m.tvNewVal

*!*			IF VARTYPE(_Screen) = 'O' AND VARTYPE(m.tvNewVal) = 'O' AND !ISNULL(m.tvNewVal)
		IF VARTYPE(m.tvNewVal) = 'O' AND !ISNULL(m.tvNewVal)
			.cTaskName = m.tvNewVal.oVars.cTaskName
			.cTaskCaption = m.tvNewVal.oVars.cTaskCaption
			.cTaskDesktopPicture = m.tvNewVal.oVars.cTaskDesktopPicture
			.cTaskIcon = m.tvNewVal.oVars.cTaskIcon

			.cDBName = m.tvNewVal.oVars.cDBName
			.cDBPath = m.tvNewVal.oVars.cDBPath
			.nDBType = m.tvNewVal.oVars.nDBType
			.cUserName = m.tvNewVal.oVars.cUserName
			.cUserPassword = m.tvNewVal.oVars.cUserPassword

			.dFltDateBegin = m.tvNewVal.oVars.dFltDateBegin
			.dFltDateEnd = m.tvNewVal.oVars.dFltDateEnd

			_Screen.Caption = m.tvNewVal.oVars.cTaskCaption
			_Screen.Picture = m.tvNewVal.oVars.cTaskDesktopPicture
			_Screen.Icon = m.tvNewVal.oVars.cTaskIcon
		ENDIF
	ENDWITH
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*cdbpath_assign 
*cdbtype_assign 
*ctaskcaption_assign 
*ctaskdesktoppicture_assign 
*ctaskicon_assign 
*ltaskbar_assign 
*ocurrenttask_assign 
^asavedlls[1,0] 
^astorexmlvars[1,3] 1-ËÏˇ ÔÂÂÏ 2-ËÏˇ ‚ xml 3-ÚËÔ
cappcurpaths
cappexename
cappname
cdbname
cdbpath
cdbschema
cdbtype ÚËÔ ·‡Á˚ - ÒÚÓÍÓÈ
cpop3_host
cpop3_log
cpop3_port
cpop3_pwd
csmtp_host
csmtp_port
ctaskcaption
ctaskdesktoppicture
ctaskicon
ctaskname
cusername
cuserpassword
cver
dfltdatebegin
dfltdateend
eventloaded
lactive
lcleanalldlls
ldisplayerrmsg œÓÍ‡Á˚‚‡Ú¸ ÏÂÒÒ‡„Ë Ó· Ó¯Ë·Í‡ı
lkeepdlls
lmenubar
loncestart
lscreenhwnd
lsearchmode
lstorepassword
lstorestatewindows
lsuo
ltaskbar
ltoolbar
ndbtype ÚËÔ ·‡Á˚ - ˜ËÒÎÓ
ocurrenttask
odbconnect
timeterminate
wndproc
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
√ÎÓ·‡Î¸Ì˚Â ÔÂÂÏÂÌÌ˚Â[END RESERVED7]
[START RESERVED8]
base_idb.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] cstvars

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0SZ0L98A3
[CLASS] custom
[BASECLASS] custom
[OBJNAME] cstwinapi
[START PROPERTIES]

Name = "cstwinapi"
Width = 20
_memberdata =     3853<VFPData><memberdata name="activatewindow" type="method" display="activateWindow"/><memberdata name="beep" type="method" display="beep"/><memberdata name="createmutex" type="method" display="createMutex"/><memberdata name="deletedc" type="method" display="deleteDC"/><memberdata name="deleteobject" type="method" display="deleteObject"/><memberdata name="exitprocess" type="method" display="exitProcess"/><memberdata name="exitwindowsex" type="method" display="exitWindowsEx"/><memberdata name="findwindow" type="method" display="findWindow"/><memberdata name="freelibrary" type="method" display="freeLibrary"/><memberdata name="gdipatblt" type="method" display="gDIPatBlt"/><memberdata name="getapppath" type="method" display="getAppPath"/><memberdata name="getcursorpos" type="method" display="getCursorPos"/><memberdata name="getdatetime" type="method" display="getDatetime"/><memberdata name="getdc" type="method" display="getDC"/><memberdata name="getdevicecaps" type="method" display="getDeviceCaps"/><memberdata name="getfocus" type="method" display="getFocus"/><memberdata name="getguid" type="method" display="getGuid"/><memberdata name="getkeyboardlayoutname" type="method" display="getKeyboardLayoutName"/><memberdata name="getlasterror" type="method" display="getLastError"/><memberdata name="getsyscolor" type="method" display="getSysColor"/><memberdata name="getwindow" type="method" display="getWindow"/><memberdata name="getwindowlong" type="method" display="getWindowLong"/><memberdata name="getwindowrect" type="method" display="getWindowRect"/><memberdata name="globalmemorystatus" type="method" display="globalMemoryStatus"/><memberdata name="ischild" type="method" display="isChild"/><memberdata name="loadicon" type="method" display="loadIcon"/><memberdata name="loadimage" type="method" display="loadImage"/><memberdata name="loadkeyboardlayout" type="method" display="loadKeyboardLayout"/><memberdata name="loadlibrary" type="method" display="loadLibrary"/><memberdata name="messagebeep" type="method" display="messageBeep"/><memberdata name="openfile" type="method" display="openFile"/><memberdata name="releasecapture" type="method" display="releaseCapture"/><memberdata name="releasedc" type="method" display="releaseDC"/><memberdata name="releasemutex" type="method" display="releaseMutex"/><memberdata name="selectobject" type="method" display="selectObject"/><memberdata name="sendmessage" type="method" display="sendMessage"/><memberdata name="shellexecute" type="method" display="shellExecute"/><memberdata name="showcursor" type="method" display="showCursor"/><memberdata name="shutdownwindows" type="method" display="shutdownWindows"/><memberdata name="sleep" type="method" display="sleep"/><memberdata name="terminateprocess" type="method" display="terminateProcess"/><memberdata name="windowfrompoint" type="method" display="windowFromPoint"/><memberdata name="winexec" type="method" display="winExec"/><memberdata name="getuserdefaultlcid" type="method" display="getUserDefaultLCID"/><memberdata name="getfolderpath" type="method" display="getFolderPath"/><memberdata name="loadlibraryex" type="method" display="loadLibraryEx"/><memberdata name="isloaded" type="method" display="isLoaded"/><memberdata name="adeclareddll" type="property" display="aDeclaredDLL"/><memberdata name="createdirectory" type="method" display="createDirectory"/><memberdata name="createsemaphore" type="method" display="createSemaphore"/><memberdata name="getmessagepos" type="method" display="getMessagePos"/><memberdata name="getwindowsdirectory" type="method" display="getWindowsDirectory"/><memberdata name="opensemaphore" type="method" display="openSemaphore"/><memberdata name="getlogicaldrive" type="method" display="getLogicalDrive"/><memberdata name="getvolumeinformation" type="method" display="getVolumeInformation"/></VFPData>
[END PROPERTIES]
[START METHODS]
PROCEDURE activatewindow
* ¿ “»¬»«¿÷»ﬂ » ¬€“¿— »¬¿Õ»≈ Œ Õ¿ œŒ ’›ÕƒÀ”
* ”ƒŒ¡ÕŒ »—œŒÀ‹«Œ¬¿“‹ ¬ œ¿–≈ — THIS.FINDWINDOW()
* IF ActivateWindow(FindWindow(tcCaption)) ...
LPARAMETERS tnWindowHandle				
	IF m.tnWindowHandle = 0
		RETURN .F.
	ENDIF

	WITH THIS
		IF !.isLoaded("SetForegroundWindow")
			DECLARE INTEGER SetForegroundWindow IN WIN32API INTEGER
		ENDIF

		IF !.isLoaded("IsIconic")
			DECLARE INTEGER IsIconic IN WIN32API INTEGER
		ENDIF

		IF !.isLoaded("ShowWindow")
			DECLARE INTEGER ShowWindow IN WIN32API INTEGER,INTEGER
		ENDIF
	ENDWITH
	* ¬€“¿Ÿ»Ã Õ¿ œŒ¬≈–’ÕŒ—“‹
	SetForegroundWindow(m.tnWindowHandle)
	* ≈—À» —¬≈–Õ”“Œ, “Œ ¬Œ——“¿ÕŒ¬»Ã œ–≈∆Õ»… –¿«Ã≈– SW_RESTORE = 9
	IF IsIconic(m.tnWindowHandle) <> 0
		ShowWindow(m.tnWindowHandle, 9)
	ENDIF
ENDPROC
PROCEDURE beep
* œŒƒ WNT/W2K ¬€ƒ¿≈“—ﬂ —»√Õ¿À ƒÀ»“≈À‹ÕŒ—“‹ﬁ DURATION — ◊¿—“Œ“Œ… FREQUENCY
* œŒƒ W9X/WME ¬€ƒ¿≈“—ﬂ BEEP Õ¿ —œ» ≈– - œ–» Œ“—”“—“¬»» «¬” Œ¬”’», »Õ¿◊≈ «¬”  œŒ ”ÃŒÀ◊¿Õ»ﬁ
* P.S. —Ã. THIS.MESSAGEBEEP()
LPARAMETERS tnFrequency AS Integer, tnDuration AS Integer
LOCAL lnSuccess AS Integer
	tnFrequency=IIF(VARTYPE(m.tnFrequency)='N', m.tnFrequency, 400)
	tnDuration=IIF(VARTYPE(m.tnDuration)='N', m.tnDuration, 100)

	IF !THIS.isLoaded("Beep")
		DECLARE INTEGER Beep IN WIN32API  LONG, LONG
	ENDIF

	lnSuccess=Beep(m.tnFrequency, m.tnDuration)
RETURN m.lnSuccess<>0

ENDPROC
PROCEDURE bitblt
* TRANSFERS BITS FROM A RECTANGLE ON A SOURCE DEVICE TO A RECTANGLE THAT HAS THE SAME DIMENSIONS ON A DESTINATION DEVICE
* P.S. ¬ Œœ»—¿Õ»» œŒ–ﬂƒ ¿ œ¿–¿Ã≈“–Œ¬ ¬ MSDN œŒ’Œ∆≈ Œÿ»¡ ¿

LPARAMETERS tnDestDC, tnX, tnY, tnWidth, tnHeight, tnSrcDC, tnXSrc, tnYSrc, tnRop && tPBrush, tDrawMode
DECLARE LONG BitBlt IN Win32API LONG, LONG, LONG, LONG, LONG, LONG, LONG, LONG, LONG
BitBlt(tnDestDC, tnX, tnY, tnWidth, tnHeight, tnSrcDC, tnXSrc, tnYSrc, tnRop)
CLEAR DLLS 'BitBlt'

ENDPROC
PROCEDURE blockinput
* BLOCK / UNBLOCK MOUSE AND KEYBOARD INPUT

LPARAMETERS tlBlock
LOCAL lnBlock
lnBlock=IIF(tlBlock, 1, 0)
DECLARE INTEGER BlockInput IN WIN32API INTEGER
BlockInput(lnBlock)
CLEAR DLLS 'BlockInput'
RETURN

ENDPROC
PROCEDURE cddoor
* Œ“ –€“‹ / «¿ –€“‹ ◊≈Àﬁ—“‹ —»ƒﬁ ¿
LPARAMETERS tcDriveLetter AS Character, tlCloseDoor AS Logical
LOCAL llSuccess AS Logical
	llSuccess=.F.
	tcDriveLetter=LEFT(LTRIM(m.tcDriveLetter), 1)
	*
	IF DRIVETYPE(m.tcDriveLetter)=DRIVE_CDROM
		IF !THIS.isLoaded("mciSendString")
			DECLARE LONG mciSendString IN WINMM STRING, LONG, LONG, LONG
		ENDIF
		* Œ“ –Œ≈Ã ”—“–Œ…—“¬Œ » œ–»—¬Œ»Ã ¿À»¿— 'CD'
		IF mciSendString('open '+m.tcDriveLetter+': type cdaudio alias cd', 0, 0, 0)=0
			llSuccess=mciSendString('set cd door '+IIF(m.tlCloseDoor, 'closed', 'open'), 0, 0, 0)=0
			mciSendString('close cd', 0, 0, 0)
		ENDIF
	ENDIF
RETURN m.llSuccess

ENDPROC
PROCEDURE checkinstance
* œ–Œ¬≈– ¿ : «¿œ”Ÿ≈ÕŒ À» ”∆≈ œ–»ÀŒ∆≈Õ»≈ ?
* > 0 - œ≈–¬€… «¿œ”—  œ–»ÀŒ∆≈Õ»ﬂ
* = 0 - Œÿ»¡ ¿ —Œ«ƒ¿Õ»ﬂ —≈Ã¿‘Œ–¿
* < 0 - œ–»ÀŒ∆≈Õ»≈ ”∆≈ «¿œ”Ÿ≈ÕŒ
LPARAMETERS tcUnique as String
LOCAL lnReturnValue AS Integer
	IF !THIS.isLoaded("CreateSemaphore")
		DECLARE INTEGER CreateSemaphore IN WIN32API INTEGER, INTEGER, INTEGER, STRING
	ENDIF

	IF !THIS.isLoaded("OpenSemaphore")
		DECLARE INTEGER OpenSemaphore IN WIN32API INTEGER, INTEGER, STRING
	ENDIF

	lnReturnValue = OpenSemaphore (983040, 0, m.tcUnique)
	lnReturnValue = IIF(m.lnReturnValue = 0, CreateSemaphore (0, 1, 1, m.tcUnique), -1)
RETURN m.lnReturnValue

ENDPROC
PROCEDURE clienttoscreen
*  ŒŒ–ƒ»Õ¿“€ ‘Œ–Ã€ Œ“ÕŒ—»“≈À‹ÕŒ ƒ›— “Œœ¿ (¿¡—ŒÀﬁ“Õ€≈  ŒŒ–ƒ»Õ¿“€ ‘Œ–Ã€)
* ThisForm.ClientToScreen() - LEFT, ThisForm.ClientToScreen(ThisForm, .T.) - TOP
* Õ¿œ–»Ã≈– ¿¡—ŒÀﬁ“Õ€≈  ŒŒ–ƒ»Õ¿“€  ŒÕ“–ŒÀ¿ Õ¿ ‘Œ–Ã≈ ÃŒ∆ÕŒ œŒÀ”◊»“‹ “¿  :
* MESSAGEBOX('Left='+TRANSFORM(This.ClientToScreen(ThisForm,.F.)+OBJTOCLIENT(This,2))+;
*			' Top='+This.ClientToScreen(ThisForm,.T.)+TRANSFORM(OBJTOCLIENT(This,1)))
* P.S. —Ã. This.GetMessagePos(.T./.F.) - œŒÀ”◊≈Õ»≈  ŒŒ–ƒ»Õ¿“  ŒÕ“–ŒÀ¿, œŒÀ”◊»¬ÿ≈√Œ œŒ—À≈ƒÕ≈≈ —ŒŒ¡Ÿ≈Õ»≈
LPARAMETERS toForm AS Form, tlTop AS Logical
LOCAL lcPoint AS String
	lcPoint=REPLICATE(CHR(0), 8)
	*
	IF !THIS.isLoaded("ClientToScreen")
		DECLARE INTEGER ClientToScreen IN WIN32API INTEGER, STRING @
	ENDIF
	*
	ClientToScreen(m.toForm.HWnd, @lcPoint)
	*
	WITH This.Parent.oFunction
		RETURN IIF(m.tlTop,;
			.StringToLong(RIGHT(m.lcPoint, 4)), .StringToLong(LEFT(m.lcPoint, 4)))
	ENDWITH
	
ENDPROC
PROCEDURE closehandle
LPARAMETERS tnHandle AS Integer
	IF !THIS.isLoaded("CloseHandle")
		DECLARE INTEGER CloseHandle IN WIN32API	INTEGER
	ENDIF
	*
	CloseHandle(m.tnHandle)
ENDPROC
PROCEDURE colorbitsperpixel
* √À”¡»Õ¿ ÷¬≈“¿ ¬ ¡»“¿’ Õ¿ œ» —≈À (—Ã.COLORCOMBINATION)
LOCAL lnDeviceHandle AS Integer, lnIndexOfItem AS Integer,;
	lcDriverName AS String, lnBitsPerPixel AS Integer
	IF !THIS.isLoaded("CreateDC")
		DECLARE INTEGER CreateDC IN WIN32API STRING @, STRING @, STRING @, STRING @
	ENDIF
	*
	IF !THIS.isLoaded("GetDeviceCaps")
		DECLARE INTEGER GetDeviceCaps IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	IF !THIS.isLoaded("DeleteDC")
		DECLARE INTEGER DeleteDC IN WIN32API INTEGER @
	ENDIF
	*
	lcDriverName='DISPLAY'+CHR(0)
	lnBitsPerPixel=0
	lnDeviceHandle=CreateDC(@lcDriverName, '', '', .NULL.)
	*
	IF m.lnDeviceHandle>0
		lnIndexOfItem=BITSPIXEL	&& 12
		*  ŒÀ»◊≈—“¬Œ ¡»“ Õ¿ œ» —≈À‹
		lnBitsPerPixel=GetDeviceCaps(@lnDeviceHandle, @lnIndexOfItem)
		DeleteDC(@lnDeviceHandle)
	ENDIF
RETURN m.lnBitsPerPixel

ENDPROC
PROCEDURE colorcombination
*  ŒÀ»◊≈—“¬Œ  ŒÃ¡»Õ¿÷»… ÷¬≈“Œ¬ (—Ã.COLORBITSPERPIXEL)
* ¬ —À”◊¿≈ ŒƒÕŒ… ÷¬≈“Œ¬Œ… œÀŒ— Œ—“» :
* 2^(1 ColorPlane * 08 BPS) = 256
* 2^(1 ColorPlane * 16 BPS) = 65536
* 2^(1 ColorPlane * 24 BPS) = 16777216
* 2^(1 ColorPlane * 32 BPS) = 4294967296

LOCAL lnDeviceHandle AS Integer, lnIndexOfItem AS Integer, lcDriverName AS String,;
	lnNumberBPixels AS Integerm, lnNumberPlanes AS Integer, lnColorCombination AS Integer
	IF !THIS.isLoaded("CreateDC")
		DECLARE INTEGER CreateDC IN WIN32API STRING @, STRING @, STRING @, STRING @
	ENDIF
	*
	IF !THIS.isLoaded("GetDeviceCaps")
		DECLARE INTEGER GetDeviceCaps IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	IF !THIS.isLoaded("DeleteDC")
		DECLARE INTEGER DeleteDC IN WIN32API INTEGER @
	ENDIF
	*
	lnColorCombination=0
	lcDriverName='DISPLAY'+CHR(0)
	lnDeviceHandle=CreateDC(@lcDriverName, '', '', .NULL.)
	*
	IF m.lnDeviceHandle>0
		lnIndexOfItem=PLANES		&& 14
		*  ŒÀ»◊≈—“¬Œ ÷¬≈“Œ¬€’ œÀŒ— Œ—“≈…
		lnNumberPlanes=GetDeviceCaps(@lnDeviceHandle, @lnIndexOfItem)
		lnIndexOfItem=BITSPIXEL	&& 12
		*  ŒÀ»◊≈—“¬Œ ¡»“ Õ¿ œ» —≈À‹
		lnNumberBPixels=GetDeviceCaps(@lnDeviceHandle, @lnIndexOfItem)
		DeleteDC(@lnDeviceHandle)
		*  ŒÀ»◊≈—“¬Œ ÷¬≈“Œ¬€’  ŒÃ¡»Õ¿÷»…
		lnColorCombination=2^(m.lnNumberPlanes*m.lnNumberBPixels)
	ENDIF
RETURN m.lnColorCombination

ENDPROC
PROCEDURE copyfile
*  Œœ»–Œ¬¿Õ»≈ ‘¿…À¿ ¬Ã≈—“≈ — ¿“–»¡”“¿Ã» R/S/H
*  ŒÃœ≈Õ—»–”≈“ Õ≈ƒŒ—“¿“ » ¬—“–Œ≈ÕÕŒ…  ŒÃ¿Õƒ€ COPY FILE ... TO ...  Œ“Œ–¿ﬂ :
* 1) Õ≈ ¬»ƒ»“ — –€“€… »À» —»—“≈ÃÕ€… ‘¿…À-»—“Œ◊Õ» 
* 2) Õ≈ œ–»—¬¿»¬¿≈“ ¿“–»¡”“€ ‘¿…À¿ »—“Œ◊Õ» ¿ ‘¿…À” œ–»≈ÃÕ» ”
* 3) Õ≈  Œœ»–”≈“ Œ“ –€“€… Õ¿ «¿œ»—‹ ‘¿…À-»—“Œ◊Õ» 
* 4) ¿¬“ŒÃ¿“»◊≈— » —“¿¬»Ã ¿“–»¡”“ ARCHIVE ‘¿…À”-œ–»≈ÃÕ» ”
* 5) —Œ«ƒ¿≈“ ‘¿…À€ ¬ LOWERCASE

* P.S.
* ¬Œ«ÃŒ∆Õ€ –¿—’Œ∆ƒ≈Õ»ﬂ ¬Œ ¬–≈Ã≈Õ» ÃŒƒ»‘» ¿÷»» SOURCE » TARGET ‘¿…ÀŒ¬
* œ–»  Œœ»–Œ¬¿Õ»» — FAT16/32 Õ¿ NTFS » Õ¿Œ¡Œ–Œ“ ƒŒ 2-’ —≈ ”Õƒ
* (“Œ◊ÕŒ—“‹ ’–¿Õ≈Õ»ﬂ ¬–≈Ã≈–» ÃŒƒ»‘»‘» ¿÷»» ‘¿…À¿ ¬ FAT 1 —≈ ”Õƒ¿, ¬ NTFS 1 Ã»ÀÀ»—≈ ”Õƒ¿)

* ¿À‹“≈–Õ¿“»¬¿ FSO :
* oFSO = CreateObject('Scripting.FileSystemObject')
* oFSO.CopyFile('SourceFile','DestinationFile',.T.)
* »À»  Œœ»–Œ¬¿Õ»≈  ¿“¿ÀŒ√¿ ÷≈À» ŒÃ :
* oFSO  =  CREATEOBJECT("Scripting.FileSystemObject")
* oFSO.—opyFolder('SourceFolder', 'DestinationFolder', .F.)
* œ–»◊≈Ã Œÿ»¡ » Œ“À¿¬À»¬¿“‹ COMRETURNERROR()
LPARAMETERS tcSource AS String, tcTarget AS String, tlOverwrite AS Logical
LOCAL lnSuccess AS Integer, lnOverwrite AS Integer
	lnSuccess = 0

	IF FILE(m.tcSource, 1)
		lnOverwrite = IIF(m.tlOverwrite, 0, 1)

		IF !THIS.isLoaded("CopyFile")
			DECLARE INTEGER CopyFile IN WIN32API STRING, STRING, INTEGER
		ENDIF

		lnSuccess = CopyFile(m.tcSource, m.tcTarget, m.lnOverwrite)
	ENDIF
RETURN m.lnSuccess <> 0
ENDPROC
PROCEDURE createcompatiblebitmap
* CREATE A BITMAP COMPATIBLE WITH THE DEVICE ASSOCIATED WITH THE SPECIFIED DEVICE CONTEXT

LPARAMETERS tnDC, tnWidth, tnHeight
LOCAL lnBitMap AS Integer
	IF !THIS.isLoaded("CreateCompatibleBitmap")
		DECLARE LONG CreateCompatibleBitmap IN Win32API LONG, LONG, LONG
	ENDIF
	*
	lnBitMap=CreateCompatibleBitmap(m.tnDC, m.tnWidth, m.tnHeight)
RETURN m.lnBitMap
ENDPROC
PROCEDURE createcompatibledc
* CREATE A MEMORY DEVICE CONTEXT (DC) COMPATIBLE WITH THE SPECIFIED DEVICE
LPARAMETERS tnDC
LOCAL lnDC AS Integer
	IF !THIS.isLoaded("CreateCompatibleDC")
		DECLARE LONG CreateCompatibleDC	IN Win32API LONG
	ENDIF
	*
	lnDC=CreateCompatibleDC(m.tnDC)
RETURN m.lnDC
ENDPROC
PROCEDURE createdirectory
* —Œ«ƒ¿Õ»≈  ¿“¿ÀŒ√¿
* P.S. Õ» ¿ »’ œ–≈»Ã”Ÿ≈—“¬ œ≈–≈ƒ ¬—“–Œ≈ÕÕŒ… MKDIR,
* “ŒÀ‹ Œ Õ≈ƒŒ—“¿“Œ  - Õ≈ —Œ«ƒ¿≈“ ÷≈œŒ◊ ” ¬ÀŒ∆≈ÕÕ€’  ¿“¿ÀŒ√Œ¬.
LPARAMETERS tcFolder AS String
LOCAL lnSuccess AS Integer
	lnSuccess = 0

	IF !DIRECTORY(m.tcFolder, 1)
		IF !THIS.isLoaded("CreateDirectory")
			DECLARE INTEGER CreateDirectory IN WIN32API STRING ,INTEGER @
		ENDIF
		* 0 - DEFAULT SECURITY DESCRIPTOR
		lnSuccess = CreateDirectory(m.tcFolder, 0)
	ENDIF
RETURN m.lnSuccess <> 0
ENDPROC
PROCEDURE createellipticrgn
* —Œ«ƒ¿Õ»≈ ›À»œ“»◊≈— Œ… Œ¡À¿—“» ¬ Œ Õ≈
LPARAMETERS tnXUpperLeft AS Integer, tnYUpperLeft AS Integer,;
	tnXLowerRight AS Integer, tnYLowerRight AS Integer
LOCAL lnRegionHandle AS Integer
	IF !THIS.isLoaded("CreateEllipticRgn")
		DECLARE INTEGER CreateEllipticRgn IN WIN32API INTEGER, INTEGER, INTEGER, INTEGER
	ENDIF

	lnRegionHandle=CreateEllipticRgn(m.tnXUpperLeft, m.tnYUpperLeft, m.tnXLowerRight, m.tnYLowerRight)
RETURN m.lnRegionHandle

ENDPROC
PROCEDURE createmutex
* —Œ«ƒ¿Õ»≈ Ã‹ﬁ“≈ —¿ — ”Õ» ¿À‹Õ€Ã »ƒ≈Õ“»‘» ¿“Œ–ŒÃ TCUNIQUE
* MUTEX - Œ¡⁄≈ “ —»Õ’–ŒÕ»«¿÷»» ¡≈« —◊®“◊» ¿, SEMAPHORE - —Œ —◊≈“◊» ŒÃ
* –≈«”À‹“¿“ - ”—œ≈’ —Œ«ƒ¿Õ»ﬂ
LPARAMETERS tcUnique AS String
LOCAL lnError AS Integer, lnHandle AS Integer
* TCUNIQUE IS LIMITED TO MAX_PATH CHARACTERS AND CAN CONTAIN ANY
* CHARACTER EXCEPT THE BACKSLASH PATH-SEPARATOR CHARACTER (\)
* NAME COMPARISON IS CASE SENSITIVE
	tcUnique = CHRTRAN(tcUnique, '\', '_')

	IF !THIS.isLoaded("CreateMutex")
		DECLARE INTEGER CreateMutex IN WIN32API INTEGER, INTEGER, STRING
	ENDIF
	* ’›ÕƒÀ Œ¡⁄≈ “¿ —»Õ’–ŒÕ»«¿÷»»
	lnHandle = CreateMutex(0, 1, m.tcUnique)
*!*		lnError = This.GetLastError()
RETURN m.lnHandle &&lnError <> ERROR_ALREADY_EXISTS AND m.lnError <> ERROR_INVALID_HANDLE

ENDPROC
PROCEDURE createrectrgn
* —Œ«ƒ¿Õ»≈ œ–ﬂÃŒ”√ŒÀ‹ÕŒ… Œ¡À¿—“» ¬ Œ Õ≈
LPARAMETERS tnXUpperLeft AS Integer, tnYUpperLeft AS Integer,;
	tnXLowerRight AS Integer, tnYLowerRight AS Integer
LOCAL lnRegionHandle AS Integer
	IF !THIS.isLoaded("CreateRectRgn")
		DECLARE INTEGER CreateRectRgn IN WIN32API INTEGER, INTEGER, INTEGER, INTEGER
	ENDIF
	*
	lnRegionHandle=CreateRectRgn(m.tnXUpperLeft, m.tnYUpperLeft, m.tnXLowerRight, m.tnYLowerRight)
RETURN m.lnRegionHandle

ENDPROC
PROCEDURE createsemaphore
* —Œ«ƒ¿Õ»≈ —≈Ã¿‘Œ–¿ — ”Õ» ¿À‹Õ€Ã »ƒ≈Õ“»‘» ¿“Œ–ŒÃ TCUNIQUE
* —≈Ã¿‘Œ– - Œ¡⁄≈ “ —»Õ’–ŒÕ»«¿÷»» —Œ —◊®“◊» ŒÃ, MUTEX - ¡≈«
* –≈«”À‹“¿“ - Õ≈Õ”À≈¬Œ… ” ¿«¿“≈À‹ Õ¿ —Œ«ƒ¿ÕÕ€… —≈Ã¿‘Œ– »À» 0, ≈—À» —Œ«ƒ¿“‹ Õ≈ ”ƒ¿ÀŒ—‹
LPARAMETERS tcUnique AS String
LOCAL lnHandle AS Integer
* TCUNIQUE IS LIMITED TO MAX_PATH CHARACTERS AND CAN CONTAIN ANY
* CHARACTER EXCEPT THE BACKSLASH PATH-SEPARATOR CHARACTER (\)
* NAME COMPARISON IS CASE SENSITIVE
	tcUnique=CHRTRAN(m.tcUnique, '\', '_')

	IF !THIS.isLoaded("CreateSemaphore")
		DECLARE INTEGER CreateSemaphore IN WIN32API INTEGER, INTEGER, INTEGER, STRING
	ENDIF

	lnHandle = CreateSemaphore (0, 1, 1, m.tcUnique)
RETURN m.lnHandle

#IF .F.
	* œ≈–¬€… ¬¿–»¿Õ“ œ–Œ¬≈– » œŒ¬“Œ–ÕŒ√Œ «¿œ”— ¿ œ–»ÀŒ∆≈Õ»ﬂ Õ¿ —≈Ã¿‘Œ–≈
FUNCTION AlreadyRunning
LPARAMETERS tcUnique
	LOCAL lcUnique, lnHandle
	tcUnique = CHRTRAN(tcUnique, '\', '_')
	DECLARE INTEGER OpenSemaphore IN WIN32API INTEGER, INTEGER, STRING
	lnHandle = OpenSemaphore(STANDARD_RIGHTS_REQUIRED, 0, tcUnique)
	CLEAR DLLS 'OpenSemaphore'
	IF lnHandle = 0
		DECLARE INTEGER CreateSemaphore IN WIN32API INTEGER, INTEGER, INTEGER, STRING
		lnHandle = CreateSemaphore (0, 1, 1, tcUnique)
		CLEAR DLLS 'CreateSemaphore'
		IF lnHandle = 0
		    DECLARE INTEGER GetLastError IN WIN32API
			* Œÿ»¡ ¿ —Œ«ƒ¿Õ»ﬂ —≈Ã¿‘Œ–¿
			MESSAGEBOX(MSG_ERR_SEMAPHORE + ' : ' + TRANSFORM(GetLastError()), 64, MAIN_CAPTION)
			* “ŒÀ‹ Œ œ–≈ƒ”œ–≈ƒ»Ã » œ–ŒƒŒÀ∆»Ã ¬€œŒÀÕ≈Õ»≈
			CLEAR DLLS 'GetLastError'
		ENDIF
		RETURN .F.
	ENDIF
	RETURN

	* ¬“Œ–Œ… ¬¿–»¿Õ“ œ–Œ¬≈– » œŒ¬“Œ–ÕŒ√Œ «¿œ”— ¿ œ–»ÀŒ∆≈Õ»ﬂ Õ¿ —≈Ã¿‘Œ–≈
	FUNCTION AlreadyRunning1
	LPARAMETERS tcUnique
	LOCAL lnError
	tcUnique = CHRTRAN(tcUnique, '\', '_')
	DECLARE INTEGER GetLastError IN WIN32API
	DECLARE INTEGER CreateSemaphore IN WIN32API INTEGER, INTEGER, INTEGER, STRING
	CreateSemaphore(0, 1, 1, tcUnique)
	lnError = GetLastError()
	CLEAR DLLS 'GetLastError', 'CreateSemaphore'
	RETURN lnError # 0

	* “–≈“»… » œŒ—À≈ƒÕ»… ¬¿–»¿Õ“ œ≈–≈œ»—¿Õ Õ¿ Ã‹ﬁ“≈ —≈ ;)

#ENDIF

ENDPROC
PROCEDURE deletedc
* DELETES THE SPECIFIED DEVICE CONTEXT
LPARAMETERS tnDCHandle AS Integer
	IF !THIS.isLoaded("DeleteDC")
		DECLARE LONG DeleteDC IN Win32API LONG
	ENDIF

	DeleteDC(m.tnDCHandle)
ENDPROC
PROCEDURE deletefile
* ”ƒ¿À≈Õ»≈ ‘¿…À¿
* 1)  ¿  » ¬—“–Œ≈ÕÕ¿ﬂ  ŒÃ¿Õƒ¿ ERASE Õ≈ ”Ã≈≈“ ”ƒ¿Àﬂ“‹ READONLY ‘¿…À€
* 2) «¿“Œ ”ƒ¿Àﬂ≈“ ‘¿…À€ SYSTEM » HIDDEN,  Œ“Œ–€≈ ERASE Õ≈ ¬»ƒ»“
LPARAMETERS tcPathFileName AS String
LOCAL lnSuccess AS Integer
	lnSuccess = 0

	IF FILE(m.tcPathFileName, 1)
		IF !THIS.isLoaded("DeleteFile")
			DECLARE INTEGER DeleteFile IN WIN32API STRING
		ENDIF

		lnSuccess = DeleteFile(m.tcPathFileName)
	ENDIF
RETURN m.lnSuccess <> 0

ENDPROC
PROCEDURE deleteobject
* DELETES A LOGICAL PEN, BRUSH, FONT, BITMAP, REGION, OR PALETTE, FREEING ALL SYSTEM RESOURCES ASSOCIATED WITH THE OBJECT
* œ–»Ã≈Õﬂ≈“—ﬂ, Õ¿œ–»Ã≈–, ƒÀﬂ ”ƒ¿À≈Õ»ﬂ This.CreateEllipticRgn()
LPARAMETERS tnHandle AS Integer
	IF !THIS.isLoaded("DeleteObject")
		DECLARE INTEGER DeleteObject IN WIN32API INTEGER
	ENDIF

	DeleteObject(m.tnHandle)


ENDPROC
PROCEDURE dllregisterserver
* –≈√»—“–¿÷»ﬂ ACTIVEX OCX == DLL ¡»¡À»Œ“≈ » ¬ –≈≈—“–≈
* œ¿–¿Ã≈“– : œ”“‹ » »Ãﬂ OCX ‘¿…À¿
* –≈«”À‹“¿“ : 0 ¬ —À”◊¿≈ ”—œ≈’¿ »À»  Œƒ Œÿ»¡ »
* —Ã. This.RegSvr32()

LPARAMETERS tcOcxFileName AS String
LOCAL lnError AS Integer
	tcOcxFileName=ALLTRIM(m.tcOcxFileName)
	*
	IF ' '$m.tcOcxFileName
		tcOcxFileName='"'+m.tcOcxFileName+'"'
	ENDIF
	*
	IF !THIS.isLoaded("DllRegisterServer")
		DECLARE INTEGER DllRegisterServer IN m.&tcOcxFileName
	ENDIF
	*
	lnError=DllRegisterServer()
RETURN m.lnError

ENDPROC
PROCEDURE dllunregisterserver
* ”ƒ¿À≈Õ»≈ –≈√»—“–¿÷»» ACTIVEX OCX == DLL ¡»¡À»Œ“≈ » »« –≈≈—“–¿
* œ¿–¿Ã≈“– : œ”“‹ » »Ãﬂ OCX ‘¿…À¿
* –≈«”À‹“¿“ : 0 ¬ —À”◊¿≈ ”—œ≈’¿ »À»  Œƒ Œÿ»¡ »
* —Ã. This.RegSvr32()
LPARAMETERS tcOcxFileName AS String
LOCAL lnError AS Integer
	tcOcxFileName=ALLTRIM(m.tcOcxFileName)
	IF ' '$m.tcOcxFileName
		tcOcxFileName='"'+m.tcOcxFileName+'"'
	ENDIF
	*
	IF !THIS.isLoaded("DllUnregisterServer")
		DECLARE INTEGER DllUnregisterServer IN m.&tcOcxFileName
	ENDIF
	*
	lnError=DllUnregisterServer()
RETURN m.lnError

ENDPROC
PROCEDURE drawicon
* –»—”≈Ã » ŒÕ ” tnIconHandle Õ¿ ”—“–Œ…—“¬≈ tnDCHandle
* »—œŒÀ‹«Œ¬¿“‹ ¬ —¬ﬂ« ≈ GetDC->LoadIcon->DrawIcon->ReleaseDC
* This.DrawIcon(tnDCHandle, tnIconHandle, 40, 20)
LPARAMETERS tnDCHandle AS Integer, tnIconHandle AS Integer,;
	tnLeft AS Integer, tnTop AS Integer
	IF !THIS.isLoaded("DrawIcon")
		DECLARE SHORT DrawIcon IN WIN32API INTEGER, INTEGER, INTEGER, INTEGER
	ENDIF
	*
	DrawIcon(m.tnDCHandle, m.tnLeft, m.tnTop, m.tnIconHandle)
ENDPROC
PROCEDURE drawiconresource
* –»—”≈Ã » ŒÕ ” tnIconId Õ¿ ‘Œ–Ã≈ tnHWnd ¬  ŒŒ–ƒ»Õ¿“¿’ tnLeft, tnTop
* P.S. : —Ã. WINAPI.H –¿«ƒ≈À ICON
LPARAMETERS tnHWnd AS Integer, tnIconId AS Integer,;
	tnLeft AS Integer, tnTop AS Integer
LOCAL lnDCHandle AS Integer, lnIconHandle AS Integer, llSuccess AS Logical
	llSuccess=.F.
	lnDCHandle=This.GetDC(m.tnHWnd)
	*
	IF m.lnDCHandle<>0
		lnIconHandle=This.LoadIcon(m.tnIconId)
		*
		IF m.lnIconHandle>0
			llSuccess=This.DrawIcon(m.lnDCHandle, m.lnIconHandle, m.tnLeft, m.tnTop)
		ENDIF
		*
		This.ReleaseDC(m.tnHWnd, m.lnDCHandle)
	ENDIF
RETURN m.llSuccess

*!*	”‰Ó·ÌÓ ‰Îˇ Ò‡ÏÓÔ‡Î¸ÌÓ„Ó MESSAGEBOX() ÔÓÎ¸ÁÓ‚‡Ú¸,a ÌÂ „ÛÁËÚ¸ ·˝˝ÏÔ˝¯ÍË,
*!* ÌÓ ‚Ë‰ËÏÓ ÔË‰ÂÚÒˇ ÔÂÂËÒÓ‚˚‚‡Ú¸ ÙÓÏÛ ‚ ThisForm.Paint(), ËÌ‡˜Â ËÒ˜ÂÁ‡˛Ú,
*!* Á‡ÚÓ ÏÓÊÌÓ Ëı Ì‡ÍÎ‡‰˚‚‡Ú¸ ‰Û„ Ì‡ ‰Û„‡ ;)))

*!*	w=CREATEOBJECT('Form')
*!*	w.Visible = .T.
*!*	o=NEWOBJECT('cntProc','c:\vfp\main\prog\custom')
*!*	o.Api.DrawIconResource(w.Hwnd, 32513, 40, 40)
*!*	MESSAGEBOX('')
*!*	RELEASE o, w

ENDPROC
PROCEDURE exitprocess
* THE EXITPROCESS FUNCTION ENDS A PROCESS AND ALL ITS THREADS.
* EXITPROCESS IS THE PREFERRED METHOD OF ENDING A PROCESS.
* THIS FUNCTION PROVIDES A CLEAN PROCESS SHUTDOWN.
LPARAMETERS tnExitCode AS Integer
	tnExitCode=IIF(VARTYPE(m.tnExitCode)='N', m.tnExitCode, 0)

	IF !THIS.isLoaded("ExitProcess")
		DECLARE ExitProcess IN WIN32API INTEGER uExitCode 
	ENDIF

	ExitProcess(m.tnExitCode)
ENDPROC
PROCEDURE exitwindowsex
* «¿¬≈–ÿ≈Õ»≈ –¿¡Œ“€ WINDOWS
* ƒÀﬂ WINNT BASED OS Õ≈Œ¡’Œƒ»ÃŒ ƒŒ¡¿¬»“‹ –¿¡Œ“” — œ–¿¬¿Ã»  ¿  «ƒ≈—‹ :
* HTTP://SUPPORT.MICROSOFT.COM/DEFAULT.ASPX?SCID=KB;EN-US;Q251310
LPARAMETERS tnFlag AS Integer, tnReason AS Integer
	tnFlag=IIF(VARTYPE(m.tnFlag)='N', m.tnFlag, EWX_SHUTDOWN)
	tnReason=IIF(VARTYPE(m.tnReason)='N', m.tnReason, 0)

	IF !THIS.isLoaded("ExitWindowsEx")
		DECLARE INTEGER ExitWindowsEx IN WIN32API INTEGER, INTEGER
	ENDIF

	ExitWindowsEx(m.tnFlag, m.tnReason)
ENDPROC
PROCEDURE fatalappexit
* ¿¬¿–»…ÕŒ≈ «¿¬≈–ÿ≈Õ»≈ –¿¡Œ“€ œ–»ÀŒ∆≈Õ»ﬂ.
* ¬€ƒ¿≈“ Œ ÕŒ — «¿√ŒÀŒ¬ ŒÃ 'Fatal Application Exit',
* ŒƒÕŒ—“–Œ◊Õ€Ã —ŒŒ¡Ÿ≈Õ»≈Ã »  ÕŒœ Œ… 'OK'.
* œ¿–¿Ã≈“– - ŒƒÕŒ—“–Œ◊ÕŒ≈ —ŒŒ¡Ÿ≈Õ»≈ — –≈ ŒÃ≈Õƒ”≈ÃŒ… ƒÀ»ÕÕŒ… Õ≈ ¡ŒÀ≈≈ 35 —»Ã¬ŒÀŒ¬
* ¬Õ»Ã¿Õ»≈ ! MAY NOT ALWAYS FREE AN APPLICATION'S MEMORY OR CLOSE ITS FILES,
*			 AND IT MAY CAUSE A GENERAL FAILURE OF THE SYSTEM
LPARAMETERS tcMessage AS String
	DECLARE FatalAppExit IN WIN32API INTEGER, STRING
	*
	FatalAppExit(0, m.tcMessage)
	CLEAR DLLS 'FatalAppExit'

ENDPROC
PROCEDURE findwindow
* ¬Œ«¬–¿Ÿ¿≈“ ’›ÕƒÀ WINDOWS Œ Õ¿ œŒ œŒƒ—“–Œ ≈ ¬ «¿√ŒÀŒ¬ ≈
* ”ƒŒ¡ÕŒ »—œŒÀ‹«Œ¬¿“‹ ¬ œ¿–≈ — THIS.ACTIVATEWINDOW()
* IF ActivateWindow(FindWindow(tcCaption)) ...
LPARAMETER tcCaption
LOCAL lnHandle, lcCaption
	IF !THIS.isLoaded("GetActiveWindow")
		DECLARE INTEGER GetActiveWindow	IN WIN32API
	ENDIF

	IF !THIS.isLoaded("GetWindow")
		DECLARE INTEGER GetWindow IN WIN32API INTEGER, INTEGER
	ENDIF

	IF !THIS.isLoaded("GetWindowText")
		DECLARE INTEGER GetWindowText IN WIN32API INTEGER, STRING, INTEGER
	ENDIF
	* œŒÀ”◊»Ã ’›ÕƒÀ ¿ “»¬ÕŒ√Œ Œ Õ¿
	lnHandle = GetActiveWindow()
	* œ≈–≈¡≈–≈Ã ¬—≈ Œ Õ¿
	DO WHILE m.lnHandle <> 0
		* —À≈ƒ”ﬁŸ≈≈ Œ ÕŒ
		lnHandle = GetWindow(m.lnHandle, 2)
		lcCaption = REPLICATE(CHR(0), 80)
		* œŒÀ”◊»Ã «¿√ŒÀŒ¬Œ 
		GetWindowText(m.lnHandle, @lcCaption, 80)
		* œ–Œ¬≈–»Ã ¬’Œ∆ƒ≈Õ»≈ œŒƒ—“–Œ » ¬ «¿√ŒÀŒ¬Œ 
		IF UPPER(ALLTRIM(m.tcCaption)) $ UPPER(m.lcCaption)
			EXIT
		ENDIF
	ENDDO
RETURN m.lnHandle
ENDPROC
PROCEDURE flashwindow
* Ã»√Õ”“‹ «¿√ŒÀŒ¬ ŒÃ Œ Õ¿ ¬ “¿— -¡¿–≈
* P.S. TYPICALLY, A WINDOW IS FLASHED TO INFORM THE USER THAT THE WINDOW
*      REQUIRES ATTENTION BUT THAT IT DOES NOT CURRENTLY HAVE THE KEYBOARD FOCUS
* DO WHILE Form.WindowState = 1
*	This.FlashWindow(HWnd)
*	This.Sleep(500)  
*	DOEVENTS
* ENDDO  
LPARAMETERS tnWindowHandle AS Integer
	IF !THIS.isLoaded("FlashWindow")
		DECLARE INTEGER FlashWindow IN WIN32API INTEGER, INTEGER
	ENDIF

	FlashWindow(m.tnWindowHandle, 1)

*!*	" Ó„‰‡ ÔÓ„‡ÏÏ‡ ÚÂ·ÛÂÚ ‚‚Ó‰‡ ‰‡ÌÌ˚ı, ÓÌ‡ ÏÓÊÂÚ ÎË·Ó ‚˚ÒÍÓ˜ËÚ¸ Ì‡ ÔÂÂ‰ÌËÈ ÔÎ‡Ì,
*!*	ÎË·Ó Ì‡˜‡Ú¸ ÏË„‡Ú¸ ÍÌÓÔÍÓÈ Ì‡ Ô‡ÌÂÎË Á‡‰‡˜. ¬˚ ÏÓÊÂÚÂ ÛÒÚ‡ÌÓ‚ËÚ¸ ‚ÂÏˇ,‚ ÚÂ˜ÂÌËË
*!*	ÍÓÚÓÓ„Ó ÔÓ„‡ÏÏ‡ ·Û‰ÂÚ ÒË„Ì‡ÎËÁËÓÓ‚‡Ú¸ ÔÂÂ‰ ˝ÚËÏ ‚˚ıÓ‰ÓÏ"
*!*	¬ HKEY_CURRENT_USER\Control Panel\Desktop - Ô‡‡ÏÂÚ ForegroundLockTimeout
*!*	ÚËÔ‡ DWORD = ‚ÂÏˇ Á‡‰ÂÊÍË ‰Ó "ÔÂÂı‚‡Ú‡" ÙÓÍÛÒ‡ ‚ ÏËÎÎËÒÂÍÛÌ‰‡ı:
*!*	0 ó ÓÍÌÓ Ò‡ÁÛ ‚˚ÒÍ‡ÍË‚‡ÂÚ ‚ÔÂÂ‰.
*!*	“‡Ï ÊÂ: DWORD-Ô‡‡ÏÂÚ ForegroundFlashCount = ÌÛÊÌÓÂ ˜ËÒÎÓ ÏË„‡ÌËÈ.
*!*	«Ì‡˜ÂÌËˇ ÛÒÚ‡Ì‡‚ÎË‚‡˛ÚÒˇ ‚ ‰ÂÒˇÚË˜ÌÓÈ ÒËÒÚÂÏÂ:
*!*	0 Á‡ÒÚ‡‚ËÚ ÍÌÓÔÍÛ ÏË„‡Ú¸ ·ÂÒÍÓÌÂ˜ÌÓ.
*!*	(ËÁ ÒÔ‡‚Ó˜ÌËÍ‡ - "–ÂÂÒÚ Windows" ¿. ÎËÏÓ‚, ». ◊Â·ÓÚ‡Â‚)

*!*	≈ÒÎË Ì‡‰Ó ˜ÚÓ· Ã»√¿À ÔÓÒÚÓˇÌÌÓ (ÌÂ ÔÓÒÚÓ ÏË„ÌÛÎ Ë ‚˚‰ÂÎËÎ ÍÌÓÔÍÛ)
*!*	ÚÓ ÂÒÚ¸ Â˘∏ FlashWindowEx - Ú‡Ï Á‡‰‡∏ÚÒˇ Ë ˜ËÒÎÓ ÏË„‡ÌËÈ, Ë ËÌÚÂ‚‡Î, Ë Â˘∏ ÏÌÓ„Ó ˜Â„Ó.
*!*	DECLARE INTEGER FlashWindowEx IN WIN32API STRING pfwi  
*!*	  #DEFINE FLASHW_STOP         0  
*!*	  #DEFINE FLASHW_CAPTION      0x00000001  
*!*	  #DEFINE FLASHW_TRAY         0x00000002  
*!*	  #DEFINE FLASHW_ALL          BITOR(FLASHW_CAPTION, FLASHW_TRAY)  
*!*	  #DEFINE FLASHW_TIMER        0x00000004  
*!*	  #DEFINE FLASHW_TIMERNOFG    0x0000000C  
*!*	    
*!*	 *_SCREEN.WindowState=1  
*!*	 * ÃÓÊÌÓ Ë ÌÂ ÏËÌËÏËÁËÓ‚‡Ú¸ ÓÍÌÓ ‰Îˇ ‰‡ÌÌÓÈ ÍÓÏ·ËÌ‡ˆËË Ô‡‡ÏÂÚÓ‚!  
*!*	    
*!*	 * ”Í‡ÊÂÏ ÏÓ„ÌÛÚ¸ 5 ‡Á Ò ËÌÚÂ‚‡ÎÓÏ ÔÓ ÛÏÓÎ˜‡ÌË˛ - Í‡Í ÏÓ„‡ÂÚ ÍÛÒÓ ‚‚Ó‰‡  
*!*	  lcFI = n2dword(20) + n2dword(_VFP.hWnd) + n2dword(FLASHW_ALL) + n2dword(5) + n2dword(0)  
*!*	  ? FlashWindowEx(m.lcfi)  
*!*	    
*!*	    
*!*	 * ”Í‡ÊÂÏ ÏÓ„‡Ú¸ ·ÂÒÍÓÌÂ˜ÌÓ, "Â‰ÍÓ" (ËÌÚÂ‚‡Î 2 ÒÂÍÛÌ‰˚), Ë ÚÓÎ¸ÍÓ ÍÌÓÔÍÓÈ Ì‡ Ô‡ÌÂÎË...  
*!*	  INKEY(10) && ƒ‡·˚ ÛÁÂÚ¸ Ô‡ÛÁÛ ÏÂÊ‰Û ÔÂ‚˚Ï Ë ‚ÚÓ˚Ï Á‡ÔÛÒÍ‡ÏË  
*!*	  lcFI = n2dword(20) + n2dword(_VFP.hWnd) + n2dword(BITOR(FLASHW_TRAY, FLASHW_TIMER)) + n2dword(0) + n2dword(2000)  
*!*	  ? FlashWindowEx(m.lcfi)  
*!*	    
*!*	 * ÃÓÊÌÓ ‚ Î˛·ÓÈ ÏÓÏÂÌÚ ÔÂÍ‡ÚËÚ¸ ÏÓ„‡ÌËÂ, Á‡‰‡‰ËÏ ÓÒÚ‡ÌÓ‚ ˜ÂÂÁ 15 ÒÂÍÛÌ‰  
*!*	  INKEY(15)  
*!*	  lcFI = n2dword(20) + n2dword(_VFP.hWnd) + n2dword(FLASHW_STOP) + n2dword(0) + n2dword(0)  
*!*	  ? FlashWindowEx(m.lcfi)  
*!*	    
*!*	  FUNCTION n2dword (tnNum)  
*!*	    lcRes = CHR(m.tnNum%256)  
*!*	    m.tnNum = INT(m.tnNum/256)  
*!*	    lcRes = m.lcRes + CHR(m.tnNum%256)  
*!*	    m.tnNum = INT(m.tnNum/256)  
*!*	    lcRes = m.lcRes + CHR(m.tnNum%256)  
*!*	    m.tnNum = INT(m.tnNum/256)  
*!*	    lcRes = m.lcRes + CHR(m.tnNum%256)  
*!*	  RETURN m.lcRes
ENDPROC
PROCEDURE freelibrary
* Œ—¬Œ¡Œ∆ƒ≈Õ»≈ ACTIVEX OCX == DLL ¡»¡À»Œ“≈ »
* œ¿–¿Ã≈“– : ’›ÕƒÀ «¿√–”∆≈ÕÕŒ… ¡»¡À»Œ“≈ »
* –≈«”À‹“¿“ : ”—œ≈’ Œœ≈–¿÷»»
* The FreeLibrary function decrements the reference count of the loaded dynamic-link
* library (DLL). When the reference count reaches zero, the module is unmapped from
* the address space of the calling process and the handle is no longer valid. 
* —Ã. This.RegSvr32()
LPARAMETERS tnHandle AS Integer
LOCAL lnError AS Integer
	IF !THIS.isLoaded("FreeLibrary")
		DECLARE INTEGER FreeLibrary IN WIN32API INTEGER
	ENDIF

	lnError=FreeLibrary(m.tnHandle)
RETURN m.lnError<>0

ENDPROC
PROCEDURE gdicreatebitmap
LPARAMETERS tnWidth as Integer, tnHeight as Integer,;
			tlPlanes as UINT, tlBitsPerPel as UINT, tlpvBits as String
LOCAL llHandleBmp as HANDLE
	IF !THIS.isLoaded("CreateBitmap")
		DECLARE HANDLE CreateBitmap IN GDI32 INTEGER nWidth, INTEGER nHeight,;
				UINT cPlanes, UINT cBitsPerPel, PSTR lpvBits
	ENDIF
	*
	llHandleBmp=CreateBitmap(m.tnWidth, m.tnHeight, m.tlPlanes, m.tlBitsPerPel, @tlpvBits)
RETURN m.llHandleBmp
ENDPROC
PROCEDURE gdicreatepatternbrush
LPARAMETERS thBitmap AS HANDLE
LOCAL llHandleBr as Long
	IF !THIS.isLoaded("CreatePatternBrush")
		DECLARE HANDLE CreatePatternBrush IN GDI32 HANDLE hBitmap
	ENDIF
	*
	llHandleBr=CreatePatternBrush(m.thBitmap)
RETURN m.llHandleBr
ENDPROC
PROCEDURE gdicreatepen
LPARAMETERS tnPenStyle AS Integer, tnWidth as Integer, tlColor as Long
LOCAL llHandlePen as Long
	IF !THIS.isLoaded("CreatePen")
		DECLARE HANDLE CreatePen IN GDI32 INTEGER fnPenStyle, INTEGER nWidth, COLORREF crColor
	ENDIF
	*
	llHandlePen=CreatePen(m.tnPenStyle, m.tnWidth, m.tlColor)
RETURN m.llHandlePen
ENDPROC
PROCEDURE gdigetstockobject
LPARAMETERS tnfnObject as Integer
LOCAL llHandleObj as HANDLE
	IF !THIS.isLoaded("GetStockObject")
		DECLARE HANDLE GetStockObject IN GDI32 INTEGER fnObject
	ENDIF
	*
	llHandlePen=GetStockObject(m.tnfnObject)
RETURN m.llHandleObj

ENDPROC
PROCEDURE gdipatblt
LPARAMETERS thDC AS Integer, tnXLeft as Integer, tnYLeft as Integer,;
			tnWidth as Integer, tnHeight as Integer, tndwRop as Integer
LOCAL llRetVal as Boolean
	IF !THIS.isLoaded("PatBlt")
		DECLARE BOOL PatBlt IN GDI32 HANDLE hDC, INTEGER nXLeft, INTEGER nYLeft,;
				INTEGER nWidth, INTEGER nHeight, INTEGER dwRop
	ENDIF

	llRetVal=PatBlt(m.thDC, m.tnXLeft, m.tnYLeft, m.tnWidth, m.tnHeight, m.tndwRop)
RETURN m.llRetVal
ENDPROC
PROCEDURE gdipdisposeimage
* DESTROY IMAGE
LPARAMETERS tnImage AS Integer
	IF !THIS.isLoaded("GdipDisposeImage")
		DECLARE LONG GdipDisposeImage IN GDIPLUS.DLL LONG
	ENDIF
	*
	GdipDisposeImage(m.tnImage)
ENDPROC
PROCEDURE gdipgetimageheight
* ¬≈“» ¿À‹Õ€… –¿«Ã≈–  ¿–“»Õ » ¬ œ» —≈À¿’
* ¬Œ«¬–¿Ÿ¿≈“ -1 œ–» Õ≈”ƒ¿◊≈
* œ¿–¿Ã≈“– = »Ãﬂ ‘¿…À¿
LPARAMETERS tcFileName AS String
LOCAL lnHeight AS Integer, lnToken AS Integer, lnImage AS Integer
	lnHeight=-1
	*
	IF FILE(m.tcFileName)
		* GDIPLUS INIT
		lnToken=This.GdiplusStartup()
		IF m.lnToken<>0
			* CREATE IMAGE FROM FILE
			lnImage=This.GdipLoadImageFromFile(m.tcFileName)
			*
			IF m.lnImage<>0
				IF !THIS.isLoaded("GdipGetImageHeight")
					DECLARE LONG GdipGetImageHeight IN GDIPLUS.DLL LONG, LONG @ WIDTH
				ENDIF
				*
				GdipGetImageHeight(m.lnImage, @lnHeight)
				* DESTROY IMAGE
				This.GdipDisposeImage(m.lnImage)
			ENDIF
			* GDIPLUS DESTROY
			This.GdiplusShutdown(m.lnToken)
		ENDIF
	ENDIF
RETURN m.lnHeight

ENDPROC
PROCEDURE gdipgetimagerawformat
* ¬Œ«¬–¿Ÿ¿≈“ GDI+ GUID ‘Œ–Ã¿“¿ »«Œ¡–¿∆≈Õ»ﬂ
* ¬ ‘Œ–Ã¿“≈ —“–Œ » VARBINARY 16 »À» ''
* œ¿–¿Ã≈“– : »Ãﬂ ‘¿…À¿
* —Ã. THIS.PARENT.oFUNCTION.GETGDIGUIDDESCRIPTION()
LPARAMETERS tcFileName AS String
LOCAL lnToken AS Integer, lnImage AS Integer, lcGUID AS String, lnStatus AS Integer
	lnStatus = -1
	IF FILE(m.tcFileName)
		* GDIPLUS INIT
		lnToken = This.GdiplusStartup()
		IF m.lnToken<>0
			* CREATE IMAGE FROM FILE
			lnImage = This.GdipLoadImageFromFile(m.tcFileName)

			IF lnImage<>0
				lcGUID = REPLICATE(CHR(0), 16)

				IF !THIS.isLoaded("GdipGetImageRawFormat")
					DECLARE INTEGER GdipGetImageRawFormat IN GDIPLUS.DLL INTEGER, STRING @
				ENDIF

				lnStatus = GdipGetImageRawFormat(m.lnImage, @lcGUID)
				* DESTROY IMAGE
				This.GdipDisposeImage(m.lnImage)
			ENDIF
			* GDIPLUS DESTROY
			This.GdiplusShutdown(m.lnToken)
		ENDIF
	ENDIF
RETURN IIF(m.lnStatus = 0, CAST(m.lcGUID AS Q(16)), '')


ENDPROC
PROCEDURE gdipgetimagewidth
* √Œ–»«ŒÕ“¿À‹Õ€… –¿«Ã≈–  ¿–“»Õ » ¬ œ» —≈À¿’
* ¬Œ«¬–¿Ÿ¿≈“ -1 œ–» Õ≈”ƒ¿◊≈
* œ¿–¿Ã≈“– = »Ãﬂ ‘¿…À¿
LPARAMETERS tcFileName AS String
LOCAL lnWidth AS Integer, lnToken AS Integer, lnImage AS Integer
	lnWidth=-1
	*
	IF FILE(m.tcFileName)
		* GDIPLUS INIT
		lnToken=THIS.GdiplusStartup()
		*
		IF m.lnToken<>0
			* CREATE IMAGE FROM FILE
			lnImage=THIS.GdipLoadImageFromFile(m.tcFileName)
			*
			IF m.lnImage<>0
				IF !THIS.isLoaded("GdipGetImageWidth")
					DECLARE LONG GdipGetImageWidth IN GDIPLUS.DLL LONG, LONG @
				ENDIF
				*
				GdipGetImageWidth(m.lnImage, @lnWidth)
				* DESTROY IMAGE
				THIS.GdipDisposeImage(m.lnImage)
			ENDIF
			* GDIPLUS DESTROY
			THIS.GdiplusShutdown(m.lnToken)
		ENDIF
	ENDIF
RETURN m.lnWidth
ENDPROC
PROCEDURE gdiploadimagefromfile
* CREATE IMAGE FROM FILE
LPARAMETERS tcFileName AS String
LOCAL lnImage AS Integer
	lnImage=0
	* CONVERTS DOUBLE-BYTE CHARACTERS TO UNICODE (WIDE CHARACTERS).
	tcFileName=STRCONV(m.tcFileName+CHR(0), 5)
	* BUG : ¡≈« .DLL Õ≈ œ¿ÿ≈“ œŒƒ W98 » W2K
	IF !THIS.isLoaded("GdipLoadImageFromFile")
		DECLARE INTEGER GdipLoadImageFromFile IN GDIPLUS.DLL STRING, INTEGER @
	ENDIF
	*
	GdipLoadImageFromFile(m.tcFileName, @lnImage)
RETURN m.lnImage

ENDPROC
PROCEDURE gdiplusshutdown
* GDIPLUS DESTROY
LPARAMETERS tnToken
	IF !THIS.isLoaded("GdiplusShutdown")
		DECLARE LONG GdiplusShutdown IN GDIPLUS.DLL LONG
	ENDIF
	*
	GdiplusShutdown(m.tnToken)
ENDPROC
PROCEDURE gdiplusstartup
* GDIPLUS INIT
LOCAL lcStart AS String, lnToken AS Integer
	IF !THIS.isLoaded("GdiplusStartup")
		DECLARE LONG GdiplusStartup IN GDIPLUS.DLL LONG @, STRING @, LONG @
	ENDIF
	* GDIPLUSSTARTUPINPUT STRUCTURE SIZE = 16
	lcStart=CHR(1)+REPLICATE(CHR(0), 15)
	lnToken=0
	GdiplusStartup(@lnToken, @lcStart, 0)
	* ¡≈« «¿ƒ≈–∆ » œ¿ƒ¿ÀŒ œŒƒ W98 » W2K,
	* œŒ ¿ ¬≈«ƒ≈ Õ≈ ƒŒ¡¿¬»À .DLL   IN GDIPLUS
	* This.Sleep(100)
RETURN m.lnToken

ENDPROC
PROCEDURE gdirectangle
LPARAMETERS thDC AS HANDLE, tnLeftRect as Integer, tnTopRect as Integer,;
			tnRightRect as Integer, tnBottomRect as Integer
LOCAL llRetVal as BOOL
	IF !THIS.isLoaded("Rectangle")
		DECLARE BOOL Rectangle IN GDI32 ;
				HANDLE hDC, INTEGER nLeftRect, INTEGER nTopRect,;
				INTEGER nRightRect, INTEGER nBottomRect
	ENDIF
	*
	llRetVal=Rectangle(m.thDC, m.tnLeftRect, m.tnTopRect, m.tnRightRect, m.tnBottomRect)
RETURN m.llRetVal

ENDPROC
PROCEDURE gdisetrop2
LPARAMETERS thDC as HANDLE, tnfnDrawMode as Integer
LOCAL llRetVal as INTEGER
	IF !THIS.isLoaded("SetROP2")
		DECLARE INTEGER SetROP2 IN GDI32 HANDLE hDC, INTEGER fnDrawMode
	ENDIF
	*
	llRetVal=SetROP2(m.thDC, m.tnfnDrawMode)
RETURN m.llRetVal


ENDPROC
PROCEDURE getapppath
* œŒÀÕ€… œ”“‹   œ–»ÀŒ∆≈Õ»ﬁ œŒ –¿—ÿ»–≈Õ»ﬁ »Ã≈Õ» ‘¿…À¿
* This.GetAppPath('DOC') = 'C:\Program Files\Microsoft Office\Office10\WINWORD.EXE'
* This.GetAppPath('TIF') = 'C:\PROGRA~1\CORELD~1\programs\photopnt.exe'
LPARAMETERS tcExtention AS String
	* œ–»¬≈ƒ≈Ã –¿—ÿ»–≈Õ»≈   ¬»ƒ”, Õ¿œ–»Ã≈– : '.DOC', '.TIF'
	lcExtention=ALLTRIM(m.tcExtention)
	lcExtention=IIF(LEFT(m.lcExtention, 1)<>'.', '.', '') + m.lcExtention
	* ◊»“¿≈Ã ¬≈“ ” ¬»ƒ¿ HKEY_CLASSES_ROOT + '.DOC' »À» HKEY_CLASSES_ROOT+'.TIF'
	lcKeyValue=This.RegGetKey(REG_HKEY_CLASSES_ROOT, m.lcExtention)
	* œŒÀ”◊¿≈Ã —“–Œ » “»œ¿ : 'Word.Document.8' »À» 'CorelPhotoPaint.Image.7'
	* P.S.: ’Œ–Œÿ»Ã “ŒÕŒÃ —◊»“¿≈“—ﬂ ¬  ŒÕ÷≈ ” ¿«€¬¿“‹ ¬≈–—»ﬁ œ–»ÀŒ∆≈Õ»ﬂ, Õ¿œ–»Ã≈– '.7' »À» '.8'
	IF !EMPTY(m.lcKeyValue)
		* ƒŒ¡¿¬Àﬂ≈Ã —“–Œ ” '\Shell\Open\Command'
		lcKeyValue=m.lcKeyValue+REG_KEY_APPPATH
		* » ◊»“¿≈Ã “¿Ã-∆≈ «Õ¿◊≈Õ»≈ ¬≈“ » ¬»ƒ¿ :
		* HKEY_CLASSES_ROOT+'Word.Document.8\Shell\Open\Command' »À»
		* HKEY_CLASSES_ROOT+'CorelPhotoPaint.Image.7\Shell\Open\Command'
		lcKeyValue=This.RegGetKey(REG_HKEY_CLASSES_ROOT, m.lcKeyValue)
		* œŒÀ”◊¿≈Ã —“–Œ » ¬»ƒ¿ :
		* "C:\Program Files\Microsoft Office\Office10\WINWORD.EXE" /n /dde
		* C:\PROGRA~1\CORELD~1\programs\photopnt.exe /dde
		IF !EMPTY(m.lcKeyValue)
			* ”¡≈–≈Ã ƒ¬Œ…Õ€≈  ¿¬€◊ » ƒÀ»ÕÕŒ√Œ »Ã≈Õ» ‘¿…À¿
			lcKeyValue=CHRTRAN(m.lcKeyValue, '"', '')

			IF '.EXE'$UPPER(m.lcKeyValue)
				* Œ“¡–Œ—»Ã  Àﬁ◊»
				lcKeyValue=LEFT(m.lcKeyValue, ATC('.EXE', m.lcKeyValue)+3)
			ENDIF

			RETURN m.lcKeyValue
		ENDIF
	ENDIF
RETURN ''
ENDPROC
PROCEDURE getclientrect
* RETRIEVES THE COORDINATES OF A WINDOW'S CLIENT AREA
* –¿«Ã≈–€  À»≈Õ“— Œ… ◊¿—“» Œ Õ¿
* This.GetClientRect(o.Hwnd, @lnWidth, @lnHeight)
* P.S. : ƒ›— “ŒœÕ€≈  ŒŒ–ƒ»Õ¿“€ ÃŒ∆ÕŒ œŒÀ”◊»“‹ ◊≈–≈« GetWindowRect()
LPARAMETERS tnWindowHandle AS Integer, vnWidth AS Integer, vnHeight AS Integer
LOCAL lcString AS String
	IF !THIS.isLoaded("GetClientRect")
		DECLARE SHORT GetClientRect IN WIN32API INTEGER, STRING @
	ENDIF
	*
	lcString=SPACE(16) 
	GetClientRect(m.tnWindowHandle, @lcString) 
	*
	vnWidth=CTOBIN(SUBSTR(m.lcString, 9, 4), "4RS")
	vnHeight=CTOBIN(RIGHT(m.lcString, 4), "4RS")
ENDPROC
PROCEDURE getcpuspeed
* “¿ “Œ¬¿ﬂ ◊¿—“Œ“¿ CPU ¬ MHZ
LOCAL lnCpuSpeed as Integer
	IF !THIS.isLoaded("GetCPUSpeed")
		DECLARE INTEGER GetCPUSpeed IN CPUSPEED.DLL
	ENDIF

	lnCpuSpeed = GetCPUSpeed()
RETURN m.lnCpuSpeed
ENDPROC
PROCEDURE getcursorpos
* X » Y  ŒŒ–ƒ»Õ¿“€  ”–—Œ–¿ Õ¿ ƒ›— “Œœ≈ ?
LPARAMETERS tlY AS Logical
LOCAL lcBuffer AS String
	IF !THIS.isLoaded("GetCursorPos")
		DECLARE INTEGER GetCursorPos IN WIN32API STRING @
	ENDIF

	lcBuffer=SPACE(40)
	GetCursorPos(@lcBuffer)

	IF m.tlY
		RETURN CTOBIN(SUBSTR(m.lcBuffer, 5, 2), "2RS")
		*VAL(ALLTRIM(STR(ASC(SUBSTR(m.lcBuffer, 6))*256+ASC(SUBSTR(m.lcBuffer, 5)))))
	ELSE
		RETURN CTOBIN(SUBSTR(m.lcBuffer, 1, 2), "2RS")
		*VAL(ALLTRIM(STR(ASC(SUBSTR(m.lcBuffer, 2))*256+ASC(SUBSTR(m.lcBuffer, 1)))))
	ENDIF

ENDPROC
PROCEDURE getdatetime
* œŒÀ”◊»“‹ ƒ¿“” » ¬–≈Ãﬂ — —≈–¬≈–¿ (W9X - Unsupported?)
* This.GetDateTime('\\ntserver')
LPARAMETERS tcServerName
LOCAL ltDateTime, lnBufferPointer,;
	lnHour, lnMin, lnSec, lnMove, lnDay, lnMonth, lnYear
	* Returns the time of day information from a specified server. Windows 95/98/Me: Unsupported!
	IF !THIS.isLoaded("NetRemoteTOD")
		DECLARE INTEGER NetRemoteTOD IN NETAPI32 STRING, INTEGER @
	ENDIF
	* Call NetApiBufferFree to free the memory that other network management functions return.
	IF !THIS.isLoaded("NetApiBufferFree")
		DECLARE INTEGER NetApiBufferFree IN NETAPI32 INTEGER Pointer
	ENDIF

	tcServerName=STRCONV(STRCONV(ALLTRIM(m.tcServerName)+CHR(0), 1), 5)
	lnBufferPointer=0
	* ≈—À» Œÿ»¡Œ  Õ≈“
	WITH This.Parent.oFunction
		IF NetRemoteTOD(m.tcServerName, @lnBufferPointer)=0
			lnHour=.PointerToLong(lnBufferPointer+8)	&& ◊‡Ò˚
			lnMin=.PointerToLong(lnBufferPointer+12)	&& ÃËÌÛÚ˚
			lnSec=.PointerToLong(lnBufferPointer+16)	&& —ÂÍÛÌ‰˚
			lnMove=.PointerToLong(lnBufferPointer+24)	&& —ÏÂ˘ÂÌËÂ
			lnDay=.PointerToLong(lnBufferPointer+32) 	&& ƒÂÌ¸
			lnMonth=.PointerToLong(lnBufferPointer+36)	&& ÃÂÒˇˆ
			lnYear=.PointerToLong(lnBufferPointer+40)	&& √Ó‰
			ltDateTime=CTOT(PADL(ALLTRIM(STR(lnDay)), 2, '0')+'/'+;
				PADL(ALLTRIM(STR(lnMonth)), 2, '0')+'/'+;
				PADL(ALLTRIM(STR(lnYear)), 4, '0')+' '+;
				PADL(ALLTRIM(STR(lnHour)), 2, '0')+':'+;
				PADL(ALLTRIM(STR(lnMin)), 2, '0')+':'+; 
				PADL(ALLTRIM(STR(lnSec)), 2, '0'))-(60*lnMove)
		ENDIF
	ENDWITH

	NetApiBufferFree(m.lnBufferPointer)
RETURN m.ltDateTime

ENDPROC
PROCEDURE getdc
* RETRIEVES A HANDLE TO A DISPLAY DEVICE CONTEXT (DC)
* FOR THE CLIENT AREA OF THE SPECIFIED WINDOW
* –≈«”À‹“¿“ : ”—œ≈ÿÕŒ, ≈—À» DC # 0
* IF This.GetDC(ThisForm.Hwnd) # 0
LPARAMETERS tnHWnd AS Integer
LOCAL lnDCHandle as Integer
	IF !THIS.isLoaded("GetDC")
		DECLARE INTEGER GetDC IN WIN32API INTEGER
	ENDIF

	lnDCHandle=GetDC(m.tnHWnd)
RETURN m.lnDCHandle
ENDPROC
PROCEDURE getdevicecaps
LPARAMETERS tnDC as Integer, tnPix as Integer
LOCAL lnCap as Integer
	IF !THIS.isLoaded("GetDeviceCaps")
		DECLARE INTEGER GetDeviceCaps IN WIN32API INTEGER, INTEGER  
	ENDIF

	lnCap = GetDeviceCaps(m.tnDC, m.tnPix)
RETURN m.lnCap
ENDPROC
PROCEDURE getfocus
* HANDLE Œ Õ¿, —¬ﬂ«¿ÕÕŒ√Œ — œŒ“Œ ŒÃ —ŒŒ¡Ÿ≈Õ»…  À¿¬»¿“”–€  
LOCAL lnHandle AS Integer
	IF !THIS.isLoaded("GetFocus")
		DECLARE INTEGER GetFocus IN WIN32API
	ENDIF

	lnHandle=GetFocus()
RETURN m.lnHandle
ENDPROC
PROCEDURE getfolderpath
* TAKES THE CSIDL OF A FOLDER AND RETURNS THE PATH
LPARAMETERS tnFolderId AS Integer, tlCreateNewFolder AS Logical, tlReturnDefaultPath AS Logical
LOCAL lnCreate, lnCurrent, lcFolder, lnReturnValue
	IF !THIS.isLoaded("SHGetFolderPath")
		DECLARE INTEGER SHGetFolderPath IN SHFOLDER INTEGER, INTEGER, INTEGER, INTEGER, STRING
	ENDIF

	lnCreate = IIF(m.tlCreateNewFolder, CSIDL_FLAG_CREATE, 0)
	lnCurrent = IIF(m.tlReturnDefaultPath, SHGFP_TYPE_DEFAULT, SHGFP_TYPE_CURRENT)
	lcFolder = SPACE(512)		&& 260
	lnReturnValue = SHGetFolderPath(0, m.tnFolderId+m.lnCreate, 0, m.lnCurrent, @lcFolder)
RETURN IIF(m.lnReturnValue = 0, ALLTRIM(CHRTRAN(m.lcFolder , CHR(0), '')) + '\', '')

#IF .F.

	–≈«”À‹“¿“ œŒƒ –¿«Õ€Ã» OS :					WIN98-SE2 (RUS)					WINXP-PROF (ENG)
	 =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  = 
	This.GetFolderPath(CSIDL_WINDOWS)			C:\WINDOWS\						C:\WINNT\			- ÂÁÛÎ¸Ú‡Ú˚ ‡Ì‡ÎÓ„Ë˜Ì˚ GetWindowsDirectory()
	This.GetFolderPath(CSIDL_PERSONAL)			C:\ÃÓË ‰ÓÍÛÏÂÌÚ˚\				C:\Documents and Settings\USER\My Documents\
	This.GetFolderPath(CSIDL_PROGRAM_FILES)		C:\Program Files\				C:\Program Files\
	This.GetFolderPath(CSIDL_SYSTEM)			C:\WINDOWS\SYSTEM\				C:\WINNT\System32\	- ÂÁÛÎ¸Ú‡Ú˚ ‡Ì‡ÎÓ„Ë˜Ì˚ GetSystemDirectory()
	This.GetFolderPath(CSIDL_APPDATA)			C:\WINDOWS\Application Data\	C:\Documents and Settings\USER\Application Data\
	This.GetFolderPath(CSIDL_MYPICTURES)		C:\ÃÓË ‰ÓÍÛÏÂÌÚ˚\ÃÓË ËÒÛÌÍË\	C:\Documents and Settings\USER\My Documents\My Pictures\
	This.GetFolderPath(CSIDL_MYMUSIC)			Õ≈“								C:\Documents and Settings\USER\My Documents\My Music\
	This.GetFolderPath(CSIDL_MYVIDEO)			Õ≈“								Õ≈“
	This.GetFolderPath(CSIDL_DESKTOPDIRECTORY)	C:\WINDOWS\–‡·Ó˜ËÈ ÒÚÓÎ\		C:\Documents and Settings\USER\Desktop\
	This.GetFolderPath(CSIDL_FAVORITES)			C:\WINDOWS\»Á·‡ÌÌÓÂ\			C:\Documents and Settings\USER\Favorites\
	This.GetFolderPath(CSIDL_STARTUP)			C:\WINDOWS\√Î‡‚ÌÓÂ ÏÂÌ˛\œÓ„‡ÏÏ˚\¿‚ÚÓÁ‡„ÛÁÍ‡\ C:\Documents and Settings\USER\Start Menu\Programs\Startup\
	This.GetFolderPath(CSIDL_RECENT)			C:\WINDOWS\Recent\				C:\Documents and Settings\USER\Recent\
	This.GetFolderPath(CSIDL_SENDTO)			C:\WINDOWS\SendTo\				C:\Documents and Settings\USER\SendTo\
	This.GetFolderPath(CSIDL_PROGRAM_FILES_COMMON)	 =  œŒƒ W98 Õ≈ œ–Œ¬≈–ﬂÀ  = 		C:\Program Files\Common Files\

	P.S.: You can use SHGetFolderPath function on earlier systems by including the redistributable ShFolder.dll

	CSIDL_DESKTOP					 =  0x0000
	CSIDL_INTERNET					 =  0x0001
	CSIDL_PROGRAMS					 =  0x0002
	CSIDL_CONTROLS					 =  0x0003
	CSIDL_PRINTERS					 =  0x0004
	CSIDL_PERSONAL					 =  0x0005
	CSIDL_FAVORITES					 =  0x0006
	CSIDL_STARTUP					 =  0x0007
	CSIDL_RECENT					 =  0x0008
	CSIDL_SENDTO					 =  0x0009
	CSIDL_BITBUCKET					 =  0x000A
	CSIDL_STARTMENU					 =  0x000B
	CSIDL_MYDOCUMENTS				 =  0x000C
	CSIDL_MYMUSIC					 =  0x000D
	CSIDL_MYVIDEO					 =  0x000E
	CSIDL_DESKTOPDIRECTORY			 =  0x0010
	CSIDL_DRIVES					 =  0x0011
	CSIDL_NETWORK					 =  0x0012
	CSIDL_NETHOOD					 =  0x0013
	CSIDL_FONTS						 =  0x0014
	CSIDL_TEMPLATES					 =  0x0015
	CSIDL_COMMON_STARTMENU			 =  0x0016
	CSIDL_COMMON_PROGRAMS			 =  0x0017
	CSIDL_COMMON_STARTUP			 =  0x0018
	CSIDL_COMMON_DESKTOPDIRECTORY	 =  0x0019
	CSIDL_APPDATA					 =  0x001A
	CSIDL_PRINTHOOD					 =  0x001B
	CSIDL_LOCAL_APPDATA				 =  0x001C
	CSIDL_ALTSTARTUP				 =  0x001D
	CSIDL_COMMON_ALTSTARTUP			 =  0x001E
	CSIDL_COMMON_FAVORITES			 =  0x001F
	CSIDL_INTERNET_CACHE			 =  0x0020
	CSIDL_COOKIES					 =  0x0021
	CSIDL_HISTORY					 =  0x0022
	CSIDL_COMMON_APPDATA			 =  0x0023
	CSIDL_WINDOWS					 =  0x0024
	CSIDL_SYSTEM					 =  0x0025
	CSIDL_PROGRAM_FILES				 =  0x0026
	CSIDL_MYPICTURES				 =  0x0027
	CSIDL_PROFILE					 =  0x0028
	CSIDL_SYSTEMX86					 =  0x0029
	CSIDL_PROGRAM_FILESX86			 =  0x002A
	CSIDL_PROGRAM_FILES_COMMON		 =  0x002B
	CSIDL_PROGRAM_FILES_COMMONX86	 =  0x002C
	CSIDL_COMMON_TEMPLATES			 =  0x002D
	CSIDL_COMMON_DOCUMENTS			 =  0x002E
	CSIDL_COMMON_ADMINTOOLS			 =  0x002F
	CSIDL_ADMINTOOLS				 =  0x0030
	CSIDL_CONNECTIONS				 =  0x0031
	CSIDL_COMMON_MUSIC				 =  0x0035
	CSIDL_COMMON_PICTURES			 =  0x0036
	CSIDL_COMMON_VIDEO				 =  0x0037
	CSIDL_RESOURCES					 =  0x0038
	CSIDL_RESOURCES_LOCALIZED		 =  0x0039
	CSIDL_COMMON_OEM_LINKS			 =  0x003A
	CSIDL_CDBURN_AREA				 =  0x003B
	CSIDL_COMPUTERSNEARME			 =  0x003D
	CSIDL_FLAG_PER_USER_INIT		 =  0x0800
	CSIDL_FLAG_NO_ALIAS				 =  0x1000
	CSIDL_FLAG_DONT_VERIFY			 =  0x4000
	CSIDL_FLAG_CREATE				 =  0x8000
	CSIDL_FLAG_MASK					 =  0xFF00

	CSIDL_DESKTOP
	Windows desktopóvirtual folder that is the root of the name space. 
	CSIDL_INTERNET
	Virtual folder that represents the Internet. 
	CSIDL_PROGRAMS
	File system directory that contains the user's program groups (which are also file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs. 
	CSIDL_CONTROLS
	Virtual folder that contains icons for Control Panel applications. 
	CSIDL_PRINTERS
	Virtual folder that contains installed printers. 
	CSIDL_PERSONAL
	File system directory that serves as a common repository for documents. A typical path is C:\Documents and Settings\username\My Documents. This is different from the My Documents virtual folder in the name space. To access that virtual folder, use the technique described in Managing the File System . 
	CSIDL_FAVORITES
	File system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites. 
	CSIDL_STARTUP
	File system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto MicrosoftÆ Windows NTÆ or starts Microsoft WindowsÆ 98. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup. 
	CSIDL_RECENT
	File system directory that contains the user's most recently used documents. A typical path is C:\Documents and Settings\username\Recent. To create a shortcut in this folder, use SHAddToRecentDocs . In addition to creating the shortcut, this function updates the Shell's list of recent documents and adds the shortcut to the Documents submenu of the Start menu. 
	CSIDL_SENDTO
	File system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo. 
	CSIDL_BITBUCKET
	Virtual folder that contains the objects in the user's Recycle Bin. 
	CSIDL_STARTMENU
	File system directory that contains Start Menu items. A typical path is C:\Documents and Settings\username\Start Menu. 
	CSIDL_MYDOCUMENTS
	Virtual folder that contains the objects in the user's My Documents folder.
	CSIDL_MYMUSIC
	File system directory that serves as a common repository for music files. A typical path is C:\My Music. 
	CSIDL_MYVIDEO
	File system directory that serves as a common repository for video files. 
	CSIDL_DESKTOPDIRECTORY
	File system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop 
	CSIDL_DRIVES
	My Computeróvirtual folder that contains everything on the local computer: storage devices, printers, and Control Panel. The folder can also contain mapped network drives. 
	CSIDL_NETWORK
	Network Neighborhoodóvirtual folder that represents the root of the network namespace hierarchy. 
	CSIDL_NETHOOD
	A file system folder that contains the link objects that can exist in the My Network Places virtual folder. It is not the same as CSIDL , which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood. 
	CSIDL_FONTS
	Virtual folder that contains fonts. A typical path is C:\WINNT\Fonts. 
	CSIDL_TEMPLATES
	File system directory that serves as a common repository for document templates. 
	CSIDL_COMMON_STARTMENU
	File system directory that contains the programs and folders that appear on the Start Menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu. Valid only for Windows NT systems. 
	CSIDL_COMMON_PROGRAMS
	File system directory that contains the directories for the common program groups that appear in the Start Menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs. Valid only for Windows NT systems. 
	CSIDL_COMMON_STARTUP
	File system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup. Valid only for Windows NT systems. 
	CSIDL_COMMON_DESKTOPDIRECTORY
	File system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop. Valid only for Windows NT systems. 
	CSIDL_APPDATA
	Version 4.71 . File system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\username\Application Data. This CSIDL is supported by the redistributable ShFolder.dll for systems that do not have the Microsoft Internet Explorer 4.0 integrated Shell installed. 
	CSIDL_PRINTHOOD
	File system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood. 
	CSIDL_LOCAL_APPDATA
	Version 5.0 . File system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data. 
	CSIDL_ALTSTARTUP
	File system directory that corresponds to the user's nonlocalized Startup program group. 
	CSIDL_COMMON_ALTSTARTUP
	File system directory that corresponds to the nonlocalized Startup program group for all users. Valid only for Windows NT systems. 
	CSIDL_COMMON_FAVORITES
	File system directory that serves as a common repository for all user's favorite items. Valid only for Windows NT systems. 
	CSIDL_INTERNET_CACHE
	Version 4.72 . File system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Temporary Internet Files. 
	CSIDL_COOKIES
	File system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies. 
	CSIDL_HISTORY
	File system directory that serves as a common repository for Internet history items. 
	CSIDL_COMMON_APPDATA
	Version 5.0 . Application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data. 
	CSIDL_WINDOWS
	Version 5.0 . Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\WINNT. 
	CSIDL_SYSTEM
	Version 5.0 . System folder. A typical path is C:\WINNT\SYSTEM32. 
	CSIDL_PROGRAM_FILES
	Version 5.0 . Program Files folder. A typical path is C:\Program Files. 
	CSIDL_MYPICTURES
	Version 5.0 . My Pictures folder. A typical path is C:\Documents and Settings\username\My Documents\My Pictures. 
	CSIDL_PROFILE
	Version 5.0 . User's profile folder. 
	CSIDL_SYSTEMX86
	The x86 system directory on Reduced Instruction Set Computer (RISC) systems. 
	CSIDL_PROGRAM_FILESX86
	The x86 Program Files folder on RISC systems. 
	CSIDL_PROGRAM_FILES_COMMON
	Version 5.0 . A folder for components that are shared across applications. A typical path is C:\Program Files\Common. Valid only for Windows NT and Windows 2000 systems. 
	CSIDL_PROGRAM_FILES_COMMONX86
	The x86 Program Files Common folder on RISC systems. 
	CSIDL_COMMON_TEMPLATES
	File system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates. Valid only for Windows NT systems. 
	CSIDL_COMMON_DOCUMENTS
	File system directory that contains documents that are common to all users. Typical paths are C:\Documents and Settings\All Users\Documents. Valid for Windows NT systems and Windows 95 and Windows 98 systems with Shfolder.dll installed. 
	CSIDL_COMMON_ADMINTOOLS
	Version 5.0 . File system directory that contains administrative tools for all users. 
	CSIDL_ADMINTOOLS
	Version 5.0 . File system directory used to store administrative tools for an individual user. The Microsoft Management Console (MMC) saves customized consoles to this directory, and it roams with the user. 
	CSIDL_CONNECTIONS
	Virtual folder that contains network and dial-up connections. 
	CSIDL_COMMON_MUSIC
	My Music folder for all users. For more information, see CSIDL . 
	CSIDL_COMMON_PICTURES
	My Pictures folder for all users. For more information, see CSIDL . 
	CSIDL_COMMON_VIDEO
	My Video folder for all users. For more information, see CSIDL . 
	CSIDL_RESOURCES
	System resource directory. A typical path is C:\WINNT\Resources. 
	CSIDL_RESOURCES_LOCALIZED
	Localized resource directory. For more information, see CSIDL . 
	CSIDL_COMMON_OEM_LINKS
	Folder containing links to OEM specific applications for all users. 
	CSIDL_CDBURN_AREA
	File system folder used to hold data for burning to a CD. Typically [User Profile Folder]\Local Settings\Applications Data\Microsoft\CD Burning. 
	CSIDL_COMPUTERSNEARME
	Computers Near Me folder. Virtual folder that contains links to nearby computers on the network. Nearness it is established by common work group membership. 
	CSIDL_FLAG_PER_USER_INIT
	Combine this flag with the desired CSIDL_ value to indicate per-user initialization. 
	CSIDL_FLAG_NO_ALIAS
	Combine this flag with the desired CSIDL_ value to force a non-alias version of the PIDL. 
	CSIDL_FLAG_DONT_VERIFY
	Combine this flag with the desired CSIDL_ value to return an unverified folder path. 
	CSIDL_FLAG_CREATE
	Combine this flag with the desired CSIDL_ value to force the creation of the associated folder. 
	CSIDL_FLAG_MASK
	Mask for all possible CSIDL flag values

#ENDIF
ENDPROC
PROCEDURE getguid
* GUID - GLOBALLY UNIQUE IDENTIFIER
* ”Õ» ¿À‹Õ¿ﬂ —“–Œ ¿ ¬»ƒ¿ '{96C1E335-B6C2-41C7-9602-295CD99988E3}'
* »—œŒÀ‹«”≈“—ﬂ, Õ¿œ–»Ã≈–, ƒÀﬂ ‘Œ–Ã»–Œ¬¿Õ»ﬂ ¬≈“Œ  CLSID ¬ –≈≈—“–≈ WINDOWS
* —“–Œ ¿ ƒÀ»ÕÕŒ… 38 ¡¿…“
LOCAL lcGuid AS String, lcResult AS String
	IF !THIS.isLoaded("CoCreateGuid")
		DECLARE INTEGER CoCreateGuid IN OLE32.DLL STRING @
	ENDIF

	IF !THIS.isLoaded("StringFromGuid2")
		DECLARE INTEGER StringFromGUID2	IN OLE32.DLL STRING, STRING @, INTEGER
	ENDIF

	lcGuid = SPACE(16)
	CoCreateGuid(@lcGuid)

	DO WHILE ASC(LEFT(m.lcGuid,1)) = 0
		CoCreateGuid(@lcGuid)
	ENDDO

	lcResult = SPACE(0076)

	StringFromGuid2(m.lcGuid, @lcResult, LEN(m.lcResult))
RETURN STRCONV(m.lcResult, 6)
ENDPROC
PROCEDURE getipaddress
* IP ¿ƒ–≈— Ã¿ÿ»Õ€ »À» Ã¿— ¿ œŒƒ—≈“» ¬ ¬»ƒ≈ —“–Œ » : '999.999.999.999'
* œŒ ÕŒÃ≈–” ¬’Œ∆ƒ≈Õ»ﬂ  ŒÕ –≈“ÕŒ√Œ IP ¿ƒ–≈—¿ ¬ “¿¡À»÷≈ ¿ƒ–≈—Œ¬
* » ∆≈À¿≈ÃŒÃ” “»œ” –≈«”À‹“¿“¿ (IPADDRESS OR SUBNETMASK)
* »—œŒÀ‹«Œ¬¿“‹ ¬ œ¿–≈ C THIS.GETIPENTRIES()
* ƒ–”√Œ… ¬¿–»¿Õ“ ◊≈–≈« MSWINSOCK :
* o = CREATEOBJECT('mswinsock.winsock')
* MESSAGEBOX(o.LocalIP)
LPARAMETER tnEntry AS Integer, tlSubNetMask AS Logical
LOCAL lnIpSize AS Integer, lcIpTable AS String, lcAddress AS String
	* œ–Œ“Œ ŒÀ Õ≈ ”—“¿ÕŒ¬À≈Õ
	IF m.tnEntry=0
		RETURN '000.000.000.000'
	ENDIF
	* «¿–≈«≈–¬»–”≈Ã Ã≈—“Œ œŒƒ —“–” “”–”
	lnIpSize=1024 && Œ·˚˜ÌÓ 300 ?
	lcIpTable=SPACE(m.lnIpSize)
	* œŒÀ”◊»Ã —“–” “”–” — IP ¿ƒ–≈—¿Ã»
	IF !THIS.isLoaded("GetIpAddrTable")
		DECLARE INTEGER GetIpAddrTable IN IPHLPAPI STRING @, INTEGER @, INTEGER
	ENDIF
	*
	GetIpAddrTable(@lcIpTable, @lnIpSize, 1)
	* œŒÀ”◊»Ã —“–Œ » IP ¿ƒ–≈—¿ »À» Ã¿— » œŒƒ—≈“»
	lcAddress=SUBSTR(m.lcIpTable, 24*(m.tnEntry-1)+5+IIF(m.tlSubNetMask, 8, 0), 4)
	* œ≈–≈¬≈ƒ≈Ã ¬ “Œ◊≈◊Õ”ﬁ ÕŒ“¿÷»ﬁ ¬»ƒ¿ : '999.999.999.999'
RETURN TRANSFORM(ASC(m.lcAddress), '@L 999')+'.'+;
   TRANSFORM(ASC(SUBSTR(m.lcAddress, 2, 1)), '@L 999')+'.'+;
   TRANSFORM(ASC(SUBSTR(m.lcAddress, 3, 1)), '@L 999')+'.'+;
   TRANSFORM(ASC(SUBSTR(m.lcAddress, 4, 1)), '@L 999')


* Convert LongInt to IP Address string
* PROCEDURE Int32ToIPStrFast(nIP)
* RETURN LTRIM(STR(BITAND(nIP, 0xFF))) + "." + ;
	LTRIM(STR(BITAND(BITRSHIFT(nIP, 8 * 1), 0xFF))) + "." + ;
	LTRIM(STR(BITAND(BITRSHIFT(nIP, 8 * 2), 0xFF))) + "." + ;
	LTRIM(STR(BITRSHIFT(nIP, 8 * 3)))


ENDPROC
PROCEDURE getipentries
*  ŒÀ»◊≈—“¬Œ IP ¿ƒ–≈—Œ¬ Õ¿ Ã¿ÿ»Õ≈
* »—œŒÀ‹«Œ¬¿“‹ ¬ œ¿–≈ — THIS.GETIPADDRESS()
LOCAL lnIpSize AS Integer, lcIpTable AS String, lcAddress AS String
	* «¿–≈«≈–¬»–”≈Ã Ã≈—“Œ œŒƒ —“–” “”–”
	lnIpSize=1024 && Œ·˚˜ÌÓ 300 ?
	lcIpTable=SPACE(m.lnIpSize)
	* œŒÀ”◊»Ã —“–” “”–” — IP ¿ƒ–≈—¿Ã»
	IF !THIS.isLoaded("GetIpAddrTable")
		DECLARE INTEGER GetIpAddrTable IN IPHLPAPI STRING @, INTEGER @, INTEGER
	ENDIF
	*
	TRY
		GetIpAddrTable(@lcIpTable, @lnIpSize, 1)
		lnEntries=CTOBIN(LEFT(m.lcIpTable, 4), '4RS')
	CATCH
		* œ–Œ“Œ ŒÀ Õ≈ ”—“¿ÕŒ¬À≈Õ
		lnEntries=0
	ENDTRY
RETURN m.lnEntries

ENDPROC
PROCEDURE getkeyboardlayoutname
* ¬Œ«¬–¿Ÿ¿≈“ “≈ ”Ÿ”ﬁ –¿— À¿ƒ ”  À¿¬»¿“”–€
* IF This.GetKeyboardLayoutName()  =  LANGID_RUS ... '00000419'  =  Russian
LOCAL lcLayout AS String
	lcLayout = SPACE(8)

	IF !THIS.isLoaded("GetKeyboardLayoutName")
		DECLARE GetKeyboardLayoutName IN WIN32API STRING @
	ENDIF

	GetKeyboardLayoutName(@lcLayout)
RETURN m.lcLayout
ENDPROC
PROCEDURE getlastactivepopup
* Õ¿…ƒ≈Ã ” ¿«¿“≈À‹ Õ¿ œŒ—À≈ƒÕ≈≈ ¿ “»¬ÕŒ≈ ƒŒ◊≈–Õ≈≈ Œ ÕŒ ¬ Œ Õ≈ — tnHWnd
* DETERMINES WHICH POP-UP WINDOW OWNED BY THE SPECIFIED WINDOW WAS MOST RECENTLY ACTIVE
* –≈«”À‹“¿“ –¿¬≈Õ tnHWnd, ≈—À» :
* 1) tnWnd Ë ÂÒÚ¸ ÔÓÒÎÂ‰ÌÂÂ ‡ÍÚË‚ÌÓÂ ÓÍÌÓ
* 2) tnWnd ÌÂ ÒÓ‰ÂÊËÚ ‰Ó˜ÂÌËı ÓÍÓÌ
* 3) tnWnd ÌÂ toplevel-ÓÍÌÓ ËÎË Ò‡ÏÓ ˇ‚ÎˇÂÚÒˇ ‰Ó˜ÂÌËÏ
* This.GetLastActivePopup(goApp.oVars.HWnd)
LPARAMETERS tnHWnd AS Integer
LOCAL lnHandle as Integer
	IF !THIS.isLoaded("GetLastActivePopup")
		DECLARE INTEGER GetLastActivePopup IN WIN32API INTEGER
	ENDIF

	lnHandle = GetLastActivePopup(m.tnHWnd)
RETURN m.lnHandle

ENDPROC
PROCEDURE getlasterror
* THE GETLASTERROR FUNCTION RETRIEVES THE CALLING THREAD"S LAST-ERROR CODE VALUE.
	IF !THIS.isLoaded("GetLastError")
		DECLARE INTEGER GetLastError IN WIN32API
	ENDIF

	lnError=GetLastError()
RETURN m.lnError
ENDPROC
PROCEDURE getlogicaldrive
* —œ»—Œ  ƒ»— Œ¬ — ” ¿«¿Õ»≈Ã »’ “»œ¿
* This. GetLogicalDriveStrings('—')
LPARAMETERS taListDrivers
LOCAL lnI, lnbuflen, lcbuf
	IF !THIS.isLoaded("GetLogicalDriveStrings")
		DECLARE INTEGER GetLogicalDriveStrings IN WIN32API Integer, String @
	ENDIF

	IF !THIS.isLoaded("GetDriveType")
		DECLARE INTEGER GetDriveType IN WIN32API String
	ENDIF
	
	lnbuflen = 104 
	lcbuf = REPLICATE(CHR(0), m.lnbuflen)

	GetLogicalDriveStrings(m.lnbuflen, @lcbuf)
	lcbuf = ALLTRIM(CHRTRAN(m.lcbuf, CHR(0) + "\:", ""))
	
	DIMENSION taListDrivers[LEN(m.lcbuf), 2]

	FOR lnI = 1 TO LEN(m.lcbuf)
		taListDrivers[m.lnI, 1] = SUBSTR(m.lcbuf, m.lnI, 1) + ":\"
		taListDrivers[m.lnI, 2] = GetDriveType(taListDrivers[m.lnI, 1])
	ENDFOR
RETURN
ENDPROC
PROCEDURE getmessagepos
*  ŒŒ–ƒ»Õ¿“€ Œ¡⁄≈ “¿ (Œ“ÕŒ—»“≈À‹ÕŒ ƒ›— “Œœ¿), œŒÀ”◊»¬ÿ≈√Œ œŒ—À≈ƒÕ≈≈ —ŒŒ¡Ÿ≈Õ»≈
* This.GetMessagePos() - LEFT, This.GetMessagePos(.T.) - TOP
* Õ¿œ–»Ã≈– ¿¡—ŒÀﬁ“Õ€≈  ŒŒ–ƒ»Õ¿“€  À» ¿ œŒ Õ≈ ŒÃ”  ŒÕ“–ŒÀ” Õ¿ ‘Œ–Ã≈
* ÃŒ∆ÕŒ œŒÀ”◊»“‹, ≈—À» ¬ ≈√Œ GOTFOCUS() œŒÀŒ∆»“‹  Œƒ :
* MESSAGEBOX('Left = '+TRANSFORM(This.GetMessagePos(.F.))+;
* 	' Top = '+TRANSFORM(This.GetMessagePos(.T.)))
* P.S.1 VFP  ŒÕ“–ŒÀ€ - –»—Œ¬¿ÕÕ€≈ ¡»“Ã¿œ€, ¿ Õ≈ Œ Õ¿, ÕŒ Õ≈ ¬—≈√ƒ¿
* Õ¿œ–»Ã≈– COMBOBOX - –»—”ÕŒ , ¿ ≈√Œ ¬€œ¿ƒ¿ﬁŸ»… —œ»—Œ  - Œ ÕŒ !
* (»Õ¿◊≈ —œ»—Œ  Õ≈¬Œ«ÃŒ∆ÕŒ ¡€ÀŒ ¡€ œŒ ¿«¿“‹ «¿ œ–≈ƒ≈À¿Ã» ‘Œ–Ã€)
* P.S.2 —Ã. œŒÀ”◊≈Õ»≈ ¿¡—ŒÀﬁ“Õ€’  ŒŒ–ƒ»Õ¿“ ‘Œ–Ã€ This.ClientToScreen(...)
LPARAMETERS tlTop AS Logical
LOCAL lnPosition AS Integer
	IF !THIS.isLoaded("GetMessagePos")
		DECLARE LONG GetMessagePos IN WIN32API
	ENDIF

	lnPosition = GetMessagePos()
RETURN IIF(m.tlTop, INT(m.lnPositio / 65536), BITAND(m.lnPosition, 4095))

ENDPROC
PROCEDURE getprocaddress
* œŒ»—  ¿ƒ–≈—¿ “Œ◊ » ¬’Œƒ¿ œ–Œ÷≈ƒ”–€ ¬ ACTIVEX OCX == DLL ¡»¡À»Œ“≈ ≈
* œ¿–¿Ã≈“– : ’›ÕƒÀ ¡»¡À»Œ“≈ », »Ãﬂ œ–Œ÷≈ƒ”–€
* –≈«”À‹“¿“ : ¿ƒ–≈— “Œ◊ » ¬’Œƒ¿ œ–Œ÷≈ƒ”–€ ¬ ¡»¡À»Œ“≈ ≈ »À» 0
* —Ã. This.RegSvr32()
LPARAMETERS tnHandle AS Integer, tcProcedure AS String
LOCAL lnAddress AS Integer
	IF !THIS.isLoaded("GetProcAddress")
		DECLARE INTEGER GetProcAddress IN WIN32API INTEGER, STRING
	ENDIF
	*
	lnAddress=GetProcAddress(m.tnHandle, m.tcProcedure)
RETURN m.lnAddress
ENDPROC
PROCEDURE getshortfilename
*  ŒÕ¬≈–“¿÷»ﬂ ƒÀ»ÕÕŒ√Œ œ”“» » »Ã≈Õ» ‘¿…À¿ ¬  Œ–Œ“ Œ≈
* ‘¿…À, — œ≈–≈ƒ¿¬¿≈Ã€Ã ¬  ¿◊≈—“¬≈ œ¿–¿Ã≈“–¿ »Ã≈Õ≈Ã, ƒŒÀ∆≈Õ —”Ÿ≈—“¬Œ¬¿“‹
* –≈«”À‹“¿“ : »Ãﬂ ¬ ‘Œ–Ã¿“≈ 8.3 »À» '' ¬ —À”◊¿≈ Œÿ»¡ » 
* This.GetShortFileName('C:\ÃŒ» ƒŒ ”Ã≈Õ“€')  =  '—:\ÃŒ»ƒŒ ~1'
LPARAMETERS tcInputString as String
LOCAL lcOutputString, lnStringLength
	IF !THIS.isLoaded("GetShortPathName")
		DECLARE INTEGER GetShortPathName IN WIN32API STRING, STRING, INTEGER
	ENDIF

	lcOutputString = SPACE(255)
	lnStringLength = GetShortPathName(@tcInputString, @lcOutputString, 255) 
RETURN IIF(m.lnStringLength = 0, '', LEFT(m.lcOutputString, m.lnStringLength))
ENDPROC
PROCEDURE getsyscolor
* ÷¬≈“¿ —»—“≈ÃÕ€’ ›À≈Ã≈Õ“Œ¬
* This.GetSysColor(COLOR_ACTIVECAPTION)				= 6956042	= COLOR_FORM_TITLEBAR_GOTFOCUS_LEFT		= RGB(010, 036, 106)
* This.GetSysColor(COLOR_GRADIENTACTIVECAPTION)		= 15780518	= COLOR_FORM_TITLEBAR_GOTFOCUS_RIGHT	= RGB(166, 202, 240)
* This.GetSysColor(COLOR_INACTIVECAPTION)			= 8421504	= COLOR_FORM_TITLEBAR_LOSTFOCUS_LEFT	= RGB(128, 128, 128)
* This.GetSysColor(COLOR_GRADIENTINACTIVECAPTION)	= 12632256	= COLOR_FORM_TITLEBAR_LOSTFOCUS_RIGHT	= RGB(192, 192, 192)
* This.GetSysColor(COLOR_DESKTOP)					= ÷¬≈“ –¿¡Œ◊≈√Œ —“ŒÀ¿
LPARAMETERS tnIndex
LOCAL lnReturnValue AS Integer
	IF !THIS.isLoaded("GetSysColor")
		DECLARE INTEGER GetSysColor IN WIN32API INTEGER  
	ENDIF
	*
	lnReturnValue=GetSysColor(m.tnIndex)
RETURN m.lnReturnValue

ENDPROC
PROCEDURE getsystemdirectory
* ¬Œ«¬–¿Ÿ¿≈“ —»—“≈ÃÕ€…  ¿“¿ÀŒ√, Õ¿œ–»Ã≈– 
* 'C:\WINDOWS\SYSTEM\' ƒÀﬂ W9X »
* 'C:\WINDOWS\SYSTEM32\' ƒÀﬂ WNT
LOCAL lcPath as String, lnSize as Integer
	IF !THIS.isLoaded("GetSystemDirectory")
		DECLARE INTEGER GetSystemDirectory IN WIN32API STRING, INTEGER
	ENDIF

	lcPath = SPACE(512)
	lnSize = GetSystemDirectory(@lcPath, 512)
RETURN LEFT(m.lcPath, m.lnSize) + '\'
ENDPROC
PROCEDURE getsystemmetrics
* WIDTHS AND HEIGHTS OF DISPLAY ELEMENTS AND SYSTEM CONFIGURATION SETTINGS
*						œ‡‡ÏÂÚ –ÂÁÛÎ¸Ú‡Ú
* SM_CXVSCROLL			= 02	->	16 ÿËËÌ‡ ‚ÂÚËÍ‡Î¸ÌÓ„Ó ÒÍÓÎ·‡‡, Ì‡ÔËÏÂ ÍÌÓÔÓÍ ÒÔËÌÌÂ‡
* SM_CMOUSEBUTTONS		= 43	->	05  ÓÎË˜ÂÒÚ‚Ó ÍÌÓÔÓÍ Ï˚¯ÍË ËÎË 0, ÂÒÎË Ï˚¯ÍË ÌÂÚ.
* SM_MOUSEWHEELPRESENT	= 75	->	01 (WNT,W98,WME) TRUE or nonzero if a mouse with a wheel is installed; FALSE or zero otherwise
* SM_CLEANBOOT			= 67	->	00 0:Normal boot / 1:Safe-mode / 2:Safe-mode with network support
* See Also : SYSMETRIC(nScreenElement)
LPARAMETERS tnMetricIndex AS Integer
LOCAL luReturnValue AS Variant
	IF !THIS.isLoaded("GetSystemMetrics")
		DECLARE INTEGER GetSystemMetrics IN WIN32API INTEGER
	ENDIF
	*
	luReturnValue=GetSystemMetrics(m.tnMetricIndex)
RETURN m.luReturnValue

ENDPROC
PROCEDURE gettempfilename
* —Œ«ƒ¿≈“ ”Õ» ¿À‹Õ€… .TMP ‘¿…À ¬  ¿“¿ÀŒ√≈ TCPATH C œ–≈‘» —ŒÃ TCPREFIX
* œ–≈‘» — - œ≈–¬€≈ 3 —»Ã¬ŒÀ¿ »Ã≈Õ» ‘¿…À¿ - œŒ ”ÃŒÀ◊¿Õ»ﬁ 'tmp'
* –≈«”À‹“¿“ œ”“‹ + »Ãﬂ_‘¿…À¿ + '.tmp' »À» œ”—“¿ﬂ —“–Œ ¿
LPARAMETERS tcPath, tcPrefix
LOCAL lcPath, lcPrefix, lcName
	lcPath=IIF(VARTYPE(m.tcPath)='C' AND !EMPTY(m.tcPath), m.tcPath, SYS(2023))
	lcPrefix=IIF(VARTYPE(m.tcPrefix)='C' AND !EMPTY(m.tcPrefix), m.tcPrefix, 'tmp')
	lcName=SPACE(576)
	*
	IF !THIS.isLoaded("GetTempFileName")
		DECLARE LONG GetTempFileName IN WIN32API STRING, STRING, LONG, STRING
	ENDIF
	*
	GetTempFileName(m.lcPath, m.lcPrefix, 0, @lcName)
RETURN STRTRAN(TRIM(m.lcName), CHR(0))
ENDPROC
PROCEDURE gettemppath
*  ¿“¿ÀŒ√ ¬–≈Ã≈ÕÕ€’ ‘¿…ÀŒ¬ WINDOWS
* WIN98-SE2  (RUS) : 'C:\WINDOWS\TEMP\'
* WINXP-PROF (ENG) : 'C:\DOCUME~1\USER\LOCALS~1\Temp\'
LOCAL lcTempPath AS String
	IF !THIS.isLoaded("GetTempPath")
		DECLARE INTEGER	GetTempPath IN WIN32API	LONG, STRING
	ENDIF
	*
	lcTempPath=SPACE(512)
	GetTempPath(512, @lcTempPath)
RETURN STRTRAN(ALLTRIM(m.lcTempPath), CHR(0))
ENDPROC
PROCEDURE gettickcount
*  ŒÀ»◊≈—“¬Œ Ã»À»—≈ ”Õƒ (»À» —≈ ”Õƒ, ≈—À» TLRETURNSECONDS = .T.),
* œ–Œÿ≈ƒÿ»’ — ÃŒÃ≈Õ“¿ —“¿–“¿ Œœ≈–¿÷»ŒÕÕŒ… —»—“≈Ã€ = SYSTEM UP TIME
* ”ƒŒ¡ÕŒ ƒÀﬂ “Œ◊ÕŒ√Œ «¿Ã≈–¿ Ã¿À€’ »Õ“≈–¬¿ÀŒ¬ ¬–≈Ã≈Õ»
* Õ¿œ–»Ã≈– - ƒÀﬂ œ–Œ‘»À»–Œ¬¿Õ»ﬂ ¬€œŒÀÕ≈Õ»ﬂ œ–Œ√–¿ÃÃ€
* P.S. Ã»Õ»Ã¿À‹Õ€… »Õ“≈–¬¿À ¬–≈Ã≈Õ» ¬ WINDOWS - Œ ŒÀŒ 55 Ã»ÀÀ»—≈ ”Õƒ
LPARAMETERS tlReturnSeconds AS Logical
LOCAL lnMilliseconds AS Integer
	IF !THIS.isLoaded("GetTickCount")
		DECLARE LONG GetTickCount IN WIN32API
	ENDIF
	*
	lnMilliseconds=GetTickCount()
RETURN IIF(m.tlReturnSeconds, ROUND(m.lnMilliseconds/1000, 0), m.lnMilliseconds)
ENDPROC
PROCEDURE gettimezoneinformation
* ¬Œ«¬–¿Ÿ¿≈“ —“–Œ ” — Œœ»—¿Õ»≈Ã ¬–≈Ã≈ÕÕŒ… «ŒÕ€
* (œ≈–¬€≈ 4 ¡¿…“¿ = BIAS)
LOCAL lcTimeZone AS String
	lcTimeZone=REPLICATE(CHR(0), TIME_ZONE_SIZE)
	*
	IF !THIS.isLoaded("GetTimeZoneInformation")
		DECLARE INTEGER GetTimeZoneInformation IN WIN32API STRING @
	ENDIF
	*
	GetTimeZoneInformation(@lcTimeZone)
RETURN m.lcTimeZone
ENDPROC
PROCEDURE getuserdefaultlcid
LOCAL lnLCID as Integer
	IF !THIS.isLoaded("GetUserDefaultLCID")
		DECLARE Integer GetUserDefaultLCID IN Win32Api
	ENDIF
	*
	lnLCID=GetUserDefaultLCID()
	*1049- Russian
RETURN m.lnLCID
ENDPROC
PROCEDURE getvolumeinformation
* —≈–»…Õ€… ÕŒÃ≈– ÀŒ√»◊≈— Œ√Œ ƒ»— ¿
* This.GetVolumeInformation('—')  =  '0000000F'
* P.S. :	SUBSTR(TRANSFORM(15, '@0'), 3)  =  '0000000F'
*			EVALUATE('0x0000000F')  =  15
LPARAMETERS tcDriveName
LOCAL lnSerialNumber AS Integer, lcDriveName AS String
	IF !THIS.isLoaded("GetVolumeInformation")
		DECLARE INTEGER GetVolumeInformation IN WIN32API;
			STRING, STRING, INTEGER, INTEGER @, INTEGER, INTEGER, STRING
	ENDIF
	* œŒÀ”◊»Ã 10-–»◊Õ€… —≈–»…Õ€… ÕŒÃ≈– (¬Œ«ÃŒ∆ÕŒ Œ“–»÷¿“≈À‹Õ€…)
	lnSerialNumber = 0
	lcDriveName = LEFT(LTRIM(m.tcDriveName), 1) + ':\'
	GetVolumeInformation(m.lcDriveName, 0, 0, @lnSerialNumber, 0, 0, 0)
	*  ŒÕ¬≈–“»–”≈Ã ¬ 16-–»◊Õ€… ‘Œ–Ã¿“
RETURN THIS.Parent.oFunction.decToHex(m.lnSerialNumber)

* ¬¿–»¿Õ“ ◊≈–≈« FSO
* LPARAMETERS tcDriveName
* LOCAL loFileSytem, loDrive
* tcDriveName  =  IIF(VARTYPE(tcDriveName) # 'C', 'C:', LEFT(LTRIM(tcDriveName), 1) + ':')
* loFileSytem  =  CreateObject("Scripting.FileSystemObject")
* loDrive  =  loFileSytem.GetDrive(loFileSytem.GetDriveName(loFileSytem.GetAbsolutePathName(tcDriveName)))
* RETURN RIGHT(TRANSFORM(loDrive.SerialNumber, "@0"), 8)

* ¬¿–»¿Õ“ WMI
* lcComputer  =  "."
* loWMIService  =  GetObject("winmgmts:" ;
* + "{impersonationLevel = impersonate}!\\" + lcComputer + "\root\cimv2")
* colDisks  =  loWMIService.ExecQuery ;
* ("Select * from Win32_LogicalDisk")
* For each loDisk in colDisks
* ?"Compressed: " + chr(9) +  TRANSFORM(loDisk.Compressed)
* ?"Description: " + chr(9) +  loDisk.Description
* ?"DeviceID: " + chr(9) +  loDisk.DeviceID
* ?"DriveType: " + chr(9) +  TRANSFORM(loDisk.DriveType)
* ?"FileSystem: " + chr(9) +  loDisk.FileSystem
* ?"FreeSpace: " + chr(9) +  loDisk.FreeSpace
* * ?"MediaType: " + chr(9) +  TRANSFORM(loDisk.MediaType)
* ?"Name: " + chr(9) +  loDisk.Name
* * ?"QuotasDisabled: " + chr(9) +  loDisk.QuotasDisabled
* ?"QuotasIncomplete: " + chr(9) +  loDisk.QuotasIncomplete
* ?"QuotasRebuilding: " + chr(9) +  loDisk.QuotasRebuilding
* ?"Size: " + chr(9) +  loDisk.Size
* ?"SupportsDiskQuotas: " + chr(9) + ;
* TRANSFORM(loDisk.SupportsDiskQuotas)
* ?"SupportsFileBasedCompression: " + chr(9) + ;
* TRANSFORM(loDisk.SupportsFileBasedCompression)
* ?"SystemName: " + chr(9) +  loDisk.SystemName
* ?"VolumeDirty: " + chr(9) +  TRANSFORM(loDisk.VolumeDirty)
* ?"VolumeName: " + chr(9) +  loDisk.VolumeName
* ?"VolumeSerialNumber: " + chr(9) +  ;
* loDisk.VolumeSerialNumber
* Next

* ¬¿–»¿Õ“ WINAPI
* FUNCTION GetVolumeSerial(tcDrive)
* IF PCOUNT()  =  0
* 	tcDrive  =  "C:\"
* ELSE
* 	tcDrive  =  STRTRAN(tcDrive, ":\", "") + ":\"
* ENDIF
* LOCAL lcName, lcFSName, lnVolumeSerial, lnFMaxLen, lnFSFlags, lcVolumeSerial,;
* 	lnNameLen, lnFSNameLen
* STORE SPACE(255) TO lcName, lcFSName
* STORE 0 TO lnVolumeSerial, lnFMaxLen, lnFSFlags
* STORE 255 TO lnNameLen, lnFSNameLen
* DECLARE GetVolumeInformation IN win32api STRING, STRING @, INTEGER, INTEGER @,;
* 	INTEGER @, INTEGER @, STRING @, INTEGER
* GetVolumeInformation(tcDrive, @lcName, lnNameLen, @lnVolumeSerial, @lnFMaxLen,;
* 	@lnFSFlags, @lcFSName, lnFSNameLen)
* CLEAR DLLS GetVolumeInformation
* IF EMPTY(lnVolumeSerial)
* 	RETURN ''
* ELSE
* 	IF lnVolumeSerial < 0
* 		lnVolumeSerial  =  4294967296 + lnVolumeSerial
* 	ENDIF
* 		lcVolumeSerial  =  SUBSTR(TRANSFORM(lnVolumeSerial,"@0"), 3)
* 		RETURN lcVolumeSerial
* 	ENDIF
* ENDFUNC
ENDPROC
PROCEDURE getwindow
* RETRIEVES A HANDLE TO A WINDOW THAT HAS THE SPECIFIED RELATIONSHIP (Z ORDER OR OWNER) TO THE SPECIFIED WINDOW
LPARAMETERS tnHWindow AS Integer, tnRelationship AS Integer
LOCAL lnWHandle AS Integer
	IF !THIS.isLoaded("GetWindow")
		DECLARE INTEGER GetWindow IN WIN32API INTEGER, INTEGER
	ENDIF
	* DECLARE INTEGER GetWindowLong IN WIN32API INTEGER, INTEGER
	lnWHandle = GetWindow(m.tnHWindow, m.tnRelationship)
RETURN m.lnWHandle

ENDPROC
PROCEDURE getwindowlong
* RETRIEVES INFORMATION ABOUT THE SPECIFIED WINDOW
LPARAMETERS tnHWnd AS Integer, tnIndex AS Integer
LOCAL lnResult AS String
	IF !THIS.isLoaded("GetWindowLong")
		DECLARE LONG GetWindowLong IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	lnResult=GetWindowLong(m.tnHWnd, m.tnIndex)
RETURN m.lnResult
ENDPROC
PROCEDURE getwindowrect
* RETRIEVES THE DIMENSIONS OF THE BOUNDING RECTANGLE OF THE SPECIFIED WINDOW
*  ŒŒ–ƒ»Õ¿“€ Œ Õ¿ Õ¿ ƒ›— “Œœ≈ (–≈¿À‹Õ€≈ –¿«Ã≈–€ Œ Õ¿, ¿ Õ≈  À»≈Õ“— Œ… ◊¿—“»)
* This.GetWindowRect(o.Hwnd, @lnXUpperLeft, @lnYUpperLeft, @lnXLowerRight, @lnYLowerRight)
* P.S. : –¿«Ã≈–€  À»≈Õ“— Œ… ◊¿—“» ÃŒ∆ÕŒ œŒÀ”◊»“‹ ◊≈–≈« GetClientRect()
LPARAMETERS tnWindowHandle AS Integer,;
	vnXUpperLeft AS Integer, vnYUpperLeft AS Integer,;
	vnXLowerRight AS Integer, vnYLowerRight AS Integer
LOCAL lcString AS String
	IF !THIS.isLoaded("GetWindowRect")
		DECLARE SHORT GetWindowRect IN WIN32API INTEGER, STRING @
	ENDIF
	*
	lcString=SPACE(16) 
	GetWindowRect(m.tnWindowHandle, @lcString) 
	*
	vnXUpperLeft=CTOBIN(LEFT(m.lcString, 4), "4RS")
	vnYUpperLeft=CTOBIN(SUBSTR(m.lcString, 5, 4), "4RS")
	vnXLowerRight=CTOBIN(SUBSTR(m.lcString, 9, 4), "4RS")
	vnYLowerRight=CTOBIN(RIGHT(m.lcString, 4), "4RS")

ENDPROC
PROCEDURE getwindowsdirectory
* ¬Œ«¬–¿Ÿ¿≈“  Œ–Õ≈¬Œ…  ¿“¿ÀŒ√ WINDOWS, Õ¿œ–»Ã≈– 'C:\WINDOWS\'
LOCAL lcPath as String, lnSize as Integer
	IF !THIS.isLoaded("GetWindowsDirectory")
		DECLARE INTEGER GetWindowsDirectory IN WIN32API STRING, INTEGER
	ENDIF

	lcPath = SPACE(512)
	lnSize = GetWindowsDirectory(@lcPath, 512)
RETURN LEFT(m.lcPath, m.lnSize) + '\'
ENDPROC
PROCEDURE globalmemorystatus
* »Õ‘Œ–Ã¿÷»ﬂ Œ œ¿Ãﬂ“»
* 1 - œ–Œ÷≈Õ“ »—œŒÀ‹«Œ¬¿ÕÕŒ… œ¿Ãﬂ“»
* 2	- –¿«Ã≈– ‘»«»◊≈— Œ… œ¿Ãﬂ“» ¬ ¡¿…“¿’
* 3	- —¬Œ¡ŒƒÕ¿ﬂ ‘»«»◊≈— ¿ﬂ œ¿Ãﬂ“‹ ¬ ¡¿…“¿’ (—Ã. SYS(3050,1,THISVALUE))
* 4	- –¿«Ã≈– ‘¿…À¿ œŒƒ ¿◊ » ¬ ¡¿…“¿’
* 5	- —¬Œ¡ŒƒÕ€’ ¡¿…“ ¬ ‘¿…À≈ œŒƒ ¿◊ »
* 6 - ¬»–“”¿À‹Õ¿ﬂ œ¿Ãﬂ“‹, »—œŒÀ‹«”≈Ã¿ﬂ œ–Œ÷≈——ŒÃ
* 7 - —¬Œ¡ŒƒÕ¿ﬂ ¬»–“”¿À‹Õ¿ﬂ œ¿Ãﬂ“‹
LPARAMETERS tnWhatInfo as Integer
LOCAL lcRamStatus as String
	tnWhatInfo=IIF(VARTYPE(m.tnWhatInfo)<>'N', 2, m.tnWhatInfo)
	*
	IF !THIS.isLoaded("GlobalMemoryStatus")
		DECLARE GlobalMemoryStatus IN WIN32API STRING @lcRamStatus
	ENDIF
	*
	lcRamStatus=REPLICATE(CHR(0), 32)
	GlobalMemoryStatus(@lcRamStatus)
	*
	DO CASE
	CASE m.tnWhatInfo=1
		* œ–Œ÷≈Õ“ »—œŒÀ‹«Œ¬¿ÕÕŒ… œ¿Ãﬂ“»
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 5, 4), '4RS')
	CASE m.tnWhatInfo=2
		* –¿«Ã≈– ‘»«»◊≈— Œ… œ¿Ãﬂ“» ¬ ¡¿…“¿’
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 9, 4), '4RS')
	CASE m.tnWhatInfo=3
		* —¬Œ¡ŒƒÕ¿ﬂ ‘»«»◊≈— ¿ﬂ œ¿Ãﬂ“‹ ¬ ¡¿…“¿’
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 13, 4), '4RS')
	CASE m.tnWhatInfo=4
		* –¿«Ã≈– ‘¿…À¿ œŒƒ ¿◊ » ¬ ¡¿…“¿’
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 17, 4), '4RS')
	CASE m.tnWhatInfo=5
		* —¬Œ¡ŒƒÕŒ ¬»–“”¿À‹ÕŒ… œ¿Ãﬂ“»
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 21, 4), '4RS')
	CASE m.tnWhatInfo=6
		* ¬»–“”¿À‹Õ¿ﬂ œ¿Ãﬂ“‹, »—œŒÀ‹«”≈Ã¿ﬂ œ–Œ÷≈——ŒÃ
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 25, 4), '4RS')
	CASE m.tnWhatInfo=7
		* —¬Œ¡ŒƒÕ¿ﬂ ¬»–“”¿À‹Õ¿ﬂ œ¿Ãﬂ“‹
		RETURN CTOBIN(SUBSTR(m.lcRamStatus, 29, 4), '4RS')
	ENDCASE
RETURN -1
ENDPROC
PROCEDURE hideprocess
* —œ–ﬂ“¿“‹ »À» œŒ ¿«¿“‹ “≈ ”Ÿ»… œ–Œ÷≈—— ¬ —œ»— ≈ «¿ƒ¿◊ œŒ CTRL+ALT+DEL
LPARAMETERS tlShow as Logical
LOCAL lnSuccess AS Integer. lnShow AS Integer
	lnShow=IIF(m.tlShow, 0, 1)
	*
	IF !THIS.isLoaded("GetCurrentProcessId")
		DECLARE INTEGER GetCurrentProcessId	IN WIN32API
	ENDIF
	*
	IF !THIS.isLoaded("RegisterServiceProcess")
		DECLARE INTEGER RegisterServiceProcess IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	lnSuccess=RegisterServiceProcess(GetCurrentProcessId(), m.lnShow)
RETURN m.lnSuccess=1
ENDPROC
PROCEDURE internetgetconnectedstate
* —Œ—“ŒﬂÕ»≈ —Œ≈ƒ»Õ≈Õ»ﬂ — »Õ“≈–Õ≈“ŒÃ
* –≈«”À‹“¿“ ◊»—ÀŒ ¬ ƒ»¿œŒ«ŒÕ≈ 1-127,
* 00 - œŒƒ Àﬁ◊≈Õ»≈ Œ“—”“—“¬”≈“
* 16 - RAS ”—“¿ÕŒ¬À≈Õ
* 32 - –¿¡Œ“¿≈Ã OFFLINE
LOCAL lnFlags AS Integer
	IF !THIS.isLoaded("InternetGetConnectedState")
		DECLARE SHORT InternetGetConnectedState IN WININET LONG @, LONG
	ENDIF
	*
	lnFlags=0
	InternetGetConnectedState(@lnFlags, 0)
RETURN m.lnFlags

*!*	–≈«”À‹“¿“ ÃŒ∆ÕŒ –¿«Œ¡–¿“‹ “¿  :

*!*	?INTERNET_CONNECTION_CONFIGURED = BITAND(lnFlags, INTERNET_CONNECTION_CONFIGURED)
*!*	?INTERNET_CONNECTION_OFFLINE = BITAND(lnFlags, INTERNET_CONNECTION_OFFLINE)
*!*	?INTERNET_RAS_INSTALLED = BITAND(lnFlags, INTERNET_RAS_INSTALLED)
*!*	?INTERNET_CONNECTION_PROXY = BITAND(lnFlags, INTERNET_CONNECTION_PROXY)
*!*	?INTERNET_CONNECTION_LAN = BITAND(lnFlags, INTERNET_CONNECTION_LAN)
*!*	?INTERNET_CONNECTION_MODEM = BITAND(lnFlags, INTERNET_CONNECTION_MODEM)

*!* »À» Õ¿œ–»Ã≈– ƒ≈ƒŒ¬— »Ã —œŒ—Œ¡ŒÃ :

*!*	?lnFlags >= INTERNET_CONNECTION_CONFIGURED
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_CONFIGURED, INTERNET_CONNECTION_CONFIGURED, 0)
*!*	?lnFlags >= INTERNET_CONNECTION_OFFLINE
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_OFFLINE, INTERNET_CONNECTION_OFFLINE, 0)
*!*	?lnFlags >= INTERNET_RAS_INSTALLED
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_RAS_INSTALLED, INTERNET_RAS_INSTALLED, 0)
*!*	?lnFlags >= INTERNET_CONNECTION_MODEM_BUSY
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_MODEM_BUSY, INTERNET_CONNECTION_MODEM_BUSY, 0)
*!*	?lnFlags >= INTERNET_CONNECTION_PROXY
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_PROXY, INTERNET_CONNECTION_PROXY, 0)
*!*	?lnFlags >= INTERNET_CONNECTION_LAN
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_LAN, INTERNET_CONNECTION_LAN, 0)
*!*	?lnFlags >= INTERNET_CONNECTION_MODEM
*!*	lnFlags = lnFlags - IIF(lnFlags >= INTERNET_CONNECTION_MODEM, INTERNET_CONNECTION_MODEM, 0)
*!*	?lnFlags && «‰ÂÒ¸ ‰ÓÎÊÂÌ ÓÒÚ‡Ú¸Òˇ 0 !!!
ENDPROC
PROCEDURE ischild
* THIS FUNCTION TESTS WHETHER A WINDOW IS A CHILD WINDOW
* OR DESCENDANT WINDOW OF A SPECIFIED PARENT WINDOW
* P.S. VFP  ŒÕ“–ŒÀ€ - –»—Œ¬¿ÕÕ€≈ ¡»“Ã¿œ€, ¿ Õ≈ Œ Õ¿, ÕŒ Õ≈ ¬—≈√ƒ¿
* Õ¿œ–»Ã≈– COMBOBOX - –»—”ÕŒ , ¿ ≈√Œ ¬€œ¿ƒ¿ﬁŸ»… —œ»—Œ  - Œ ÕŒ !
* (»Õ¿◊≈ —œ»—Œ  Õ≈¬Œ«ÃŒ∆ÕŒ ¡€ÀŒ ¡€ œŒ ¿«¿“‹ «¿ œ–≈ƒ≈À¿Ã» ‘Œ–Ã€)

LPARAMETERS tnHWndParent AS Integer, tnHWndChild AS Integer
LOCAL lnIsChild AS Integer
	IF !THIS.isLoaded("IsChild")
		DECLARE LONG IsChild IN Win32API LONG, LONG
	ENDIF
	*
	lnIsChild=IsChild(m.tnHWndParent, m.tnHWndChild)
RETURN m.lnIsChild<>0
ENDPROC
PROCEDURE isloaded
LPARAMETERS lcFunctionName as String
LOCAL ARRAY laDeclaredDlls[1,3]
LOCAL lnLen as Integer
	lnLen = ADLLS(m.laDeclaredDlls)
RETURN ASCAN(m.laDeclaredDlls, m.lcFunctionName , 1, m.lnLen , 2, 15) <> 0
ENDPROC
PROCEDURE loadicon
* «¿√–”« ¿ » ŒÕ » (œ¿–¿Ã≈“– —Ã. ¬ WINAPI.H –¿«ƒ≈À ICON)
* –≈«”À‹“¿“ : ”—œ≈ÿÕŒ, ≈—À» lnHandle > 0
* This.LoadIcon(32516) && Information
LPARAMETERS tnIconId AS Integer
LOCAL lnHandle AS Integer
	IF !THIS.isLoaded("LoadIcon")
		DECLARE INTEGER LoadIcon IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	lnHandle=LoadIcon(0, m.tnIconId)
RETURN m.lnHandle
ENDPROC
PROCEDURE loadimage
* «¿√–”∆¿≈“ ‘¿…À » ŒÕ »  ¿  –≈—”–— WINDOWS
* ¬Œ«¬–¿Ÿ¿≈“ RESOURCE HANDLE > 0
*  0	- Œÿ»¡ ¿ œ–» «¿√–”« ≈
* -1	- ‘¿…À Õ≈ Õ¿…ƒ≈Õ
LPARAMETERS tcIconFileName AS String
LOCAL lcTempFile AS String, lnHandle AS Integer
	lnHandle=-1
	*
	IF !THIS.isLoaded("LoadImage")
		DECLARE INTEGER LoadImage IN WIN32API;
				INTEGER, STRING, INTEGER, INTEGER, INTEGER, INTEGER
	ENDIF
	*
	lcTempFile=This.TempFile()
	COPY FILE (m.tcIconFileName) TO (m.lcTempFile)
	lnHandle=LoadImage(0, m.lcTempFile, 1, 0, 0, 0x0010)
	ERASE (m.lcTempFile)
RETURN m.lnHandle
ENDPROC
PROCEDURE loadkeyboardlayout
* «¿√–”« ¿  À¿¬»¿“”–ÕŒ… –¿— À¿ƒ » ('00000409'-English '00000419'-RUSSIAN)
* This.LoadKeyboardLayout(LANGID_RUS)
* This.LoadKeyboardLayout(LANGID_ENG)
LPARAMETERS tcLayout AS String
	IF !THIS.isLoaded("LoadKeyboardLayout")
		DECLARE INTEGER LoadKeyboardLayout IN WIN32API STRING, INTEGER
	ENDIF
	*
	LoadKeyboardLayout(tcLayout, KLF_ACTIVATE)

* DECLARE INTEGER GetKeyboardLayout IN win32api INTEGER
* ?GetKeyboardLayout(0)    && ƒ‡ÒÚ ÚÂÍÛ˘Û˛ ‡ÒÍÎ‡‰ÍÛ

*!*	DECLARE GetKeyboardLayoutName IN WIN32API STRING
*!*	DECLARE ActivateKeyboardLayout IN WIN32API INTEGER, INTEGER
*!*	LOCAL lcString
*!*	lcString = SPACE(8)
*!*	GetKeyboardLayoutName(@lcString)
*!*	MESSAGEBOX(lcString)
*!*	IF lcString # '00000409' && 409-Eng 419-Rus
*!*		ActivateKeyboardLayout(1,0)
*!*	ENDIF
*!* CLEAR DLLS 'GetKeyboardLayoutName', 'ActivateKeyboardLayout'

*!*	FUNCTION RusLatKey						&& œÂÂÍÎ˛˜ÂÌËÂ ‡ÒÍÎ‡‰ÍË ÍÎ‡‚Ë‡ÚÛ˚ RUS/LAT
*!*	LPARAMETERS tlRus						&& ¬¿–»¿Õ“ 1
*!*	ASSERT VARTYPE(tlRus) = 'L'
*!*	LOCAL lnRetVal
*!*	* DECLARE LONG ActivateKeyboardLayout IN WIN32API;
*!*			INTEGER	nHandleToKeyboardLayout,;
*!*			INTEGER	nKeyboardLayoutFlags
*!*	DECLARE LONG ActivateKeyboardLayout IN WIN32API INTEGER, INTEGER
*!*	lnRetVal=ActivateKeyboardLayout(IIF(tlRus,68748313,67699721),0)
*!*	CLEAR DLLS 'ActivateKeyboardLayout'
*!*	RETURN lnRetVal	= 67699721				&& 67699721


*!*	FUNCTION LatRusKey						&& œÂÂÍÎ˛˜ÂÌËÂ ‡ÒÍÎ‡‰ÍË ÍÎ‡‚Ë‡ÚÛ˚ RUS/LAT
*!*	LPARAMETERS tlRus						&& ¬¿–»¿Õ“ 2
*!*	ASSERT VARTYPE(tlRus) = 'L'
*!*	LOCAL lnRetVal
*!*	DECLARE LONG LoadKeyboardLayout IN WIN32API;
*!*			STRING pwszKLID,;
*!*			INTEGER nKeyboardLayoutFlags
*!*	lnRetVal = LoadKeyboardLayout(IIF(tlRus,'00000419','00000409'),1)
*!*	CLEAR DLLS 'LoadKeyboardLayout'
*!*	RETURN lnRetVal	= 68748313				&& 68748313

*!*	//  Primary language IDs.
*!*	#define LANG_NEUTRAL                     0x00
*!*	#define LANG_AFRIKAANS                   0x36
*!*	#define LANG_ALBANIAN                    0x1c
*!*	#define LANG_ARABIC                      0x01
*!*	#define LANG_ARMENIAN                    0x2b
*!*	#define LANG_ASSAMESE                    0x4d
*!*	#define LANG_AZERI                       0x2c
*!*	#define LANG_BASQUE                      0x2d
*!*	#define LANG_BELARUSIAN                  0x23
*!*	#define LANG_BENGALI                     0x45
*!*	#define LANG_BULGARIAN                   0x02
*!*	#define LANG_CATALAN                     0x03
*!*	#define LANG_CHINESE                     0x04
*!*	#define LANG_CROATIAN                    0x1a
*!*	#define LANG_CZECH                       0x05
*!*	#define LANG_DANISH                      0x06
*!*	#define LANG_DUTCH                       0x13
*!*	#define LANG_ENGLISH                     0x09
*!*	#define LANG_ESTONIAN                    0x25
*!*	#define LANG_FAEROESE                    0x38
*!*	#define LANG_FARSI                       0x29
*!*	#define LANG_FINNISH                     0x0b
*!*	#define LANG_FRENCH                      0x0c
*!*	#define LANG_GEORGIAN                    0x37
*!*	#define LANG_GERMAN                      0x07
*!*	#define LANG_GREEK                       0x08
*!*	#define LANG_GUJARATI                    0x47
*!*	#define LANG_HEBREW                      0x0d
*!*	#define LANG_HINDI                       0x39
*!*	#define LANG_HUNGARIAN                   0x0e
*!*	#define LANG_ICELANDIC                   0x0f
*!*	#define LANG_INDONESIAN                  0x21
*!*	#define LANG_ITALIAN                     0x10
*!*	#define LANG_JAPANESE                    0x11
*!*	#define LANG_KANNADA                     0x4b
*!*	#define LANG_KASHMIRI                    0x60
*!*	#define LANG_KAZAK                       0x3f
*!*	#define LANG_KONKANI                     0x57
*!*	#define LANG_KOREAN                      0x12
*!*	#define LANG_LATVIAN                     0x26
*!*	#define LANG_LITHUANIAN                  0x27
*!*	#define LANG_MACEDONIAN                  0x2f
*!*	#define LANG_MALAY                       0x3e
*!*	#define LANG_MALAYALAM                   0x4c
*!*	#define LANG_MANIPURI                    0x58
*!*	#define LANG_MARATHI                     0x4e
*!*	#define LANG_NEPALI                      0x61
*!*	#define LANG_NORWEGIAN                   0x14
*!*	#define LANG_ORIYA                       0x48
*!*	#define LANG_POLISH                      0x15
*!*	#define LANG_PORTUGUESE                  0x16
*!*	#define LANG_PUNJABI                     0x46
*!*	#define LANG_ROMANIAN                    0x18
*!*	#define LANG_RUSSIAN                     0x19
*!*	#define LANG_SANSKRIT                    0x4f
*!*	#define LANG_SERBIAN                     0x1a
*!*	#define LANG_SINDHI                      0x59
*!*	#define LANG_SLOVAK                      0x1b
*!*	#define LANG_SLOVENIAN                   0x24
*!*	#define LANG_SPANISH                     0x0a
*!*	#define LANG_SWAHILI                     0x41
*!*	#define LANG_SWEDISH                     0x1d
*!*	#define LANG_TAMIL                       0x49
*!*	#define LANG_TATAR                       0x44
*!*	#define LANG_TELUGU                      0x4a
*!*	#define LANG_THAI                        0x1e
*!*	#define LANG_TURKISH                     0x1f
*!*	#define LANG_UKRAINIAN                   0x22
*!*	#define LANG_URDU                        0x20
*!*	#define LANG_UZBEK                       0x43
*!*	#define LANG_VIETNAMESE                  0x2a

*!*	Identifier Predefined symbol Language 
*!*	0x00 LANG_NEUTRAL Neutral 
*!*	0x01 LANG_ARABIC Arabic 
*!*	0x02 LANG_BULGARIAN Bulgarian 
*!*	0x03 LANG_CATALAN Catalan  
*!*	0x04 LANG_CHINESE Chinese 
*!*	0x05 LANG_CZECH Czech 
*!*	0x06 LANG_DANISH Danish 
*!*	0x07 LANG_GERMAN German 
*!*	0x08 LANG_GREEK Greek 
*!*	0x09 LANG_ENGLISH English  
*!*	0x0a LANG_SPANISH Spanish  
*!*	0x0b LANG_FINNISH Finnish 
*!*	0x0c LANG_FRENCH French 
*!*	0x0d LANG_HEBREW Hebrew 
*!*	0x0e LANG_HUNGARIAN Hungarian 
*!*	0x0f LANG_ICELANDIC Icelandic 
*!*	0x10 LANG_ITALIAN Italian  
*!*	0x11 LANG_JAPANESE Japanese 
*!*	0x12 LANG_KOREAN Korean 
*!*	0x13 LANG_DUTCH Dutch 
*!*	0x14 LANG_NORWEGIAN Norwegian 
*!*	0x15 LANG_POLISH Polish 
*!*	0x16 LANG_PORTUGUESE Portuguese 
*!*	0x18 LANG_ROMANIAN Romanian 
*!*	0x19 LANG_RUSSIAN Russian 
*!*	0x1a LANG_CROATIAN Croatian 
*!*	0x1a LANG_SERBIAN Serbian 
*!*	0x1b LANG_SLOVAK Slovak 
*!*	0x1c LANG_ALBANIAN Albanian 
*!*	0x1d LANG_SWEDISH Swedish  
*!*	0x1e LANG_THAI Thai 
*!*	0x1f LANG_TURKISH Turkish  
*!*	0x20 LANG_URDU Urdu 
*!*	0x21 LANG_INDONESIAN Indonesian 
*!*	0x22 LANG_UKRAINIAN Ukrainian 
*!*	0x23 LANG_BELARUSIAN Belarusian 
*!*	0x24 LANG_SLOVENIAN Slovenian 
*!*	0x25 LANG_ESTONIAN Estonian 
*!*	0x26 LANG_LATVIAN Latvian 
*!*	0x27 LANG_LITHUANIAN Lithuanian 
*!*	0x29 LANG_FARSI Farsi 
*!*	0x2a LANG_VIETNAMESE Vietnamese 
*!*	0x2b LANG_ARMENIAN Armenian 
*!*	0x2c LANG_AZERI Azeri 
*!*	0x2d LANG_BASQUE Basque 
*!*	0x2f LANG_MACEDONIAN FYRO Macedonian 
*!*	0x36 LANG_AFRIKAANS Afrikaans 
*!*	0x37 LANG_GEORGIAN Georgian 
*!*	0x38 LANG_FAEROESE Faeroese 
*!*	0x39 LANG_HINDI Hindi 
*!*	0x3e LANG_MALAY Malay 
*!*	0x3f LANG_KAZAK Kazak 
*!*	0x40 LANG_KYRGYZ Kyrgyz 
*!*	0x41 LANG_SWAHILI Swahili 
*!*	0x43 LANG_UZBEK Uzbek 
*!*	0x44 LANG_TATAR Tatar 
*!*	0x45 LANG_BENGALI Not supported. 
*!*	0x46 LANG_PUNJABI Punjabi 
*!*	0x47 LANG_GUJARATI Gujarati 
*!*	0x48 LANG_ORIYA Not supported. 
*!*	0x49 LANG_TAMIL Tamil 
*!*	0x4a LANG_TELUGU Telugu 
*!*	0x4b LANG_KANNADA Kannada 
*!*	0x4c LANG_MALAYALAM Not supported. 
*!*	0x4d LANG_ASSAMESE Not supported. 
*!*	0x4e LANG_MARATHI Marathi 
*!*	0x4f LANG_SANSKRIT Sanskrit 
*!*	0x50 LANG_MONGOLIAN Mongolian 
*!*	0x56 LANG_GALICIAN Galician 
*!*	0x57 LANG_KONKANI Konkani 
*!*	0x58 LANG_MANIPURI Not supported. 
*!*	0x59 LANG_SINDHI Not supported. 
*!*	0x5a LANG_SYRIAC Syriac 
*!*	0x60 LANG_KASHMIRI Not supported. 
*!*	0x61 LANG_NEPALI Not supported. 
*!*	0x65 LANG_DIVEHI Divehi 
*!*	0x7f LANG_INVARIANT   

ENDPROC
PROCEDURE loadlibrary
* «¿√–”« ¿ ACTIVEX OCX  ==  DLL ¡»¡À»Œ“≈ »
* œ¿–¿Ã≈“– : œ”“‹ » »Ãﬂ OCX ‘¿…À¿
* –≈«”À‹“¿“ : ’›ÕƒÀ «¿√–”∆≈ÕÕŒ… ¡»¡À»Œ“≈ » »À» 0
* —Ã. This.RegSvr32()
LPARAMETERS tcOcxFileName AS String
LOCAL lnHandle AS Integer
	IF !THIS.isLoaded("LoadLibrary")
		DECLARE INTEGER LoadLibrary IN WIN32API STRING
	ENDIF

	lnHandle = LoadLibrary(m.tcOcxFileName)
RETURN m.lnHandle

ENDPROC
PROCEDURE loadlibraryex
* «¿√–”« ¿ ACTIVEX OCX  =  =  DLL ¡»¡À»Œ“≈ »
* œ¿–¿Ã≈“– : œ”“‹ » »Ãﬂ OCX ‘¿…À¿
* –≈«”À‹“¿“ : ’›ÕƒÀ «¿√–”∆≈ÕÕŒ… ¡»¡À»Œ“≈ » »À» 0
* —Ã. This.RegSvr32()
LPARAMETERS tcOcxFileName AS String
LOCAL lnHandle AS Integer
	IF !THIS.isLoaded("LoadLibrary")
		DECLARE INTEGER LoadLibraryEx IN WIN32API;
				String @ lpFileName, ;				&& file name of module
				Integer hFile, ;					&& reserved, must be NULL
				Integer dwFlags						&& entry-point execution option
	ENDIF

	lnHandle = LoadLibrary(m.tcOcxFileName, NULL, )
RETURN m.lnHandle

ENDPROC
PROCEDURE localerrormessage
* ÀŒ ¿À»«Œ¬¿ÕÕ¿ﬂ —“–Œ ¿ —ŒŒ¡Ÿ≈Õ»ﬂ Œ¡ Œÿ»¡ ≈ œŒ ≈≈ ÕŒÃ≈–” »À» œ”—“¿ﬂ —“–Œ ¿
* œ–»Ã≈–1 :	This.LocalErrorMessage('ShellExecute', 0) =
* 			'Œ¯Ë·Í‡ ÔË ‚˚ÔÓÎÌÂÌËË SHELLEXECUTE' + CHR_CR +;
*			'ÕÂ‰ÓÒÚ‡ÚÓ˜ÌÓ Ô‡ÏˇÚË ËÎË ÂÒÛÒÓ‚'
* œ–»Ã≈–2 :	This.LocalErrorMessage('WinExec', 32) = ''
LPARAMETERS tcProcName AS String, tnError AS Integer
LOCAL ARRAY laError[1]
LOCAL lcProcName AS String, lcMessage AS String
	lcProcName=UPPER(ALLTRIM(m.tcProcName))
	lcMessage='ÕÂËÁ‚ÂÒÚÌ‡ˇ Ó¯Ë·Í‡ No '+TRANSFORM(m.tnError)
	*
	DO CASE
	CASE m.lcProcName='SHELLEXECUTE'
		DO CASE
		CASE m.tnError>32
			RETURN ''					&& No error ocurred
		CASE BETWEEN(m.tnError, 0, 32)	&& Error range 0-32
			DIMENSION laError[33]		&& Array range 1-33
			laError[01]='ÕÂ‰ÓÒÚ‡ÚÓ˜ÌÓ Ô‡ÏˇÚË ËÎË ÂÒÛÒÓ‚'					&& The system is out of memory or resources
			laError[03]='—ÓÓÚ‚ÂÚÒÚ‚Û˛˘ËÈ Ù‡ÈÎ ÌÂ Ì‡È‰ÂÌ'						&& The specified file was not found
			laError[04]='—ÓÓÚ‚ÂÚÒÚ‚Û˛˘ËÈ Í‡Ú‡ÎÓ„ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ'				&& The specified path was not found
			laError[06]='ƒÓÒÚÛÔ Í ÒÓÓÚ‚ÂÚÒÚ‚Û˛˘ÂÏÛ Ù‡ÈÎÛ Á‡ÔÂ˘ÂÌ'			&& The operating system denied access to the specified file
			laError[09]='ÕÂ‰ÓÒÚ‡ÚÓ˜ÌÓ Ô‡ÏˇÚË ‰Îˇ Á‡‚Â¯ÂÌËˇ ÓÔÂ‡ˆËË'			&& There was not enough memory to complete the operation
			laError[12]='ÕÂ‚ÂÌ˚È ÙÓÏ‡Ú .exe Ù‡ÈÎ‡'							&& The .exe file is invalid (non-Win32Æ .exe or error in .exe image)
			laError[27]=' ÓÌÙÎËÍÚ Ó‰ÌÓ‚ÂÏÂÌÌÓ„Ó ‰ÓÒÚÛÔ‡'						&& A sharing violation occurred
			laError[28]='ÕÂ‚ÂÌ‡ˇ ‡ÒÒÓˆË‡ˆËˇ ‰Îˇ ˝ÚÓ„Ó ÚËÔ‡ Ù‡ÈÎÓ‚'			&& The file name association is incomplete or invalid
			laError[29]='«‡ÔÓ¯ÂÌÌÓÂ ‰Îˇ Á‡ÔÛÒÍ‡ ‚ÂÏˇ ËÒÚÂÍÎÓ'				&& The DDE transaction could not be completed because the request timed out
			laError[30]='ÕÂ Û‰‡ÎÓÒ¸ Á‡ÔÛÒÚËÚ¸ ÒÓÓÚ‚ÂÚÒÚ‚Û˛˘Û˛ ÔÓ„‡ÏÏÛ'		&& The DDE transaction failed
			laError[31]='—ÓÓÚ‚ÂÚÒÚ‚Û˛˘‡ˇ ÔÓ„‡ÏÏ‡ ÒÂÈ˜‡Ò ÌÂ‰ÓÒÚÛÔÌ‡'			&& The DDE transaction could not be completed because other DDE transactions were being processed
			laError[32]='—ÓÓÚ‚ÂÚÒÚ‚Û˛˘‡ˇ ÔÓ„‡ÏÏ‡ ÌÂ ÛÒÚ‡ÌÓ‚ÎÂÌ‡'			&& There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable
			laError[33]='—ÓÓÚ‚ÂÚÒÚ‚Û˛˘‡ˇ ‰ËÌ‡ÏË˜ÂÒÍ‡ˇ ·Ë·ÎËÓÚÂÍ‡ ÌÂ Ì‡È‰ÂÌ‡'	&& The specified dynamic-link library was not found
			*
			IF VARTYPE(laError[m.tnError+1])='C'
				lcMessage=laError[m.tnError+1]
			ENDIF
		ENDCASE
	CASE m.lcProcName='WINEXEC'
		DO CASE
		CASE m.tnError>31
			RETURN ''					&& No error ocurred
		CASE BETWEEN(m.tnError, 0, 31)	&& Error range 0-31
			DIMENSION laError[32]		&& Array range 1-32
			laError[01]='ÕÂ‰ÓÒÚ‡ÚÓ˜ÌÓ Ô‡ÏˇÚË ËÎË ÂÒÛÒÓ‚'					&& The system is out of memory or resources
			laError[03]='—ÓÓÚ‚ÂÚÒÚ‚Û˛˘ËÈ Ù‡ÈÎ ÌÂ Ì‡È‰ÂÌ'						&& The specified file was not found
			laError[04]='—ÓÓÚ‚ÂÚÒÚ‚Û˛˘ËÈ Í‡Ú‡ÎÓ„ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ'				&& The specified path was not found
			laError[12]='ÕÂ‚ÂÌ˚È ÙÓÏ‡Ú .exe Ù‡ÈÎ‡'							&& The .exe file is invalid (non-Win32Æ .exe or error in .exe image)
			IF VARTYPE(laError[m.tnError+1])='C'
				lcMessage=laError[m.tnError+1]
			ENDIF
		ENDCASE
	ENDCASE
RETURN 'Œ¯Ë·Í‡ ÔË ‚˚ÔÓÎÌÂÌËË '+m.lcProcName+CHR_CR+m.lcMessage
ENDPROC
PROCEDURE mcisendstring
* ¬€œŒÀÕ≈Õ»≈ MCI  ŒÃ¿Õƒ
* –≈«”À‹“¿“ - —“–Œ ¿ — Œÿ»¡ Œ… »À» œ”—“Œ ≈—À» ¬—≈ OK
* –¿¡Œ“¿ — AVI-‘¿…ÀŒÃ :
* Œ“ –€“‹ AVI ‘¿…À — ¿À»¿—ŒÃ Animation ¬ Œ Õ≈ — œ¿–¿Ã≈“–¿Ã» 12345
* tcCommand = 'open c:\foxrain.avi type AVIVideo alias Animation parent '+TRANSFORM(ThisForm.HWnd) + ' style ' + TRANSFORM(12345)
* œ≈–≈Ã≈—“»“‹ » »«Ã≈Õ»“‹ –¿«Ã≈–€ Œ Õ¿
* tcCommand = 'put Animation window at 10 10 200 200'
* œ–Œ»√–¿“‹ AVI ‘¿…À, œ–»◊≈Ã WAIT - ƒŒ∆ƒ¿“‹—ﬂ ¬€œŒÀÕ≈Õ»ﬂ  ŒÃ¿Õƒ€
* tcCommand = 'play Animation wait'
* «¿ –€“‹ AVI
* tcCommand = 'close Animation'
* œ–Œ»√–€¬¿Õ»≈ CD-AUDIO
* OPENDOOR 
* tcCommand = 'set cdaudio door open wait'
* CLOSEDOOR 
* tcCommand = 'set cdaudio door closed wait'
* OPENDEVICE 
* tcCommand = 'open cdaudio shareable'
* CLOSEDEVICE 
* tcCommand = 'stop cdaudio wait'
* tcCommand = 'close cdaudio'
LPARAMETERS tcCommand AS String
LOCAL lcReturn AS String, lnError AS Integer, lcError AS String, lcBuffer  AS String
	STORE SPACE(250) TO lcReturn, lcError 
	*
	IF !THIS.isLoaded("mciSendString")
		DECLARE INTEGER mciSendString IN WINMM.DLL STRING, STRING @, INTEGER, INTEGER
	ENDIF
	*
	lnError=mciSendString(m.tcCommand, @lcReturn, LEN(m.lcReturn), 0)
	IF m.lnError=0
		lcError=''
	ELSE
		IF !THIS.isLoaded("mciGetErrorString")
			DECLARE INTEGER mciGetErrorString IN WINMM.DLL INTEGER, STRING @, INTEGER
		ENDIF
		*
	    lcError=REPLICATE(CHR(0), 250) 
	    mciGetErrorString(m.lnError, @lcError, LEN(m.lcError))
		lcError=SUBSTR(m.lcError, 1, AT(CHR(0), m.lcError)-1)
	ENDIF
RETURN m.lcError
ENDPROC
PROCEDURE messagebeep
* –¿«ÕŒ≈ ¡»¡» ¿Õ‹≈, œ¿–¿Ã≈“– - —Ã. –¿«ƒ≈À MESSAGEBEEP ¬ WINAPI.H » THIS.BEEP()
* œ–»Ã≈– : THIS.MESSAGEBEEP(-1)
LPARAMETERS tnBeepType AS Integer
LOCAL lnSuccess AS Integer
	tnBeepType=IIF(VARTYPE(m.tnBeepType)='N', m.tnBeepType, MB_SIMPLEBEEP)
	*
	IF !THIS.isLoaded("MessageBeep")
		DECLARE INTEGER MessageBeep IN WIN32API INTEGER
	ENDIF
	*
	lnSuccess=MessageBeep(m.tnBeepType)
RETURN m.lnSuccess<>0

ENDPROC
PROCEDURE netmessagebuffersend
* œŒ—€À ¿ —ŒŒ¡Ÿ≈Õ»ﬂ œŒ —≈“», –≈«”À‹“¿“ - ”—œ≈’ ¬€œŒÀÕ≈Õ»ﬂ
* ”ƒŒ¡ÕŒ ƒÀﬂ œŒÀ”◊≈Õ»ﬂ —ŒŒ¡Ÿ≈Õ»… Œ“ ÃŒÀ◊¿À»¬€’ —≈–¬≈–Õ€’ œ–»ÀŒ∆≈Õ»…
* Õ≈ –¿¡Œ“¿≈“ œŒƒ WIN9X/ME, “ŒÀ‹ Œ œŒƒ WNT/2K/XP, œ–»◊≈Ã ƒŒÀ∆≈Õ ¡€“‹ «¿œ”Ÿ≈Õ —≈–¬»— MESSENGER
* Õ¿œ–»Ã≈– : ¿Õ¿ÀŒ√ŒÃ  ŒÃ¿Õƒ€ net send ek ÚÂÍÒÚ ÒÓÓ·˘ÂÌËˇ
* ¡”ƒ≈“ : This.NetMessageBufferSend('ÚÂÍÒÚ ÒÓÓ·˘ÂÌËˇ', 'ek', '¬‡Òˇ œÛÔÍËÌ')
* œŒ—À¿“‹ —ŒŒ¡Ÿ≈Õ»≈ —¿ÃŒÃ” —≈¡≈ ÃŒ∆ÕŒ “¿  :
* This.NetMessageBufferSend('Error report')
LPARAMETERS tcMessage AS String, tcToName AS String, tcFromName AS String, tcServerName AS String
LOCAL lnResult AS Integer	&& tcServerName - ‚ÓÁÏÓÊÌÓ ËÏˇ ÒÂ‚Â‡ ÔÓÒÂ‰ÌËÍ‡ ‰Îˇ WNT4.0
	* œ≈–≈¬≈ƒ≈Ã ¬ UNICODE
	tcMessage=STRCONV(m.tcMessage+CHR(0), 5)
	tcServerName=IIF(VARTYPE(m.tcServerName)='C', STRCONV(m.tcServerName+CHR(0), 5), .NULL.)
	tcToName=STRCONV(IIF(VARTYPE(m.tcToName)='C', m.tcToName, RTRIM(LEFT(SYS(0), AT('#', SYS(0)) - 1))) + CHR(0), 5)
	tcFromName=IIF(VARTYPE(m.tcFromName)='C', STRCONV(m.tcFromName+CHR(0), 5), .NULL.)
	*
	IF !THIS.isLoaded("NetMessageBufferSend")
		DECLARE LONG NetMessageBufferSend IN NETAPI32.DLL STRING @, STRING @, STRING @, STRING @, LONG
	ENDIF
	*
	lnResult=NetMessageBufferSend(@tcServerName, @tcToName, @tcFromName, @tcMessage, LEN(m.tcMessage))
RETURN m.lnResult=0
ENDPROC
PROCEDURE openfile
* Œ“ –€“‹ ‘¿…À » ¬≈–Õ”“‹ ’›ÕƒÀ
LPARAMETERS tcFileName AS String
LOCAL lcBuffer AS String, lnHandle AS Integer
	IF !THIS.isLoaded("OpenFile")
		DECLARE INTEGER OpenFile IN WIN32API STRING, STRING @, INTEGER
	ENDIF
	*
	lcBuffer=REPLICATE(CHR(0), 250)
	lnHandle=OpenFile(m.tcFileName, @lcBuffer, 1)
RETURN m.lnHandle
ENDPROC
PROCEDURE opensemaphore
* Œ“ –€“»≈ —≈Ã¿‘Œ–¿ — ”Õ» ¿À‹Õ€Ã »ƒ≈Õ“»‘» ¿“Œ–ŒÃ = TCUNIQUE
* –≈«”À‹“¿“ - Õ≈Õ”À≈¬Œ… ” ¿«¿“≈À‹ Õ¿ —”Ÿ≈—“¬”ﬁŸ»… —≈Ã¿‘Œ– »À» 0,
* ≈—À» “¿ Œ√Œ —≈Ã¿‘Œ–¿ Õ≈ —”Ÿ≈—“¬”≈“
LPARAMETERS tcUnique AS String
LOCAL lnHandle AS Integer
	* TCUNIQUE IS LIMITED TO MAX_PATH CHARACTERS AND CAN CONTAIN ANY
	* CHARACTER EXCEPT THE BACKSLASH PATH-SEPARATOR CHARACTER (\)
	* NAME COMPARISON IS CASE SENSITIVE
	tcUnique=CHRTRAN(m.tcUnique, '\', '_')
	*
	IF !THIS.isLoaded("OpenSemaphore")
		DECLARE INTEGER OpenSemaphore IN WIN32API INTEGER, INTEGER, STRING
	ENDIF
	*
	lnHandle=OpenSemaphore(STANDARD_RIGHTS_REQUIRED, 0, m.tcUnique)
RETURN m.lnHandle
ENDPROC
PROCEDURE regclosekey
* «¿ –€“‹  Àﬁ◊ –≈≈—“–¿
* –≈«”À‹“¿“ : .T. -  Àﬁ◊ ”—œ≈ÿÕŒ «¿ –€“, .F. - Œÿ»¡ ¿ «¿ –€“»ﬂ  Àﬁ◊¿
LPARAMETERS tnKeyHandle as Integer
LOCAL lnError as Integer
	IF !THIS.isLoaded("RegCloseKey")
		DECLARE INTEGER RegCloseKey IN WIN32API INTEGER
	ENDIF
	*
	lnError=RegCloseKey(m.tnKeyHandle)
RETURN m.lnError=0
ENDPROC
PROCEDURE regcreatekey
* —Œ«ƒ¿“‹  Àﬁ◊ –≈≈—“–¿
* –≈«”À‹“¿“ : ’›ÕƒÀ —Œ«ƒ¿ÕÕŒ√Œ  Àﬁ◊¿ (INTEGER) »À» 0 œ–» Œÿ»¡ ≈
* This.RegCreateKey(HKEY_LOCAL_MACHINE, 'Software\Microsoft\Shared Tools\MSInfo')
LPARAMETERS tnRoot AS Integer, tcPath AS String
LOCAL lnKeyHandle as Integer
	lnKeyHandle=0
	*
	IF !THIS.isLoaded("RegCreateKey")
		DECLARE INTEGER RegCreateKey IN WIN32API INTEGER, STRING, INTEGER @lnKeyHandle
	ENDIF
	*
	RegCreateKey(m.tnRoot, m.tcPath, @lnKeyHandle)
RETURN m.lnKeyHandle
ENDPROC
PROCEDURE regdeletekey
* ”ƒ¿Àﬂ≈“ ¬≈“ ”  Àﬁ◊≈… —Œ ¬—≈Ã» œŒƒ¬≈“ ¿Ã» !
* THE FUNCTION ALSO DELETES ALL SUBKEYS AND VALUES !
* This.RegDeleteKey(REG_HKEY_LOCAL_MACHINE, REG_KEY_WIN9X_CURRENTVERSION + '\Run')
LPARAMETERS tnRoot AS Integer, tcPath AS String
LOCAL lnError AS Integer
	IF !THIS.isLoaded("RegDeleteKey")
		DECLARE INTEGER RegDeleteKey IN WIN32API INTEGER, STRING @
	ENDIF
	*
	lnError=RegDeleteKey(m.tnRoot, @tcPath)
RETURN m.lnError=0
ENDPROC
PROCEDURE regdeletevalue
* ”ƒ¿Àﬂ≈Ã  Àﬁ◊ TCKEY ¬≈“ » TCPATH –¿«ƒ≈À¿ TNROOT
* This.RegDeleteValue(REG_HKEY_LOCAL_MACHINE, REG_KEY_WIN9X_CURRENTVERSION + '\Run', 'My cool program ;)')
* –≈«”À‹“¿“ : .T. -  Àﬁ◊ ”—œ≈ÿÕŒ ”ƒ¿À≈Õ
LPARAMETERS tnRoot AS Integer, tcPath AS String, tcKey AS String
LOCAL lnKeyHandle AS Integer
	lnKeyHandle=This.RegOpenKey(m.tnRoot, m.tcPath)
	*
	IF m.lnKeyHandle>0
		IF !THIS.isLoaded("RegDeleteValue")
			DECLARE INTEGER RegDeleteValue IN WIN32API INTEGER, STRING @
		ENDIF
		*
		lnError=RegDeleteValue(m.lnKeyHandle, @tcKey)
	    This.RegCloseKey(m.lnKeyHandle)
	    *
		RETURN m.lnError=0
	ENDIF
RETURN .F.
ENDPROC
PROCEDURE reggetkey
* œ–Œ◊≈—“‹ —“–Œ Œ¬€… »À» ◊»—ÀŒ¬Œ…  Àﬁ◊ –≈≈—“–¿
* –≈«”À‹“¿“ : —“–Œ ¿ »À» ◊»—ÀŒ —Œ «Õ¿◊≈Õ»≈Ã  Àﬁ◊¿ »À» .F. œ–» Œÿ»¡ ≈
* This.RegGetKey(-2147483646, 'Software\Microsoft\Shared Tools\MSInfo', 'Path')
* This.RegGetKey(-2147483646, 'Hardware\Description\System\CentralProcessor\0', '~MHz')
* REG_HKEY_CLASSES_ROOT = -2147483648
* REG_KEY_BROWSER = 'HTTP\shell\open\ddeexec\Application'
* This.RegGetKey(REG_HKEY_CLASSES_ROOT, REG_KEY_BROWSER) = 'IExplore'
LPARAMETERS tnRoot, tcPath, tcKey
LOCAL lcKey, lnKeyHandle, lnKeyType, lnKeyLength, lcKeyValue, lnError
	lcKey=IIF(VARTYPE(tcKey)<>'C', '', m.tcKey)
	lnKeyHandle=This.RegOpenKey(m.tnRoot, m.tcPath)
	*
	IF m.lnKeyHandle<>0
		IF !THIS.isLoaded("RegQueryValueEx")
			DECLARE INTEGER RegQueryValueEx IN WIN32API INTEGER, STRING, INTEGER, INTEGER @lnKeyType, STRING @lcKeyValue, INTEGER @lnKeyLength
		ENDIF
		*
		lnKeyType=0
		lnKeyLength=256
		lcKeyValue=SPACE(m.lnKeyLength)
		lnError=RegQueryValueEx(m.lnKeyHandle, m.lcKey, 0, @lnKeyType, @lcKeyValue, @lnKeyLength)
		This.RegCloseKey(m.lnKeyHandle)
		*
		IF m.lnError=0
			DO CASE
			CASE m.lnKeyType=1 OR m.lnKeyType=2	&& 1 - Data string (REG_SZ) 2-(REG_EXPAND_SZ)
				RETURN LEFT(m.lcKeyValue, m.lnKeyLength - 1)
			CASE m.lnKeyType=4					&& 4 - 32 bit number DWORD
				RETURN CTOBIN(LEFT(m.lcKeyValue, 4), '4RS')
			OTHE								&& 3 - Binary data
			ENDCASE
		ENDIF
	ENDIF
RETURN .F.

ENDPROC
PROCEDURE regopenkey
* Œ“ –€“‹  Àﬁ◊ –≈≈—“–¿
* –≈«”À‹“¿“ : ’›ÕƒÀ Œ“ –€“Œ√Œ  Àﬁ◊¿ (INTEGER) »À» 0 œ–» Œÿ»¡ ≈
* This.RegOpenKey(HKEY_LOCAL_MACHINE, 'Software\Microsoft\Shared Tools\MSInfo')
LPARAMETERS tnRoot AS Integer, tcPath AS String
LOCAL lnKeyHandle AS Integer
	lnKeyHandle=0
	*
	IF !THIS.isLoaded("RegOpenKey")
		DECLARE INTEGER RegOpenKey IN WIN32API INTEGER, STRING @, INTEGER @
	ENDIF
	*
	RegOpenKey(m.tnRoot, m.tcPath, @lnKeyHandle)
RETURN m.lnKeyHandle
ENDPROC
PROCEDURE regsetkey
* «¿œ»—¿“‹ —“–Œ Œ¬€… »À» ◊»—ÀŒ¬Œ…  Àﬁ◊ –≈≈—“–¿
* –≈«”À‹“¿“ : .T. -  Àﬁ◊ ”—œ≈ÿÕŒ «¿œ»—¿Õ, .F. - Œÿ»¡ ¿ «¿œ»—»  Àﬁ◊¿
* œŒƒÃ≈Õ¿ MSINFO Õ¿ ¿»ƒ” ;)
* This.RegSetKey(REG_HKEY_LOCAL_MACHINE, 'Software\Microsoft\Shared Tools\MSInfo', 'Path', 'C:\Util\Aida32.exe')
* ¿¬“Œ«¿œ”—  : (\Run,\RunOnce,\RunOnceEx)
* This.RegSetKey(REG_HKEY_LOCAL_MACHINE, REG_KEY_WIN9X_CURRENTVERSION + '\Run', 'My cool program ;)', 'C:\VFP\MAIN\Main.exe')
LPARAMETERS tnRoot AS Integer, tcPath AS String, tcKey AS String, tuValue AS Variant
LOCAL lnKeyHandle, lnKeyType, lnKeyLength, lcKeyValue, lnError
	lnKeyHandle=This.RegOpenKey(m.tnRoot, m.tcPath)
	*
	IF m.lnKeyHandle>0
		DO CASE
		CASE VARTYPE(m.tuValue)='C'
			* DATA STRING
			lnKeyType=1
			lcKeyValue=m.tuValue+CHR(0)
		CASE VARTYPE(m.tuValue)='N'
			* 32 BIT NUMBER
			lnKeyType=4
			lcKeyValue=BINTOC(m.tuValue, '4RS')+CHR(0)
		OTHERWISE
			RETURN .F.
		ENDCASE
		*
		lnKeyLength=LEN(m.lcKeyValue)
		*
		IF !THIS.isLoaded("RegSetValueEx")
			DECLARE INTEGER RegSetValueEx IN WIN32API INTEGER, STRING, INTEGER, INTEGER, STRING, INTEGER
		ENDIF
		*
		lnError=RegSetValueEx(m.lnKeyHandle, m.tcKey, 0, m.lnKeyType, m.lcKeyValue, m.lnKeyLength)
		This.RegCloseKey(m.lnKeyHandle)
		RETURN m.lnError=0
	ENDIF
RETURN .F.
ENDPROC
PROCEDURE regsvr32
* –≈√»—“–¿÷»ﬂ OCX ACTIVEX ¡»¡À»Œ“≈ » ¬ –≈≈—“–≈ œŒ—–≈ƒ—“¬ŒÃ ¬—“–Œ≈ÕÕ€’ œ–Œ÷≈ƒ”–
* «¿Ã≈Õ»“≈À‹ REGSVR32.EXE FILENAME.OCX » REGSVR32.EXE /U FILENAME.OCX
* œ¿–¿Ã≈“–€ : œ”“‹ » »Ãﬂ OCX ‘¿…À¿ (C), REGISTER / UNREGISTER (L)
* –≈«”À‹“¿“ : —“–Œ ¿ — —ŒŒ¡Ÿ≈Õ»≈Ã Œ¡ Œÿ»¡ ≈ »À» œ”—“Œ
LPARAMETERS tcOcxFileName AS String, tlRegister AS Logical
LOCAL lcMessage AS String, lnHandle AS Integer, lcProcedure AS String, lnError AS Integer
	lcMessage=''
	lnHandle=This.LoadLibrary(m.tcOcxFileName)
	*
	IF m.lnHandle>0
		lcProcedure=IIF(m.tlRegister, 'DllRegisterServer', 'DllUnregisterServer')
		*
		IF This.GetProcAddress(m.lnHandle, m.lcProcedure)>0
			IF m.tlRegister
				lnError=This.DllRegisterServer(m.tcOcxFileName)
			ELSE
				lnError=This.DllUnregisterServer(m.tcOcxFileName)
			ENDIF
			*
			IF m.lnError<>0
				lcMessage='Œ¯Ë·Í‡ ÔË ‚˚ÔÓÎÌÂÌËË ÔÓˆÂ‰Û˚ '+;
					m.lcProcedure+CHR_CR+'‚ ·Ë·ÎËÓÚÂÍÂ '+m.tcOcxFileName
			ENDIF
		ELSE
			lcMessage='ÕÂ Ì‡È‰ÂÌ ‡‰ÂÒ ÚÓ˜ÍË ‚ıÓ‰‡ ÔÓˆÂ‰Û˚ '+;
				m.lcProcedure+CHR_CR+'‚ ·Ë·ÎËÓÚÂÍÂ '+m.tcOcxFileName
		ENDIF
		IF !This.FreeLibrary(m.lnHandle)
			lcMessage='Œ¯Ë·Í‡ ÓÒ‚Ó·ÓÊ‰ÂÌËˇ ·Ë·ÎËÓÚÂÍË'+CHR_CR+m.tcOcxFileName
		ENDIF
	ELSE
		lcMessage='Œ¯Ë·Í‡ Á‡„ÛÁÍË ·Ë·ÎËÓÚÂÍË'+CHR_CR+m.tcOcxFileName
	ENDIF
RETURN m.lcMessage
ENDPROC
PROCEDURE releasecapture
* RESTORES NORMAL MOUSE INPUT PROCESSING
	IF !THIS.isLoaded("ReleaseCapture")
		DECLARE ReleaseCapture IN WIN32API
	ENDIF
	*
	ReleaseCapture()
ENDPROC
PROCEDURE releasedc
* RELEASES A DEVICE CONTEXT (DC), FREEING IT FOR USE BY OTHER APPLICATIONS
* This.ReleaseDC(ThisForm.Hwnd, This.GetDC(ThisForm.Hwnd))
LPARAMETERS tnHWnd AS Integer, tnDCHandle AS Integer
	IF !THIS.isLoaded("ReleaseDC")
		DECLARE INTEGER ReleaseDC IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	ReleaseDC(m.tnHWnd, m.tnDCHandle)
ENDPROC
PROCEDURE releasemutex
* Œ—¬Œ¡Œ∆ƒ≈Õ»≈ Œ¡⁄≈ “¿ —»Õ’–ŒÕ»«¿÷»»
* –≈«”À‹“¿“ : ”—œ≈’ Œœ≈–¿÷»»
LPARAMETERS tnHandle AS Integer
LOCAL lnSuccess AS Integer
	IF !THIS.isLoaded("ReleaseMutex")
		DECLARE INTEGER ReleaseMutex IN WIN32API INTEGER
	ENDIF

	lnSuccess = ReleaseMutex(m.tnHandle)
RETURN m.lnSuccess > 0
ENDPROC
PROCEDURE removedirectory
* ”ƒ¿À≈Õ»≈  ¿“¿ÀŒ√¿
* P.S. Õ» ¿ »’ œ–≈»Ã”Ÿ≈—“¬ œ≈–≈ƒ ¬—“–Œ≈ÕÕŒ… RMDIR.
* Œ¡Ÿ≈≈ ¬ œŒ¬≈ƒ≈Õ»» REMOVEDIRECTORY » RMDIR :
* 1) Õ≈ ”Ã≈ﬁ“ ”ƒ¿Àﬂ“‹ READONLY  ¿“¿ÀŒ√»
* 2) «¿œ–Œ—“Œ –¿—œ–¿¬Àﬂﬁ“—ﬂ — SYSTEM » HIDDEN œ¿œ ¿Ã»
* 3) ÷≈œŒ◊ » ¬ÀŒ∆≈ÕÕ€’  ¿“¿ÀŒ√Œ¬ Õ≈ ÃŒ√”“ ¡€“‹ ”ƒ¿À≈Õ€ «¿ 1 œ–»—≈—“
LPARAMETERS tcFolder AS String
LOCAL lnSuccess AS Integer
	lnSuccess = 0

	IF DIRECTORY(m.tcFolder, 1)
		IF !THIS.isLoaded("RemoveDirectory")
			DECLARE INTEGER RemoveDirectory IN WIN32API STRING
		ENDIF

		lnSuccess = RemoveDirectory(m.tcFolder)
	ENDIF
RETURN m.lnSuccess <> 0
ENDPROC
PROCEDURE removeicon
* ”ƒ¿À»Ã » ŒÕ ” ¬ TITLEBAR Œ Õ¿
* œŒ—À≈ƒŒ¬¿“≈À‹ÕŒ—“‹ ƒ≈…—“¬»… ¬¿∆Õ¿!
* Œ–»√»Õ¿À‹Õ¿ﬂ »ƒ≈ﬂ ¬¿ƒ»Ã¿ œ»–Œ∆ Œ¬¿
LPARAMETERS tnHWnd AS Integer
	WITH This
		* ”—“¿ÕŒ¬»Ã Œ“—”“—“¬”ﬁŸ»… ¬ VFP ƒ»¿ÀŒ√Œ¬€… —“»À‹ Œ Õ¿ (BorderStyle # 0,1,2,3!)
		.SetWindowLong(m.tnHWnd, GWL_EXSTYLE, WS_EX_DLGMODALFRAME)
		* œ≈–≈ƒ≈–Õ≈Ã » ŒÕ ” — Ã¿À≈Õ‹ Œ… Õ¿ ¡ŒÀ‹ÿ”ﬁ, ’Œ“ﬂ » “¿  ”∆≈ —“Œ»“ ¡ŒÀ‹ÿ¿ﬂ ;)
		.SendMessage(m.tnHWnd, WM_SETICON, ICON_SMALL, 0)
		.SendMessage(m.tnHWnd, WM_SETICON, ICON_BIG, 0)
		* «¿Õ”À»Ã ” ¿«¿“≈À‹ » ŒÕ », ¿——Œ÷»»–Œ¬¿ÕÕŒ… —  À¿——ŒÃ Œ Õ¿
		.SetClassLong(m.tnHWnd, GCL_HICON, 0)
	ENDWITH

* œ–»Ã≈– œŒÀ”◊≈Õ»ﬂ TOOLWINDOW - ¡≈« » ŒÕ »,—  ÕŒœ Œ… CLOSE œŒÀŒ¬»ÕÕŒ… ¬€—Œ“€
* #DEFINE GWL_EXSTYLE				-20
* #DEFINE WS_EX_TOOLWINDOW		0x00000080
* DECLARE INTEGER SetWindowLong IN WIN32API INTEGER, INTEGER, INTEGER
* o=CREATEOBJECT('form')
* SetWindowLong(o.hWnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW)
* o.Show(1)
ENDPROC
PROCEDURE runprocess
* «¿œ”—  œ–»ÀŒ∆≈Õ»ﬂ DOS »À» WINDOWS C Œ∆»ƒ¿Õ»≈Ã –≈«”À‹“¿“¿
* œ¿–¿Ã≈“–€ :  ŒÃ¿ÕƒÕ¿ﬂ —“–Œ ¿, –¿¡Œ◊¿ﬂ œ¿œ ¿ œ–Œ÷≈——¿, –≈∆»Ã Œ Õ¿, œ–»Œ–»“≈“
* –≈«”À‹“¿“ : 0 - Œÿ»¡ ¿ —Œ«ƒ¿Õ»ﬂ œ–Œ÷≈——¿
* 			  1 - œ–Œ÷≈—— ”—œ≈ÿÕŒ «¿¬≈–ÿ≈Õ
* 		   	 -1 - œ–Œ÷≈—— ”¡»“ Œœ≈–¿“Œ–ŒÃ (Õ¿∆¿“ ESC)
* œ–»Ã≈◊¿Õ»≈ : ≈—À» œ–Œ÷≈—— —ÕﬂÀ» “–≈Ãﬂ œ¿À‹÷¿Ã» - ¬≈–Õ≈“ 1
* Œ—Œ¡≈ÕÕŒ—“» :
* ≈—À»   NORMAL_PRIORITY_CLASS ƒŒ¡¿¬»“‹ CREATE_NO_WINDOW,
* “Œ Œ ÕŒ Õ≈ œŒ ¿∆≈“—ﬂ, ƒ¿∆≈ ≈—À» ¬€—“¿¬À≈ÕŒ SW_SHOWNORMAL

LPARAMETERS tcCommandLine AS String, tcWorkingDir AS String,;
	tnWindowState AS Integer, tnPriority AS Integer
LOCAL lnReturnValue AS Integer, lnProcessHandle AS Integer,;
	lnResult AS Integer, lcProcessInfo AS String, lcStartUpInfo AS String
	* CREATES A NEW PROCESS AND ITS PRIMARY THREAD
	IF !THIS.isLoaded("CreateProcess")
		DECLARE SHORT CreateProcess IN WIN32API;
			STRING, STRING, STRING, STRING, SHORT, INTEGER, STRING, STRING, STRING, STRING
	ENDIF
	* RETURNS THE PSEUDOHANDLE OF THE CURRENT PROCESS
	IF !THIS.isLoaded("GetCurrentProcess")
		DECLARE INTEGER GetCurrentProcess IN WIN32API
	ENDIF
	* WAITS UNTIL THE PROCESS IS IDLE FOR INPUT
	IF !THIS.isLoaded("WaitForInputIdle")
		DECLARE INTEGER WaitForInputIdle IN WIN32API	INTEGER, INTEGER
	ENDIF
	*
	* WAITS UNTIL THE PROCESS IS SIGNALLED OR THE TIMEOUT PERIOD EXPIRES
	IF !THIS.isLoaded("WaitForSingleObject")
		DECLARE INTEGER WaitForSingleObject IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	IF !THIS.isLoaded("TerminateProcess")
		DECLARE INTEGER TerminateProcess IN WIN32API INTEGER, INTEGER
	ENDIF
	*
	IF !THIS.isLoaded("CloseHandle")
		DECLARE INTEGER CloseHandle	IN WIN32API INTEGER
	ENDIF
	*
	tcWorkingDir=IIF(VARTYPE(m.tcWorkingDir)<>'C' OR !DIRECTORY(m.tcWorkingDir), 0, ADDBS(ALLTRIM(m.tcWorkingDir))+CHR(0))
	tnWindowState=IIF(VARTYPE(m.tnWindowState)<>'N', SW_SHOWNORMAL, m.tnWindowState)
	tnPriority=IIF(VARTYPE(m.tnPriority)<>'N', NORMAL_PRIORITY_CLASS, m.tnPriority)
	lcStartUpInfo=CHR(68)+REPLICATE(CHR(0),43)+CHR(1)+REPLICATE(CHR(0), 3)+;
		CHR(m.tnWindowState)+REPLICATE(CHR(0), 19)
	lcProcessInfo=REPLICATE(CHR(0), 16)
	lnReturnValue=0					&& Œ¯Ë·Í‡ ÒÓÁ‰‡ÌËˇ ÔÓˆÂÒÒ‡
	*
	IF CreateProcess(0, m.tcCommandLine, 0, 0, 1, m.tnPriority, 0, m.tcWorkingDir,;
		@lcStartUpInfo, @lcProcessInfo)=1
		lnProcessHandle=(((ASC(SUBSTR(m.lcProcessInfo, 4, 1))*256)+;
			ASC(SUBSTR(m.lcProcessInfo, 3, 1)))*256+;
			ASC(SUBSTR(m.lcProcessInfo, 2, 1)))*256+;
			ASC(LEFT(m.lcProcessInfo, 1))
		* ¡≈— ŒÕ≈◊ÕŒ≈ Œ∆»ƒ¿Õ»≈ Œ ŒÕ◊¿Õ»ﬂ –¿¡Œ“€ œ–Œ÷≈——¿
		WaitForInputIdle(GetCurrentProcess(), INFINITE)
		lnReturnValue=1				&& ”ÒÔÂ¯ÌÓÂ Á‡‚Â¯ÂÌËÂ
		* œ–Œ¬≈–ﬂ≈Ã Õ¿∆¿“»≈ ESC  ¿∆ƒ€≈ œŒÀ—≈ ”Õƒ€
		DO WHILE WaitForSingleObject(m.lnProcessHandle, TIME_ONE_SECOND/2)=WAIT_TIMEOUT
			IF INKEY()=KEY_ESC
				* œ–≈ –¿“»“‹ ¬€œŒÀÕ≈Õ»≈ œ–Œ√–¿ÃÃ€ ?
				IF MESSAGEBOX(MSG_PROGRAMTERMINATE, 4+32+256, ThisForm.Caption)=6
					* œ–≈ –¿“»Ã ¬€œŒÀÕ≈Õ»≈ — PROCESSEXITCODE = 0
					TerminateProcess(m.lnProcessHandle, 0)
					CloseHandle(m.lnProcessHandle)
					lnReturnValue=-1	&& ŒÔÂ‡ÚÓ Ì‡Ê‡Î Escape
					EXIT
				ENDIF
			ENDIF
		ENDDO
	ENDIF									
RETURN m.lnReturnValue

*!* * * * * * * * * * * * * * * * * * * * * * * *
*!*	—Ã. http://support.microsoft.com/kb/q191584/*
*!* * * * * * * * * * * * * * * * * * * * * * * *
*!*	HOW TO DETERMINE WHEN A 32-BIT PROCESS HAS COMPLETED
*!*	Executing the RUN/! command in a Visual FoxPro program starts another executable
*!*	program asynchronously and returns control to the Visual FoxPro application. This
*!*	shelled program continues to run independently of the parent Visual FoxPro
*!*	application until the user closes it. However, if your Visual FoxPro application
*!*	needs to wait for the child process to terminate, you can use the Win32
*!*	CreateProcess and WaitForSingleObject API functions. CreateProcess starts
*!*	the child process and populates a PROCESS_INFORMATION structure with its process
*!*	handle. WaitForSingleObject accepts this process handle as an argument, and puts
*!*	the processor in an extremely efficient wait state until the child process
*!*	terminates. 

*!*	#DEFINE NORMAL_PRIORITY_CLASS 32
*!*	#DEFINE IDLE_PRIORITY_CLASS 64
*!*	#DEFINE HIGH_PRIORITY_CLASS 128
*!*	#DEFINE REALTIME_PRIORITY_CLASS 1600

*!*	* Return code from WaitForSingleObject() if
*!*	* it timed out.
*!*	#DEFINE WAIT_TIMEOUT 0x00000102

*!*	* This controls how long, in milli secconds, WaitForSingleObject()
*!*	* waits before it times out. Change this to suit your preferences.
*!*	#DEFINE WAIT_INTERVAL 200

*!*	DECLARE INTEGER CreateProcess IN kernel32.DLL ;
*!*	   INTEGER lpApplicationName, ;
*!*	   STRING lpCommandLine, ;
*!*	   INTEGER lpProcessAttributes, ;
*!*	   INTEGER lpThreadAttributes, ;
*!*	   INTEGER bInheritHandles, ;
*!*	   INTEGER dwCreationFlags, ;
*!*	   INTEGER lpEnvironment, ;
*!*	   INTEGER lpCurrentDirectory, ;
*!*	   STRING @lpStartupInfo, ;
*!*	   STRING @lpProcessInformation

*!*	DECLARE INTEGER WaitForSingleObject IN kernel32.DLL ;
*!*	   INTEGER hHandle, INTEGER dwMilliseconds

*!*	DECLARE INTEGER CloseHandle IN kernel32.DLL ;
*!*	   INTEGER hObject

*!*	DECLARE INTEGER GetLastError IN kernel32.DLL

*!*	* STARTUPINFO is 68 bytes, of which we need to
*!*	* initially populate the 'cb' or Count of Bytes member
*!*	* with the overall length of the structure.
*!*	* The remainder should be 0-filled
*!*	start = long2str(68) + REPLICATE(CHR(0), 64)

*!*	* PROCESS_INFORMATION structure is 4 longs,
*!*	* or 4*4 bytes = 16 bytes, which we'll fill with nulls.
*!*	process_info = REPLICATE(CHR(0), 16)

*!*	* Start a copy of NOTEPAD (EXE name must be null-terminated)
*!*	File2Run = "C:\WINNT\NOTEPAD.EXE" + CHR(0)

*!*	* Call CreateProcess, obtain a process handle. Treat the
*!*	* application to run as the 'command line' argument, accept
*!*	* all other defaults. Important to pass the start and
*!*	* process_info by reference.
*!*	RetCode = CreateProcess(0, File2Run, 0, 0, 1, ;
*!*	   NORMAL_PRIORITY_CLASS, 0, 0, @start, @process_info)

*!*	* Unable to run, exit now.
*!*	IF RetCode = 0
*!*	   =MESSAGEBOX("Error occurred. Error code: ", GetLastError())
*!*	   RETURN
*!*	ENDIF

*!*	* Extract the process handle from the
*!*	* PROCESS_INFORMATION structure.
*!*	hProcess = str2long(SUBSTR(process_info, 1, 4))

*!*	DO WHILE .T.
*!*	* Use timeout of TIMEOUT_INTERVAL msec so the display
*!*	* will be updated. Otherwise, the VFP window never repaints until
*!*	* the loop is exited.
*!*	IF WaitForSingleObject(hProcess, WAIT_INTERVAL) != WAIT_TIMEOUT
*!*	     EXIT
*!*	   ELSE
*!*	      DOEVENTS
*!*	   ENDIF
*!*	ENDDO

*!*	* Show a message box when we're done.
*!*	=MESSAGEBOX ("Process completed")

*!*	* Close the process handle afterwards.
*!*	RetCode = CloseHandle(hProcess)
*!*	RETURN


*!*	********************
*!*	FUNCTION long2str
*!*	********************
*!*	* Passed : 32-bit non-negative numeric value (m.longval)
*!*	* Returns : ASCII character representation of passed
*!*	*           value in low-high format (m.retstr)
*!*	* Example :
*!*	*    m.long = 999999
*!*	*    m.longstr = long2str(m.long)

*!*	PARAMETERS m.longval

*!*	PRIVATE i, m.retstr

*!*	m.retstr = ""
*!*	FOR i = 24 TO 0 STEP -8
*!*	   m.retstr = CHR(INT(m.longval/(2^i))) + m.retstr
*!*	   m.longval = MOD(m.longval, (2^i))
*!*	NEXT
*!*	RETURN m.retstr


*!*	*******************
*!*	FUNCTION str2long
*!*	*******************
*!*	* Passed:  4-byte character string (m.longstr)
*!*	*   in low-high ASCII format
*!*	* returns:  long integer value
*!*	* example:
*!*	*   m.longstr = "1111"
*!*	*   m.longval = str2long(m.longstr)

*!*	PARAMETERS m.longstr

*!*	PRIVATE i, m.retval

*!*	m.retval = 0
*!*	FOR i = 0 TO 24 STEP 8
*!*	   m.retval = m.retval + (ASC(m.longstr) * (2^i))
*!*	   m.longstr = RIGHT(m.longstr, LEN(m.longstr) - 1)
*!*	NEXT
*!*	RETURN m.retval

ENDPROC
PROCEDURE selectobject
* SELECTS AN OBJECT INTO A SPECIFIED DEVICE CONTEXT
LPARAMETERS tnDC, tnObject
	IF !THIS.isLoaded("SelectObject")
		DECLARE LONG SelectObject IN Win32API LONG, LONG
	ENDIF
	*
	SelectObject(m.tnDC, m.tnObject)
ENDPROC
PROCEDURE sendmessage
* SENDS THE SPECIFIED MESSAGE TO A WINDOW OR WINDOWS
* This.SendMessage(ThisForm.hWnd, WM_SYSCOMMAND, SC_MOVE + HTCAPTION, 0)
* This.SendMessage(ThisForm.hWnd, WM_SETICON, ICON_SMALL, 0)
* This.SendMessage(ThisForm.hWnd, WM_CLOSE, 0, 0)
* P.S. VFP  ŒÕ“–ŒÀ€ - –»—Œ¬¿ÕÕ€≈ ¡»“Ã¿œ€, ¿ Õ≈ Œ Õ¿, ÕŒ Õ≈ ¬—≈√ƒ¿
* Õ¿œ–»Ã≈– COMBOBOX - –»—”ÕŒ , ¿ ≈√Œ ¬€œ¿ƒ¿ﬁŸ»… —œ»—Œ  - Œ ÕŒ !
* (»Õ¿◊≈ —œ»—Œ  Õ≈¬Œ«ÃŒ∆ÕŒ ¡€ÀŒ ¡€ œŒ ¿«¿“‹ «¿ œ–≈ƒ≈À¿Ã» ‘Œ–Ã€)
LPARAMETERS tnHwnd, tnMessage, tnParameter1, tnParameter2
LOCAL lnResult AS Long
	tnParameter1=IIF(VARTYPE(m.tnParameter1)='N', m.tnParameter1, 0)
	tnParameter2=IIF(VARTYPE(m.tnParameter2)='N', m.tnParameter2, 0)
	*
	IF !THIS.isLoaded("SendMessage")
		DECLARE LONG SendMessage IN WIN32API LONG, LONG, LONG, LONG
	ENDIF
	*
	lnResult=SendMessage(m.tnHWnd, m.tnMessage, m.tnParameter1, m.tnParameter2)
RETURN m.lnResult
ENDPROC
PROCEDURE setattributes
* —Ã≈Õ¿ ¿“–»¡”“Œ¬ ‘¿…À¿ »À»  ¿“¿ÀŒ√¿
LPARAMETERS tcPathFileOrFolder AS String, tnAttribute AS Integer
LOCAL lnSuccess AS Integer
	lnSuccess=0
	*
	IF FILE(m.tcPathFileOrFolder, 1) OR DIRECTORY(m.tcPathFileOrFolder, 1)
		tnAttribute=IIF(VARTYPE(m.tnAttribute)<>'N', FILE_ATTRIBUTE_NORMAL, m.tnAttribute)
		*
		IF !THIS.isLoaded("SetFileAttributes")
			DECLARE INTEGER SetFileAttributes IN WIN32API STRING, INTEGER
		ENDIF
		*
		lnSuccess=SetFileAttributes(m.tcPathFileOrFolder, m.tnAttribute)
	ENDIF
RETURN m.lnSuccess<>0

ENDPROC
PROCEDURE setclasslong
* REPLACES THE SPECIFIED 32-BIT (LONG) VALUE AT THE SPECIFIED OFFSET INTO THE EXTRA CLASS MEMORY OR THE WNDCLASSEX STRUCTURE FOR THE CLASS TO WHICH THE SPECIFIED WINDOW BELONGS
* Õ¿œ–»Ã≈– «¿Õ”À»Ã ” ¿«¿“≈À‹ » ŒÕ » ¿——Œ÷»»–Œ¬¿ÕÕŒ…, —  À¿——ŒÃ Œ Õ¿ :
* This.SetClassLong(ThisForm.hWnd, GCL_HICON, 0)
LPARAMETERS tnHWnd AS Integer, tnIndex AS Integer, tnValue AS Integer
	IF !THIS.isLoaded("SetClassLong")
		DECLARE INTEGER SetClassLong IN WIN32API INTEGER, INTEGER, INTEGER
	ENDIF
	*
	SetClassLong(m.tnHWnd, m.tnIndex, m.tnValue)

ENDPROC
PROCEDURE setdatetime
* ”—“¿ÕŒ¬ ¿ —»—“≈ÃÕŒ… ƒ¿“€ » ¬–≈Ã≈Õ» (UTC?)
* This.SetDateTime(TIME())
* —Ã. MSDN : Q188897
LPARAMETERS ttNewDateTime AS Datetime
LOCAL lcSystemTime AS String
	* LPSYSTEMTIME - —“–Œ ¿ —“–” “”–€ WINAPI : 8 ’ 2 = 16
	IF !THIS.isLoaded("SetLocalTime")
		DECLARE SetLocalTime IN WIN32API STRING @
	ENDIF
	* «¿Õ”Àﬂ≈Ã ÕŒÃ≈– ƒÕﬂ Õ≈ƒ≈À» » Ã»ÀÀ»—≈ ”Õƒ€
	lcSystemTime=BINTOC(YEAR(m.ttNewDateTime), '2RS')+;
		BINTOC(MONTH(m.ttNewDateTime), '2RS')+REPLICATE(CHR(0), 2)+;
		BINTOC(DAY(m.ttNewDateTime), '2RS')+BINTOC(HOUR(m.ttNewDateTime), '2RS')+;
		BINTOC(MINUTE(m.ttNewDateTime), '2RS')+BINTOC(SEC(m.ttNewDateTime), '2RS')+;
		REPLICATE(CHR(0), 2)
	SetLocalTime(@lcSystemTime)
	* ŒœŒ¬≈—“»Ã ¬—≈’ Œ —Ã≈Õ≈ —»—“≈ÃÕŒ√Œ ¬–≈Ã≈Õ»
	This.SendMessage(HWND_BROADCAST, WM_TIMECHANGE)


ENDPROC
PROCEDURE setfiletime
* ”—“¿ÕŒ¬ ¿ ƒ¿“€ » ¬–≈Ã≈Õ» —Œ«ƒ¿Õ»ﬂ, ÃŒƒ»‘» ¿÷»» » ƒŒ—“”œ¿   ‘¿…À”
* Œ—Œ¡≈ÕÕŒ—“» œŒ¬≈ƒ≈Õ»ﬂ FAT » NTFS :
* Windows NT FAT, create time has a resolution of 10 milliseconds,
* write time has a resolution of 2 seconds, and access time has a
* resolution of 1 day (really, the access date).
* On NTFS, access time has a resolution of 1 hour.
* Therefore, the GetFileTime function may not return the same file time
* information set using SetFileTime. Furthermore, FAT records times
* on disk in local time. However, NTFS records times on disk in UTC. 
* NTFS records file times natively in FILETIME format,
* so they are not affected by changes in time zone or daylight saving time
LPARAMETERS tcFileName AS String, ttCreate AS Datetime,;
	ttAccess AS Datetime, ttModify AS Datetime
LOCAL lnHandle AS Integer
	lnHandle=This.Openfile(m.tcFileName)
	*
	WITH This.Parent.oFunction
		lcCreate=.TimeToString(m.ttCreate)
		lcAccess=.TimeToString(m.ttAccess)
		lcModify=.TimeToString(m.ttModify)
	ENDWITH
	*
	IF m.lnHandle>0
		IF !THIS.isLoaded("SetFileTime")
			DECLARE INTEGER SetFileTime IN WIN32API INTEGER, STRING @, STRING @, STRING @  
		ENDIF
		*
		SetFileTime(m.lnHandle, m.lcCreate, m.lcAccess, m.lcModify)
		This.CloseHandle(m.lnHandle)
	ENDIF
ENDPROC
PROCEDURE setwindowlong
* CHANGES AN ATTRIBUTE OF THE SPECIFIED WINDOW
* Õ¿œ–»Ã≈– ”—“¿ÕŒ¬»Ã Œ“—”“—“¬”ﬁŸ»… ¬ VFP ƒ»¿ÀŒ√Œ¬€… —“»À‹ Œ Õ¿ (BorderStyle # 0,1,2,3!)
* This.SetWindowLong(ThisForm.hWnd, GWL_EXSTYLE, WS_EX_DLGMODALFRAME)
LPARAMETERS tnHWnd AS Integer, tnIndex AS Integer, tnValue AS Integer
	IF !THIS.isLoaded("SetWindowLong")
		DECLARE INTEGER SetWindowLong IN WIN32API INTEGER, INTEGER, INTEGER
	ENDIF
	*
	SetWindowLong(m.tnHWnd, m.tnIndex, m.tnValue)
ENDPROC
PROCEDURE setwindowrgn
* THE SETWINDOWRGN FUNCTION SETS THE WINDOW REGION OF A WINDOW.
* THE WINDOW REGION DETERMINES THE AREA WITHIN THE WINDOW WHERE THE SYSTEM PERMITS DRAWING.
* THE SYSTEM DOES NOT DISPLAY ANY PORTION OF A WINDOW THAT LIES OUTSIDE OF THE WINDOW REGION.
LPARAMETERS tnWindowHandle AS Integer, tnRegionHandle AS Integer
LOCAL llSuccess AS Logical
	IF !THIS.isLoaded("SetWindowRgn")
		DECLARE INTEGER SetWindowRgn IN WIN32API INTEGER, INTEGER, INTEGER
	ENDIF
	*
	llSuccess=SetWindowRgn(m.tnWindowHandle, m.tnRegionHandle, 1)<>0
	*
	IF !m.llSuccess
		THIS.DeleteObject(m.tnRegionHandle)
	ENDIF
RETURN m.llSuccess
ENDPROC
PROCEDURE shellexecute
* ÿ›À-–≈¿ ÷»ﬂ Õ¿ –¿—ÿ»–≈Õ»≈ ‘¿…À¿ » ƒ–”√»≈ ¡Œ√¿“€≈ ¬Œ«ÃŒ∆ÕŒ—“»!
* IF EMPTY(This.ShellExecute('readme.txt', FULLPATH(''), 'Print', 0))	- ‡ÒÔÂ˜‡Ú‡Ú¸ Ù‡ÈÎ
* IF EMPTY(This.ShellExecute('notepad.exe',,,'c:\autoexec.bat')			- ÓÚÍ˚Ú¸ notepad Ë Ò Á‡„ÛÊÂÌÌ˚Ï ‰Îˇ ÔÓÒÏÓÚ‡ autoexec.bat
LPARAMETERS tcFilename AS String, tcWorkDir AS String, tcOperation AS String, tcParameters AS String, tnWindowState AS Integer
LOCAL lcFileName As String, lcWorkDir AS String, lcOperation AS String,;
	lcParameters AS String, lnWindowState AS Integer, lnError AS Integer
	lcFileName = ALLTRIM(m.tcFileName)
	lcWorkDir = IIF(VARTYPE(m.tcWorkDir) = 'C', ALLTRIM(m.tcWorkDir), '')
	lcOperation = IIF(VARTYPE(m.tcOperation) = 'C' AND !EMPTY(m.tcOperation), ALLTRIM(m.tcOperation), 'open')
	lcParameters = IIF(VARTYPE(m.tcParameters) = 'C', ALLTRIM(m.tcParameters), '')
	lnWindowState = IIF(VARTYPE(m.tnWindowState) = 'N', m.tnWindowState, SW_SHOWNORMAL)

	IF !THIS.isLoaded("ShellExecute")
		DECLARE INTEGER ShellExecute IN SHELL32.DLL INTEGER, STRING, STRING, STRING, STRING, INTEGER
	ENDIF

	lnError = ShellExecute(0, m.lcOperation, m.lcFilename, m.lcParameters, m.lcWorkDir, m.lnWindowState)
RETURN This.LocalErrorMessage('ShellExecute', m.lnError) && 0-32

#IF .F.

	tcOperation :
	'edit'		- Launches an editor and opens the document for editing. If lpFile is not a document file, the function will fail. 
	'explore'	- Explores the folder specified by lpFile.  
	'find'		- Initiates a search starting from the specified directory. 
	'open'		- Opens the file specified by the lpFile parameter. The file can be an executable file, a document file, or a folder. 
	'print'		- Prints the document file specified by lpFile. If lpFile is not a document file, the function will fail. 

	OPENS DATA FILES WITH THEIR ASSOCIATED APPLICATIONS
	ShellExecute (0,	'open',	'c:\mybase.mdb','',	'',	SW_SHOWMAXIMIZED) 

	ACCESSING A SITE ON THE INTERNET
	ShellExecute (0, 'open', 'http://www.mysite.com/','', '',SW_SHOWMAXIMIZED) 

	OPENS A FOLDER BY IE ;)
	ShellExecute (0, 'explore','c:\util','','',SW_SHOWMAXIMIZED) 

	OPEN SEARCH FILE WINDOW STARTING FROM THE SPECIFIED DIRECTORY
	ShellExecute (0, 'find','','','C:\',SW_SHOWMAXIMIZED) 

	PRINTS THE TEXT FILE USING THE ASSOCIATED APPLICATION (œ≈◊¿“‹ ‘¿…À¿ œŒ—–≈ƒ—“¬ŒÃ NOTEPAD)
	ShellExecute (0, 'print','c:\myfile.txt','','',SW_SHOWMAXIMIZED) 

#ENDIF
ENDPROC
PROCEDURE showcursor
* — –€“‹ / œŒ ¿«¿“‹ Ã€ÿ»Õ€…  ”–—Œ–
* P.S. VFP8 VERY OFTEN RESTORES HIDDEN MOUSE CURSOR AUTOMATICALLY. SO THIS FUNCTION MAY NOT BE USEFUL.
* MOUSEPOINTER PROPERTY, APPLICABLE TO MANY VFP CONTROLS, HIDES THE POINTER WHEN SET TO 13
LPARAMETERS tlShow AS Logical
	IF !THIS.isLoaded("ShowCursor")
		DECLARE INTEGER ShowCursor IN Win32API INTEGER
	ENDIF
	*
	ShowCursor(IIF(m.tlShow, 1, 0))
ENDPROC
PROCEDURE shutdownwindows
* ¬€«Œ¬ ƒ»¿ÀŒ√¿ «¿¬≈–ÿ≈Õ»ﬂ –¿¡Œ“€ WINDOWS
LOCAL lnHandle AS Integer
	lnHandle=This.FindWindow('Program Manager')
	This.SendMessage(m.lnHandle, WM_ENDSESSION, 0, 0)

*!*	* HOWTO Exit Windows from Visual FoxPro ?
*!*	* =======================================
*!*	* Program....:  EXITWINDOWS.PRG  
*!*	* Version....:  1.0  
*!*	* Author.....:  Dipl. Kfm. Frank Dietrich  
*!*	* Date.......:  21.Oktober 2001  
*!*	* Notice.....:  Copyright (c) 2001  
*!*	*               Frank Dietrich Datentechnik  
*!*	*               Leo-Baeck-Str. 22  
*!*	*               14165 Berlin  
*!*	*               PHONE : +49-30-845 777-0  
*!*	*               FAX   : +49-30-845 777-19  
*!*	*         CIS   : 100322,333  
*!*	*    e-mail: frank.dietrich@dd-tech.de, All Rights Reserved.  
*!*	* Compiler...:  Visual FoxPro 07.00.0000.9297 f¸r Windows  
*!*	* Abstract...:  Prozedurendatei mit einer Prozedur, um Windows  
*!*	*    in unterschiedlichen Modi herunterzufahren und  
*!*	*    ggf. auch den Rechner auszuschalten  
*!*	*    Funktioniert auf allen Win OS  
*!*	*    Source stammt aus  
*!*	*-- Define from Winnt.h  
*!*	#DEFINE TOKEN_ADJUST_PRIVILEGES   0x0020  
*!*	#DEFINE TOKEN_QUERY               0x0008  
*!*	#DEFINE SE_PRIVILEGE_ENABLED      2  

*!*	*-- Defines from Winbase.h  
*!*	#DEFINE VER_PLATFORM_WIN32s             0  
*!*	#DEFINE VER_PLATFORM_WIN32_WINDOWS      1  
*!*	#DEFINE VER_PLATFORM_WIN32_NT           2  
*!*	    
*!*	*-- Defines from WinUser.h  
*!*	#DEFINE EWX_LOGOFF           0  && Shuts down all processes running  
*!*	                                && in the security  
*!*	                                && context of the process that  
*!*	                                && called the ExitWindowsEx function.  
*!*	                                && Then it logs the user off.  
*!*	    
*!*	#DEFINE EWX_SHUTDOWN         1  && Shuts down the system to a point  
*!*	                                && at which it is safe to turn off the  
*!*	                                && power. All file buffers have been  
*!*	                                && flushed to disk, and all  
*!*	                                && running processes have stopped.  

*!*	                                && Windows NT/2000: The calling process  
*!*	                                && must have the SE_SHUTDOWN_NAME  
*!*	                                && privilege.  
*!*	    
*!*	#DEFINE EWX_REBOOT           2  && Shuts down the system and then  
*!*	                                && restarts the system.  
*!*	    
*!*	                                && Windows NT/2000: The calling process  
*!*	                                && must have the SE_SHUTDOWN_NAME  
*!*	                                && privilege.  
*!*	    
*!*	#DEFINE EWX_POWEROFF         8  && Shuts down the system and turns  
*!*	                                && off the power. The system must support  
*!*	                                && the power-off feature.  

*!*	                                && Windows NT/2000: The calling process  
*!*	                                && must have the SE_SHUTDOWN_NAME  
*!*	                                && privilege.  

*!*	*-- Change EWX_SHUTDOWN to any of the above #define values to  
*!*	*-- either logoff, shutdown, reboot, or power off.  
*!*	* DO ExitWindowsFox WITH EWX_SHUTDOWN  
*!*	PROCEDURE ExitWindows
*!*	PARAMETERS ExitMode
*!*	LOCAL iRc
*!*	iRc = 0
*!*	DECLARE ExitWindowsEx IN Win32Api INTEGER, INTEGER
*!*	*-- Check the OS version, and call the SetPrivilege function if NT/Win2K
*!*	liPlatform = GetPlatform()
*!*	IF liPlatform != VER_PLATFORM_WIN32_NT	&& We can do whatever we wish  
*!*											&& without worrying about security  
*!*		iRc = ExitWindowsEx(ExitMode, 0)
*!*		IF ExitMode = EWX_LOGOFF OR ExitMode = EWX_POWEROFF
*!*			*-- Necessary because VFP will not exit using  
*!*			*-- either of these parameters under Win9x.  
*!*			QUIT
*!*		ENDIF  
*!*	ELSE									&& We have to set the process security  
*!*		iRc = SetProcPrivilege()  
*!*		IF iRc <> 0  
*!*			iRc = ExitWindowsEx(ExitMode, 0)  
*!*		ENDIF
*!*	ENDIF									&& liPlatform != VER_PLATFORM_WIN32_NT  

*!*	PROCEDURE SetProcPrivilege  
*!*	*-- Sets the appropriate process privilege to allow shutdown on NT/Win2K  
*!*	*-- Declare function to obtain current Process ID, needed to open the process  
*!*	*-- get the process token.  
*!*	LOCAL iRc  
*!*	iRc = 0  
*!*	DECLARE INTEGER GetCurrentProcessId IN kernel32.DLL  
*!*	DECLARE INTEGER OpenProcess IN Kernel32.DLL INTEGER, INTEGER, INTEGER  
*!*	DECLARE INTEGER OpenProcessToken IN AdvApi32.DLL INTEGER, INTEGER, INTEGER @
*!*	 
*!*	*-- Declare function to retrieve a LUID for the necessary security  
*!*	*-- privilege.  
*!*	DECLARE INTEGER LookupPrivilegeValue IN AdvApi32.DLL STRING, STRING, INTEGER @
*!*	 
*!*	*-- Declare function to adjust the process token privileges so that  
*!*	*-- we can shut down NT/Windows 2000  
*!*	DECLARE INTEGER AdjustTokenPrivileges IN AdvApi32.DLL INTEGER, ;  
*!*	INTEGER, STRING @, INTEGER, INTEGER, INTEGER  

*!*	liAccessToken = 0        && Placeholder for the access token whose privileges we'll change  
*!*	lsLuidBuffer = SPACE(8)  && Placeholder for LUID used to change access privileges  
*!*	lsName = SPACE(15)       && Placeholder for computer name  
*!*	liBufferLen = 15         && Placeholder for the computer name buffer length  
*!*	liLuid = 0  
*!*	liProc = 0  
*!*	liProc = GetCurrentProcessId()  
*!*	hProc = OpenProcess(2035711, 0, liProc)  
*!*	iRc = OpenProcessToken(hProc, BITOR(TOKEN_ADJUST_PRIVILEGES, TOKEN_QUERY), @liAccessToken)  
*!*	IF iRc <> 0  
*!*		IF iRc <> 0  
*!*			*-- "SeShutdownPrivilege" is the string value for the SE_SHUTDOWN_NAME value.  
*!*			LookupPrivilegeValue("", "SeShutdownPrivilege", @liLuid)  
*!*			lsLuidBuffer = LongToStr(liLuid) + CHR(0) + CHR(0) + CHR(0) + CHR(0)  
*!*			*-- Declare a string to hold the TOKEN_PRIVILEGES structure  
*!*			lsNewState = SPACE(16)
*!*			*-- Fill in the structure  
*!*			lsNewState = LongToStr(1) + lsLuidBuffer + LongToStr(SE_PRIVILEGE_ENABLED)
*!*			iRc = AdjustTokenPrivileges(liAccessToken, 0, @lsNewState, LEN(lsNewState), 0, 0)
*!*			RETURN iRc  
*!*		ELSE  
*!*			RETURN iRc  
*!*		ENDIF
*!*	ELSE  
*!*		RETURN iRc  
*!*	ENDIF  
*!*	ENDPROC  

*!*	PROCEDURE GetPlatform  
*!*	LOCAL liPlatform, iRc  
*!*	liPlatform = 0  
*!*	iRc = 0  
*!*	DECLARE INTEGER GetVersionEx IN Win32Api STRING @
*!*	*-- Declare a string to hold the OSVERSIONINFO structure  
*!*	lsOSVersionInfo = LongToStr(148) + SPACE(144)
*!*	iRc = GetVersionEx(@lsOSVersionInfo)
*!*	liPlatform = StrToLong(SUBSTR(lsOSVersionInfo, 17, 4))
*!*	RETURN liPlatform
*!*	ENDPROC  
*!*	 
*!*	*-- The following function converts a long integer to an ASCII  
*!*	*-- character representation of the passed value in low-high format.  
*!*	FUNCTION LongToStr
*!*	* Passed : 32-bit non-negative numeric value (lnLongval)  
*!*	* Returns : ascii character representation of passed value in low-high  
*!*	* format (lcRetstr)  
*!*	* Example :  
*!*	* m.long   = 999999  
*!*	* m.longstr  = long2str(m.long)  
*!*	PARAMETERS lnLongval  
*!*	PRIVATE i, lcRetstr  
*!*	lcRetstr = ""  
*!*	FOR i = 24 TO 0 STEP -8  
*!*		lcRetstr = CHR(INT(lnLongval/(2^i))) + lcRetstr  
*!*		lnLongval = MOD(lnLongval, (2^i))  
*!*	NEXT
*!*	RETURN lcRetstr
*!*	 
*!*	*-- The following function converts a string in low-high format to a long integer.  
*!*	FUNCTION StrToLong  
*!*	* Passed:  4-byte character string (lcLongstr) in low-high ASCII format  
*!*	* Returns:  long integer value  
*!*	* Example:  
*!*	* m.longstr = "1111"  
*!*	* m.longval = str2long(m.longstr)  
*!*	PARAMETERS lcLongstr  
*!*	PRIVATE i, lnRetval  
*!*	lnRetval = 0  
*!*	FOR i = 0 TO 24 STEP 8  
*!*		lnRetval = lnRetval + (ASC(lcLongstr) * (2^i))  
*!*		lcLongstr = RIGHT(lcLongstr, LEN(lcLongstr) - 1)  
*!*	NEXT  
*!*	RETURN lnRetval

ENDPROC
PROCEDURE sleep
* ¿√–”Ã≈Õ“ - œ≈–»Œƒ Œ∆»ƒ¿Õ»ﬂ ¬ Ã»ÀÀ»—≈ ”Õƒ¿’
LPARAMETERS tnTime AS Integer
	IF !THIS.isLoaded("Sleep")
		DECLARE Sleep IN WIN32API INTEGER
	ENDIF

	Sleep(m.tnTime)
ENDPROC
PROCEDURE terminateprocess
* ”¡»¬¿≈Ã œ–Œ÷≈—— œŒ ’›ÕƒÀ” Œ Õ¿
* –≈«”À‹“¿“ : ”—œ≈’  ¿–¿“≈À‹ÕŒ… Œœ≈–¿÷»»
* This.TerminateProcess(GetActiveWindow())
LPARAMETERS tnWindowHandle
LOCAL lnReturn AS Integer, lnProcessId AS Integer
	IF !THIS.isLoaded("GetWindowThreadProcessId")
		DECLARE INTEGER GetWindowThreadProcessId IN WIN32API INTEGER, INTEGER
	ENDIF

	IF !THIS.isLoaded("OpenProcess")
		DECLARE INTEGER OpenProcess IN WIN32API INTEGER, INTEGER,INTEGER
	ENDIF

	IF !THIS.isLoaded("TerminateProcess")
		DECLARE INTEGER TerminateProcess IN WIN32API INTEGER, INTEGER
	ENDIF

	IF !THIS.isLoaded("CloseHandle")
		DECLARE INTEGER CloseHandle	IN WIN32API INTEGER
	ENDIF

	lnReturn = 0
	lnProcessId = 0
	* œŒÀ”◊»Ã ID œ–Œ÷≈——¿ œŒ ’›ÕƒÀ” Œ Õ¿
	GetWindowThreadProcessId(m.tnWindowHandle, @lnProcessId)
	lnProcessHandle = OpenProcess(0xF1, .F., m.lnProcessId)

	IF !EMPTY(m.lnProcessHandle)
		lnReturn = TerminateProcess(m.lnProcessHandle, 0)
		CloseHandle(m.lnProcessHandle)
	ENDIF
RETURN m.lnReturn <> 0

*!*	#DEFINE PROCESS_TERMINATE			0x0001
*!*	#DEFINE PROCESS_CREATE_THREAD		0x0002
*!*	#DEFINE PROCESS_SET_SESSIONID		0x0004
*!*	#DEFINE PROCESS_VM_OPERATION		0x0008
*!*	#DEFINE PROCESS_VM_READ				0x0010
*!*	#DEFINE PROCESS_VM_WRITE			0x0020
*!*	#DEFINE PROCESS_DUP_HANDLE			0x0040
*!*	#DEFINE PROCESS_CREATE_PROCESS		0x0080
*!*	#DEFINE PROCESS_SET_QUOTA			0x0100
*!*	#DEFINE PROCESS_SET_INFORMATION		0x0200
*!*	#DEFINE PROCESS_QUERY_INFORMATION	0x0400
*!*	#DEFINE PROCESS_ALL_ACCESS			0xFFF	&& STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE

ENDPROC
PROCEDURE urldownloadtofile
* ÃŒÀ◊¿ √–”«»Ã ‘¿…À — HTTP-—≈–¬≈–¿ » —Œ’–¿Õﬂ≈Ã ≈√Œ ¬ ÀŒ ¿À‹ÕŒÃ  ¿“¿ÀŒ√≈
* –≈«”À‹“¿“ - ”—œ≈’ Œœ≈–¿÷»»
* This.URLDownloadToFile('http://www.urfin.narod.ru/index.html','c:\util\index.html')
* This.URLDownloadToFile('http://www.cbr.ru/scripts/XML_daily.asp?date_req=02/03/2002', ADDBS(SYS(2023)) + 'course.xml')
LPARAMETERS tcSourceFile AS String, tcTargetFile AS String
	IF !FILE(m.tcTargetFile)
		IF !THIS.isLoaded("URLDownloadToFile")
			DECLARE INTEGER URLDownloadToFile IN URLMON.DLL;
				LONG, STRING, STRING, LONG, LONG
		ENDIF
		*
		URLDownloadToFile(0, m.tcSourceFile, m.tcTargetFile, 0, 0)
		RETURN FILE(m.tcTargetFile)
	ENDIF
RETURN .F.

ENDPROC
PROCEDURE windowfrompoint
* œŒÀ”◊»“‹ ’›ÕƒÀ Œ Õ¿, ¬  ŒŒ–ƒ»Õ¿“¿’ TLLEFT, TLTOP
* P.S.  ŒŒ–ƒ»Õ¿“€ Œ“ÕŒ—»“≈À‹ÕŒ ƒ›— “Œœ¿!
LPARAMETERS tnLeft AS Integer, tnTop AS Integer
LOCAL lnHWnd AS Integer
	IF !THIS.isLoaded("WindowFromPoint")
		DECLARE LONG WindowFromPoint IN WIN32API LONG, LONG
	ENDIF
	*
	lnHWnd=WindowFromPoint(m.tnLeft, m.tnTop)
RETURN m.lnHWnd 
ENDPROC
PROCEDURE winexec
* «¿œ”—“»“‹ œ–»ÀŒ∆≈Õ»≈ WINDOWS » œ–ŒƒŒÀ∆»“‹ –¿¡Œ“” ¡≈« Œ∆»ƒ¿Õ»ﬂ –≈«”À‹“¿“¿
* WinExec('notepad c:/newfile.txt', SW_SHOWMAXIMIZED)
* tnWindowState	- –ÂÊËÏ ÓÍÌ‡ ÔÓˆÂÒÒ‡ (ÒÏ. WinApi.h)
LPARAMETERS tcCommandLine AS String, tnWindowState AS Integer
LOCAL lnError AS Integer
	IF !THIS.isLoaded("WinExec")
		DECLARE INTEGER WinExec IN WIN32API STRING, INTEGER
	ENDIF

	tnWindowState = IIF(VARTYPE(m.tnWindowState) = 'N', m.tnWindowState, SW_SHOWNORMAL)
	lnError = WinExec(m.tcCommandLine, m.tnWindowState)
RETURN This.LocalErrorMessage("WinExec", m.lnError) && 0-31
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*activatewindow 
*beep 
*bitblt 
*blockinput 
*cddoor 
*checkinstance 
*clienttoscreen 
*closehandle 
*colorbitsperpixel 
*colorcombination 
*copyfile 
*createcompatiblebitmap 
*createcompatibledc 
*createdirectory 
*createellipticrgn 
*createmutex 
*createrectrgn 
*createsemaphore 
*deletedc 
*deletefile 
*deleteobject 
*dllregisterserver 
*dllunregisterserver 
*drawicon 
*drawiconresource 
*exitprocess 
*exitwindowsex 
*fatalappexit 
*findwindow 
*flashwindow 
*freelibrary 
*gdicreatebitmap 
*gdicreatepatternbrush 
*gdicreatepen 
*gdigetstockobject 
*gdipatblt 
*gdipdisposeimage 
*gdipgetimageheight 
*gdipgetimagerawformat 
*gdipgetimagewidth 
*gdiploadimagefromfile 
*gdiplusshutdown 
*gdiplusstartup 
*gdirectangle 
*gdisetrop2 
*getapppath 
*getclientrect 
*getcpuspeed 
*getcursorpos 
*getdatetime 
*getdc 
*getdevicecaps 
*getfocus 
*getfolderpath 
*getguid ”ÌËÍ‡Î¸Ì‡ˇ ÒÚÓÍ‡ ‚Ë‰‡ : {96C1E335-B6C2-41C7-9602-295CD99988E3}
*getipaddress 
*getipentries 
*getkeyboardlayoutname 
*getlastactivepopup 
*getlasterror 
*getlogicaldrive 
*getmessagepos 
*getprocaddress 
*getshortfilename 
*getsyscolor 
*getsystemdirectory 
*getsystemmetrics 
*gettempfilename 
*gettemppath 
*gettickcount 
*gettimezoneinformation 
*getuserdefaultlcid ŒÔÂ‰ÂÎËÚ¸ ÎÓÍ‡Î¸ ÔÓÎ¸ÁÓ‚‡ÚÂÎˇ
*getvolumeinformation 
*getwindow 
*getwindowlong 
*getwindowrect 
*getwindowsdirectory 
*globalmemorystatus 
*hideprocess 
*internetgetconnectedstate 
*ischild 
*isloaded œÓ‚ÂÍ‡ Á‡„ÛÁÍË dll
*loadicon 
*loadimage «‡„ÛÊ‡ÂÚ Ù‡ÈÎ ËÍÓÌÍË Í‡Í ÂÒÛÒ WINDOWS
*loadkeyboardlayout 
*loadlibrary 
*loadlibraryex 
*localerrormessage Occurs when the Valid event returns false (.F.), and provides a means to display an error message.
*mcisendstring 
*messagebeep 
*netmessagebuffersend 
*openfile 
*opensemaphore 
*regclosekey 
*regcreatekey 
*regdeletekey 
*regdeletevalue 
*reggetkey 
*regopenkey 
*regsetkey 
*regsvr32 
*releasecapture 
*releasedc 
*releasemutex 
*removedirectory 
*removeicon 
*runprocess 
*selectobject 
*sendmessage 
*setattributes 
*setclasslong 
*setdatetime 
*setfiletime 
*setwindowlong 
*setwindowrgn 
*shellexecute 
*showcursor 
*shutdownwindows 
*sleep 
*terminateprocess 
*urldownloadtofile 
*windowfrompoint 
*winexec 
_memberdata XML Metadata for customizable properties
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\cstwinapi.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\cstwinapi.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
—ËÒÚÂÏÌ˚Â ÙÛÌÍˆËË[END RESERVED7]
[START RESERVED8]
base_app.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] cstwinapi

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM01C8TQ
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] editbar
[START PROPERTIES]
Enabled = .F.
Height = 44
Left = 0
Name = "editbar"
Top = 0
Width = 290
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
10[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM024ZGC
[CLASS] base_separator
[CLASSLOC] base_gui.vcx
[BASECLASS] separator
[OBJNAME] Base_separator1
[PARENT] editbar
[START PROPERTIES]
Height = 0
Left = 88
Name = "Base_separator1"
Top = 3
Width = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM02EDJW
[CLASS] base_separator
[CLASSLOC] base_gui.vcx
[BASECLASS] separator
[OBJNAME] Base_separator2
[PARENT] editbar
[START PROPERTIES]
Height = 0
Left = 209
Name = "Base_separator2"
Top = 3
Width = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM025TSU
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdCopy
[PARENT] editbar
[START PROPERTIES]
Left = 126
Name = "cmdCopy"
Picture = ..\bmp\copy.ico
ToolTipText = "—Óı‡ÌËÚ¸ ‚ ·ÛÙÂ Ó·ÏÂÌ‡"
Top = 3
ZOrderSet = 4
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+C}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM024ZGD
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdCut
[PARENT] editbar
[START PROPERTIES]
Left = 88
Name = "cmdCut"
Picture = ..\bmp\cut.ico
ToolTipText = "—Óı‡ÌËÚ¸ ‚ ·ÛÙÂ Ó·ÏÂÌ‡ Ë Û‰‡ÎËÚ¸"
Top = 3
ZOrderSet = 3
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+X}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM02EDJX
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdFind
[PARENT] editbar
[START PROPERTIES]
Left = 209
Name = "cmdFind"
Picture = ..\bmp\find.ico
ToolTipText = "Õ‡ÈÚË ÚÂÍÒÚ"
Top = 3
ZOrderSet = 7
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+F}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM027JQE
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdPaste
[PARENT] editbar
[START PROPERTIES]
Left = 164
Name = "cmdPaste"
Picture = ..\bmp\paste.ico
ToolTipText = "¬ÒÚ‡‚ËÚ¸ ËÁ ·ÛÙÂ‡ Ó·ÏÂÌ‡"
Top = 3
ZOrderSet = 5
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+V}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM022YEU
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdRedo
[PARENT] editbar
[START PROPERTIES]
Left = 43
Name = "cmdRedo"
Picture = ..\bmp\redo.ico
ToolTipText = "œÓ‚ÚÓËÚ¸ ÔÓÒÎÂ‰ÌÂÂ ‰ÂÈÒÚ‚ËÂ"
Top = 3
ZOrderSet = 1
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+R}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM02EDJY
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdRepl
[PARENT] editbar
[START PROPERTIES]
Left = 247
Name = "cmdRepl"
Picture = ..\bmp\replace.ico
ToolTipText = "Õ‡ÈÚË Ë Á‡ÏÂÌËÚ¸ ÚÂÍcÚ"
Top = 3
ZOrderSet = 8
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+L}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RM01FW5W
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdUndo
[PARENT] editbar
[START PROPERTIES]
Left = 5
Name = "cmdUndo"
Picture = ..\bmp\undo.ico
ToolTipText = "ŒÚÏÂÌËÚ¸ ÔÓÒÎÂ‰ÌÂÂ ‰ÂÈÒÚ‚ËÂ"
Top = 3
ZOrderSet = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
KEYBOARD "{CTRL+Z}"
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] editbar
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1S60CG3CP
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] exitbar
[START PROPERTIES]
Enabled = .F.
Height = 44
Left = 0
Name = "exitbar"
Top = 0
Width = 48
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1S60CH2Y1
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdExit
[PARENT] exitbar
[START PROPERTIES]
Left = 5
Name = "cmdExit"
Picture = ..\bmp\exit.ico
Top = 3
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
CLEAR EVENTS
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] exitbar
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QA0279C8
[CLASS] dialog_form_szgr_2buttons
[CLASSLOC] base_gui.vcx
[BASECLASS] form
[OBJNAME] login_form
[START PROPERTIES]

Caption = "»‰ÂÌÚËÙËÍ‡ˆËˇ ÔÓÎ¸ÁÓ‚‡ÚÂÎˇ"
DataSession = 1
Dialog_shape.Height = 135
Dialog_shape.Left = 3
Dialog_shape.Name = "Dialog_shape"
Dialog_shape.Top = 3
Dialog_shape.Width = 329
DoCreate = .T.
Height = 178
Icon = ..\bmp\keys.ico
Left = 0
Name = "login_form"
OSAVESET_FORM.Name = "OSAVESET_FORM"
Top = 0
Width = 335
WindowState = 1
_memberdata =      924<VFPData><memberdata name="cusername" type="property" display="cUserName"/><memberdata name="cuserpassword" type="property" display="cUserPassword"/><memberdata name="otask" type="property" display="oTask"/><memberdata name="recreateuserlist" type="method" display="recreateUserList"/><memberdata name="otasklist" type="property" display="oTaskList"/><memberdata name="movetocenter" type="Method" favorites="True" display="moveToCenter"/><memberdata name="lpassverification" type="property" display="lPassVerification"/><memberdata name="checkuser" type="method" display="checkUser"/><memberdata name="oapp" type="property" display="oApp"/><memberdata name="odbconnect" type="property" display="oDBConnect"/><memberdata name="lisload" type="property" display="lIsLoad"/><memberdata name="lstorepwd" type="property" display="lStorePwd"/><memberdata name="lstorepassword" type="property" display="lStorePassword"/></VFPData>
cancelbutton.Left = 232
cancelbutton.Name = "cancelbutton"
cancelbutton.TabIndex = 9
cancelbutton.Top = 144
cusername = 
cuserpassword = 
dbcontainer.Name = "dbcontainer"
lisload = .T.
lpassverification = .F.
lstorepassword = .F.
oapp = .NULL.
odbconnect = .NULL.
okbutton.Left = 137
okbutton.Name = "okbutton"
okbutton.TabIndex = 8
okbutton.Top = 144
resizecorner.Image.Height = 16
resizecorner.Image.Name = "Image"
resizecorner.Image.Width = 16
resizecorner.Left = 319
resizecorner.Name = "resizecorner"
resizecorner.Top = 162
resizecorner.resize_timer.Name = "resize_timer"
resizecorner.tmrRefresh.Name = "tmrRefresh"
[END PROPERTIES]
[START PROTECTED]
lisload^
[END PROTECTED]
[START METHODS]
PROCEDURE Activate
DODEFAULT()

IF THIS.lIsLoad
	THIS.WindowState = 0
	THIS.lIsLoad = .F.
ENDIF
ENDPROC
PROCEDURE Init
LPARAMETERS toApp as Object
LOCAL loTask as tasklist OF ..\lib.9\base_app, lnItem as Integer
	DODEFAULT()

	WITH THIS
		.oApp = m.toApp

		IF !ISNULL(m.toApp.oTaskList)
			*ÂÒÎË Á‡‰‡˜‡ ÚÓÎ¸ÍÓ Ó‰Ì‡ Ë ÔÓÎ¸ÁÓ‚‡ÚÂÎÂÈ Û ÌÂÂ ÌÂÚ - ÚÓ ÔÓ·ÛÂÏ Á‡ÎÂÚÂÚ¸ ÏÓÎ˜‡
			lnItem = 0

			WITH .combobox_tasklist
				FOR lnItem = 1 TO m.toApp.oTaskList.Count
					.AddItem(m.toApp.oTaskList.Item[m.lnItem].oVars.cTaskCaption)
					.List[.NewIndex, 2] = m.toApp.oTaskList.Item[m.lnItem].oVars.cTaskName
					.Picture[m.lnItem] = m.toApp.oTaskList.Item[m.lnItem].oVars.cTaskIcon

					IF m.toApp.oTaskList.Item[m.lnItem].oVars.lActive
						.ListIndex = m.lnItem

						.Valid()
					ENDIF
				ENDFOR
			ENDWITH

			IF (.lStorePassword OR (m.toApp.oTaskList.Count = 1 AND .combobox_userlist.ListCount = 0));
				AND	.checkUser()
			ELSE
				.textbox_password.SetFocus()
			ENDIF

			.moveToCenter()
		ENDIF
	ENDWITH
ENDPROC
PROCEDURE cancelbutton.Click
THISFORM.Hide()
NODEFAULT
ENDPROC
PROCEDURE checkuser
#INCLUDE ..\lib.9\base_app.h
WITH THIS
	IF !ISNULL(.oApp.oVars.oCurrentTask) && AND !EMPTY(.cUserName)
		LOCAL loExc as Exception, llres as Logical

		.lPassVerification = .F.

		.oDBConnect = NEWOBJECT("DbConnect", "..\lib.9\base_idb", '', .oApp.oVars.oCurrentTask.oVars.nDBType)
#IF !_DEVELOP_MODE
		TRY
#ENDIF
			.lPassVerification = .oDBConnect.connect(.oApp.oVars.oCurrentTask.oVars.cDBPath,;
												     .oApp.oVars.oCurrentTask.oVars.cDBName,;
												     ALLTRIM(.cUserName),;
												     ALLTRIM(.cUserPassword))
#IF !_DEVELOP_MODE
		CATCH TO loExc
			.oApp.oFunction.showErrMsg(m.loExc)
		ENDTRY
#ENDIF
		IF .lPassVerification
			.oApp.oVars.oCurrentTask.oVars.cUserName = ALLTRIM(.cUserName)
			.oApp.oVars.oCurrentTask.oVars.cUserPassword = ALLTRIM(.cUserPassword)
			.oApp.oVars.oCurrentTask.oVars.lStorePassword = .lStorePassword

			.Hide()
		ELSE
			IF .oDBConnect.getResultCode() = 210
				MESSAGEBOX("œ‡ÓÎ¸ ÌÂ ‚ÂÂÌ!", 16, .oApp.oVars.cTaskCaption)

				THIS.textbox_password.SetFocus()
			ENDIF

			.oDBConnect.Destroy()
			.oDBConnect = .NULL.
		ENDIF
	ENDIF
	
	RETURN .lPassVerification
ENDWITH
ENDPROC
PROCEDURE okbutton.Click
THISFORM.checkUser()
ENDPROC
PROCEDURE recreateuserlist
#INCLUDE ..\lib.9\base_app.h
LPARAMETERS tÒTask as String
	WITH THIS
		IF !EMPTY(m.tÒTask)
			LOCAL lnItem as Integer, lnI as Integer, lcMsg as String,;
				  loDBConnect as DbConnect OF ..\lib.9\base_idb,;
				  loExc as Exception, llres as Logical
			FOR lnI = 1 TO .oApp.oTaskList.Count
				IF .oApp.oTaskList.Item[m.lnI].oVars.cTaskName == m.tÒTask
					CREATE CURSOR USERLIST (FULL_NAME C(50), SYSTEM_NAME C(50))

					.oApp.oVars.oCurrentTask = .oApp.oTaskList.Item[m.lnI]

					loDBConnect = NEWOBJECT("DbConnect", "..\lib.9\base_idb", '',;
											.oApp.oTaskList.Item[m.lnI].oVars.nDBType)

					DO CASE
					CASE .oApp.oTaskList.Item[m.lnI].oVars.nDBType = DB_FoxPro
					CASE .oApp.oTaskList.Item[m.lnI].oVars.nDBType = DB_PostgreSQL
#IF !_DEVELOP_MODE
						TRY
#ENDIF
							llres = m.loDBConnect.connect(.oApp.oTaskList.Item[m.lnI].oVars.cDBPath,;
														  .oApp.oTaskList.Item[m.lnI].oVars.cDBName,;
														  "list_users", "list_users")
							m.loDBConnect.lock()

							IF m.llres
								llres = SQLEXEC(m.loDBConnect.nId_Connection,;
												"SELECT * FROM " + .oApp.oTaskList.Item[m.lnI].oVars.cDBSchema;
												+ ".get_list_users()", "USERLIST")

								IF m.llres = -1
									LOCAL ARRAY laResult[1]
									AERROR(laResult)

									lcMsg = "Don't receive users list from server ";
											+ .oApp.oTaskList.Item[m.lnI].oVars.cDBPath + "!" + CRLF;
											+ laResult[2]

									THIS.oApp.showMsg(m.lcMsg)
									MESSAGEBOX(m.lcMsg, 16, .oApp.oTaskList.Item[m.lnI].oVars.cTaskCaption)
								ENDIF
							ENDIF

							m.loDBConnect.unLock()
#IF !_DEVELOP_MODE
						CATCH TO loExc
							.oApp.oFunction.showErrMsg(m.loExc)
						ENDTRY
#ENDIF
						RELEASE m.loDBConnect
					CASE .oApp.oTaskList.Item[m.lnI].oVars.nDBType = DB_MSSQL
					CASE .oApp.oTaskList.Item[m.lnI].oVars.nDBType = DB_Oracle
					CASE .oApp.oTaskList.Item[m.lnI].oVars.nDBType = DB_Access
						.combobox_userlist.Style = 0
						
						IF !EMPTY(.oApp.oTaskList.Item[m.lnI].oVars.cUserName)
							INSERT INTO USERLIST (FULL_NAME, SYSTEM_NAME);
										  VALUES (.oApp.oTaskList.Item[m.lnI].oVars.cUserName,;
										  		  .oApp.oTaskList.Item[m.lnI].oVars.cUserName)
						ENDIF
					OTHERWISE
					ENDCASE

					.cUserName = .oApp.oTaskList.Item[m.lnI].oVars.cUserName
					.lStorePassword = .oApp.oTaskList.Item[m.lnI].oVars.lStorePassword

					WITH .Combobox_UserList
						lnItem = 0
						.Clear()

						IF USED("USERLIST")
							SELECT USERLIST

							SCAN
								lnItem = m.lnItem + 1

								.AddItem(ALLTRIM(FULL_NAME))
								.List[.NewIndex, 2] = ALLTRIM(SYSTEM_NAME)
								.Picture[m.lnItem] = "..\bmp\16x16\user1.bmp"

								IF THIS.oApp.oTaskList.Item[m.lnI].oVars.cUserName == ALLTRIM(SYSTEM_NAME)
									.ListIndex = m.lnItem
					
									IF THIS.lStorePassword
										THIS.cUserPassword = THIS.oApp.oTaskList.Item[m.lnI].oVars.cUserPassword
									ENDIF
								ENDIF
							ENDSCAN

							USE
						ENDIF
					ENDWITH	

					EXIT
				ENDIF
			ENDFOR
		ELSE
			THIS.Combobox_UserList.Clear()
		ENDIF
	ENDWITH
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
8[END RESERVED2]
[START RESERVED3]
*checkuser 
*recreateuserlist 
cusername
cuserpassword
lisload œËÁÌ‡Í Á‡Í„ÛÁÍË ‚ÔÂ‚˚È ‡Á
lpassverification
lstorepassword
oapp
odbconnect
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\user1.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\user1.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
base_idb.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _20N19OC7R
[CLASS] base_checkbox
[CLASSLOC] base_gui.vcx
[BASECLASS] checkbox
[OBJNAME] checkbox_StorePwd
[PARENT] login_form
[START PROPERTIES]
Alignment = 0
Caption = "—Óı‡ÌˇÚ¸ Ô‡ÓÎ¸"
ControlSource = "THISFORM.lStorePassword"
FontBold = .T.
Left = 150
Name = "checkbox_StorePwd"
ToolTipText = "—Óı‡ÌˇÚ¸ Ô‡ÓÎ¸"
Top = 112
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QC0CCS8M
[CLASS] base_combobox
[CLASSLOC] base_gui.vcx
[BASECLASS] combobox
[OBJNAME] combobox_tasklist
[PARENT] login_form
[START PROPERTIES]
BoundColumn = 2
BoundTo = .T.
ColumnCount = 1
Height = 24
Left = 150
Name = "combobox_tasklist"
StatusBarText = "¬˚·ÂËÚÂ Á‡‰‡˜Û"
Style = 2
TabIndex = 3
ToolTipText = "¬˚·ÂËÚÂ Á‡‰‡˜Û"
Top = 14
Width = 168
[END PROPERTIES]
[START METHODS]
PROCEDURE Valid
THISFORM.recreateUserList(THIS.Value)
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QA02R7QW
[CLASS] base_combobox
[CLASSLOC] base_gui.vcx
[BASECLASS] combobox
[OBJNAME] combobox_userlist
[PARENT] login_form
[START PROPERTIES]
BoundColumn = 2
BoundTo = .T.
ColumnCount = 1
Height = 24
Left = 150
Name = "combobox_userlist"
StatusBarText = "¬˚·ÂËÚÂ ÔÓÎ¸ÁÓ‚‡ÚÂÎˇ"
Style = 2
TabIndex = 5
ToolTipText = "¬˚·ÂËÚÂ ÔÓÎ¸ÁÓ‚‡ÚÂÎˇ"
Top = 49
Width = 168
[END PROPERTIES]
[START METHODS]
PROCEDURE Valid
THISFORM.cUserName = ALLTRIM(IIF(EMPTY(THIS.Text), THIS.Value, THIS.Text))
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QA02R7QX
[CLASS] base_label
[CLASSLOC] base_gui.vcx
[BASECLASS] label
[OBJNAME] label_password
[PARENT] login_form
[START PROPERTIES]
BackStyle = 0
Caption = "œ‡ÓÎ¸ ÔÓÎ¸ÁÓ‚‡ÚÂÎˇ:"
FontBold = .T.
Height = 15
Left = 14
Name = "label_password"
TabIndex = 6
Top = 87
Width = 135
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QC0CCS8L
[CLASS] base_label
[CLASSLOC] base_gui.vcx
[BASECLASS] label
[OBJNAME] label_tasklist
[PARENT] login_form
[START PROPERTIES]
BackStyle = 0
Caption = "Õ‡Á‚‡ÌËÂ Á‡‰‡˜Ë:"
FontBold = .T.
Height = 15
Left = 41
Name = "label_tasklist"
TabIndex = 2
Top = 18
Width = 107
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QA0279C8
[CLASS] base_label
[CLASSLOC] base_gui.vcx
[BASECLASS] label
[OBJNAME] label_user
[PARENT] login_form
[START PROPERTIES]
BackStyle = 0
Caption = "»Ïˇ ÔÓÎ¸ÁÓ‚‡ÚÂÎˇ:"
FontBold = .T.
Height = 15
Left = 32
Name = "label_user"
TabIndex = 4
Top = 53
Width = 116
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QA02SJ7J
[CLASS] base_textbox
[CLASSLOC] base_gui.vcx
[BASECLASS] textbox
[OBJNAME] textbox_password
[PARENT] login_form
[START PROPERTIES]
Anchor = 6
ControlSource = "THISFORM.cUserPassword"
Height = 21
Left = 150
Name = "textbox_password"
PasswordChar = "*"
SelectOnEntry = .T.
StatusBarText = "¬‚Â‰ËÚÂ Ô‡ÓÎ¸"
TabIndex = 7
ToolTipText = "¬‚Â‰ËÚÂ Ô‡ÓÎ¸"
Top = 84
Width = 168
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] login_form
[START PROPERTIES]
Courier New, 0, 8, 7, 14, 11, 7, 3, 0
MS Sans Serif, 0, 8, 5, 13, 11, 11, 2, 0
MS Sans Serif, 1, 8, 6, 13, 11, 12, 2, 0
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1NJ0UL9NO
[CLASS] optionbutton
[BASECLASS] optionbutton
[OBJNAME] op_window
[START PROPERTIES]

Caption = "WindowCaption"
FontName = "Microsoft Sans Serif"
FontSize = 8
Height = 22
Name = "op_window"
Picture = ..\bmp\16x16\view_text.png
PicturePosition = 2
SpecialEffect = 2
Style = 1
Width = 150
_memberdata =      547<VFPData><memberdata name="formname" type="property" display="formName"/><memberdata name="formcaption" type="property" display="formCaption"/><memberdata name="formshortcaption" type="property" display="formShortCaption"/><memberdata name="formhwnd" type="property" display="formHWnd"/><memberdata name="ctempimage" type="property" display="cTempImage"/><memberdata name="ctempscreenimage" type="property" display="cTempScreenImage"/><memberdata name="contextmenuselectionhandler" type="method" display="contextMenuSelectionHandler"/></VFPData>
ctempicon = 
ctempimage = 
formcaption = 
formhwnd = 0
formname = 
formshortcaption = 
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
LOCAL loForm as Form
	FOR EACH loForm IN m.goApp.oApp_Collection
		IF m.loForm.hWnd = THIS.formHWnd
			IF THIS.Parent.Parent.Parent.lHideOnClickIfActive
				m.loForm.Hide()
				loForm.WindowState = 0

				EXIT 
			ENDIF 

			IF m.loForm.WindowState = 1
				loForm.WindowState = 0
			ENDIF

			IF TYPE("m.loForm.ActiveControl") = 'O'
				IF PEMSTATUS(m.loForm.ActiveControl, "SetFocus", 5)
					m.loform.Activecontrol.Setfocus()
				ENDIF
			ELSE
				m.loForm.Show()
			ENDIF

			EXIT
		ENDIF
	ENDFOR

	THIS.Value = 1
ENDPROC
PROCEDURE DblClick
THIS.Click()
ENDPROC
PROCEDURE Destroy
oTaskbarButton_1NT0UWKRF = .NULL.

IF !EMPTY(THIS.cTempImage)
	THIS.Picture = ''

	CLEAR RESOURCES (THIS.cTempImage)
	ERASE (THIS.cTempImage)
ENDIF
ENDPROC
PROCEDURE Init
THIS.Height = TSKB_BTN_HEIGHT
THIS.Width = TSKB_BTN_MAXWIDTH
THIS.FontName = TSKB_FONTNAME
THIS.FontSize = TSKB_FONTSIZE
THIS.FontBold = TSKB_FONTBOLD
ENDPROC
PROCEDURE RightClick
LOCAL loForm as Form, llModalWindow as Logical, lnRow as Integer, lnCol as Integer
	FOR EACH loForm IN _Screen.Forms
		IF VARTYPE(m.loForm.WindowType) = "N" 
			IF m.loForm.WindowType = 1
				llModalWindow = .T.
				EXIT
			ENDIF 
		ENDIF
	ENDFOR

	IF m.llModalWindow
		*modal form active, nothing to do
		RETURN 
	ENDIF 

	FOR EACH loForm IN _Screen.Forms
		IF m.loForm.hWnd = THIS.formHWnd
			EXIT
		ENDIF
	ENDFOR
	*set a public variable to handle context menu click
	IF TYPE("oTaskbarButton_1NT0UWKRF") = 'U'
		PUBLIC oTaskbarButton_1NT0UWKRF 
		oTaskbarButton_1NT0UWKRF = THIS 
	ELSE
		oTaskbarButton_1NT0UWKRF = THIS 
	ENDIF

	lnRow = m.goApp.oFunction.pixeltoFoxel(m.goApp.oWinApi.getCursorPos(.T.), .T.)
	lnCol = m.goApp.oFunction.pixeltoFoxel(m.goApp.oWinApi.getCursorPos(.F.), .F.)

	DEFINE POPUP context SHORTCUT RELATIVE FROM m.lnRow, m.lnCol IN SCREEN

	ACTIVATE WINDOW (m.loForm.Name) TOP

	IF m.loForm.WindowState <> 0 OR (m.loForm.WindowState = 0 AND m.loForm.Visible = .F.)
		DEFINE BAR 1 OF context PROMPT CNT_MENU_RESTORE
	ELSE
		DEFINE BAR 1 OF context PROMPT '\' + CNT_MENU_RESTORE
	ENDIF

	IF m.loForm.WindowState <> 1 AND m.loForm.Visible = .T.
		DEFINE BAR 2 OF context PROMPT CNT_MENU_MINIMIZE
	ELSE
		DEFINE BAR 2 OF context PROMPT '\' + CNT_MENU_MINIMIZE
	ENDIF

	IF m.loForm.WindowState <> 2
		DEFINE BAR 3 OF context PROMPT CNT_MENU_MAXIMIZE
	ELSE
		DEFINE BAR 3 OF context PROMPT '\' + CNT_MENU_MAXIMIZE
	ENDIF

	DEFINE BAR 4 OF context PROMPT '\-'
	DEFINE BAR 5 OF context PROMPT CNT_MENU_CLOSE

	ON SELECTION POPUP context oTaskbarButton_1NT0UWKRF.contextMenuSelectionHandler(BAR())
	ACTIVATE POPUP context

	oTaskbarButton_1NT0UWKRF = .NULL.
ENDPROC
PROCEDURE contextmenuselectionhandler
LPARAMETERS tnBar as Integer
LOCAL loForm as Form
	FOR EACH loForm IN _Screen.Forms
		IF m.loForm.hWnd = THIS.formHWnd
			DO CASE
			CASE m.tnBar = 1
				loForm.WindowState = 0
				m.loForm.Show() 
			CASE m.tnBar = 2
				IF THIS.Parent.Parent.Parent.lHideFormOnMinimize
					m.loForm.Hide()
					loForm.WindowState = 0
				ELSE 
					loForm.WindowState = 1
				ENDIF 
			CASE m.tnBar = 3
				loForm.WindowState = 2

				IF m.loForm.Visible = .F.
					m.loForm.Show()
				ENDIF 
			CASE m.tnBar = 5
				m.loForm.Release()
			ENDCASE 
			EXIT
		ENDIF  
	ENDFOR

	oTaskbarButton_1NT0UWKRF = .NULL.
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*contextmenuselectionhandler 
_memberdata XML Metadata for customizable properties
ctempicon temporary icon, used to create a temporary bitmap used for button
ctempimage temporary image used to store form icon converted to 16x16 bitmap
formcaption assigned form caption
formhwnd assigned form hWnd
formname name of the form
formshortcaption if the form has shortCaption property, use this instead of normal caption
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
taskbar.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] op_window
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RL10TC0Y
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] servicebar
[START PROPERTIES]
Caption = "Servicebar"
Enabled = .F.
Height = 44
Left = 0
Name = "servicebar"
Top = 0
Width = 131
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
5[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RL13ULZ4
[CLASS] base_separator
[CLASSLOC] base_gui.vcx
[BASECLASS] separator
[OBJNAME] Base_separator1
[PARENT] servicebar
[START PROPERTIES]
Height = 0
Left = 50
Name = "Base_separator1"
Top = 3
Width = 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RL12MFAF
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdCalendar
[PARENT] servicebar
[START PROPERTIES]
Left = 50
Name = "cmdCalendar"
Picture = ..\bmp\calendar.ico
ToolTipText = " ‡ÎÂÌ‰‡¸"
Top = 3
ZOrderSet = 2
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
m.goApp.OnMenuEvents("Calendar")
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RL11RB3B
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdClock
[PARENT] servicebar
[START PROPERTIES]
Left = 88
Name = "cmdClock"
Picture = ..\bmp\clock.ico
ToolTipText = "◊‡Ò˚"
Top = 3
ZOrderSet = 3
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
m.goApp.OnMenuEvents("Clock")
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1RL13ULZ5
[CLASS] barbutton
[CLASSLOC] base_gui.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdWorkInterval
[PARENT] servicebar
[START PROPERTIES]
Left = 5
Name = "cmdWorkInterval"
Picture = ..\bmp\data_time.ico
ToolTipText = "–‡·Ó˜ËÈ ÔÂËÓ‰"
Top = 3
ZOrderSet = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
m.goApp.goForm("Select_period", 0, .NULL., .NULL.)
*!*	m.goApp.goForm("FORMS\Select_period", 0, .NULL., .NULL.)
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] servicebar
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q509URR2
[CLASS] base_toolbar
[CLASSLOC] base_gui.vcx
[BASECLASS] toolbar
[OBJNAME] taskbar
[START PROPERTIES]

Height = 28
Left = 0
Name = "taskbar"
Top = 0
Width = 210
_memberdata =     1923<VFPData><memberdata name="addactiveforms" type="method" display="addActiveForms"/><memberdata name="addformbutton" type="method" display="addFormButton"/><memberdata name="removeformbutton" type="method" display="removeFormButton"/><memberdata name="orderbuttons" type="method" display="orderButtons"/><memberdata name="ncurrentline" type="property" display="nCurrentLine"/><memberdata name="resizetaskbar" type="method" display="resizeTaskBar"/><memberdata name="nextrawidth" type="property" display="nExtraWidth"/><memberdata name="setbuttonpicture" type="method" display="setButtonPicture"/><memberdata name="setbuttonwidthandcaption" type="method" display="setButtonWidthAndCaption"/><memberdata name="activateformbutton" type="method" display="activateFormButton"/><memberdata name="singleline" type="property" display="singleLine"/><memberdata name="nlinecount" type="property" display="nLineCount"/><memberdata name="nmaxbuttonwidth" type="property" display="nMaxButtonWidth"/><memberdata name="nminbuttonwidth" type="property" display="nMinButtonWidth"/><memberdata name="nscrollbarwidth" type="property" display="nScrollBarWidth"/><memberdata name="otoplevelform" type="property" display="oToplevelForm"/><memberdata name="singleline_assign" type="method" display="singleLine_Assign"/><memberdata name="gettoplevelform" type="method" display="getToplevelForm"/><memberdata name="checkresizebinding" type="method" display="checkResizeBinding"/><memberdata name="nscrollbarheight" type="property" display="nScrollbarHeight"/><memberdata name="coldcursor" type="property" display="cOldCursor"/><memberdata name="nextraheight" type="property" display="nExtraHeight"/><memberdata name="captionassignhandler" type="method" display="captionAssignHandler"/><memberdata name="deactivatehandler" type="method" display="deactivateHandler"/><memberdata name="resizehandler" type="method" display="resizeHandler"/></VFPData>
coldcursor = 
lhideformonminimaze = .F.
lhideonclickifactive = .F.
lresizebinding = .F.
ncurrentline = 1
nextraheight = 0
nextrawidth = 0
nlinecount = 0
nmaxbuttonwidth = 200
nminbuttonwidth = 100
nscrollbarheight = 0
nscrollbarwidth = 0
oimage = .NULL.
otoplevelform = .NULL.
singleline = .F.
[END PROPERTIES]
[START METHODS]
PROCEDURE AfterDock
THIS.resizeTaskbar()
ENDPROC
PROCEDURE DblClick
NODEFAULT
ENDPROC
PROCEDURE Init
THIS.cnt_windows.Height=0
THIS.nScrollbarWidth = SYSMETRIC(5)
THIS.nScrollbarHeight = SYSMETRIC(6)
THIS.oTopLevelForm = THIS.getTopLevelForm()
*gpImage instance used to convert icon to PNG
THIS.oImage = NEWOBJECT("gpImage", "_gdiplus.vcx")
*!*	*bind host resize if not already 
*!*	IF THIS.checkResizeBinding()
*!*		THIS.lResizeBinding = .T.
*!*		BINDEVENT(THIS.oTopLevelForm, "Resize", THIS, "ResizeTaskbar")
*!*	ENDIF

THIS.Tag = "init"
THIS.resizeTaskbar()
THIS.Tag = ''
*loop through _screen.Forms collection and buttons for them
THIS.addActiveForms()

THIS.Dock(3, 0, 0)

IF THIS.cnt_windows.opg_windows.ButtonCount > 0
	THIS.Show()
ENDIF
ENDPROC
PROCEDURE Show
LPARAMETERS tnStyle
	*requires some buttons to be made visible
	IF THIS.cnt_windows.opg_windows.ButtonCount = 0
		NODEFAULT 
	ELSE 
		DODEFAULT(m.tnStyle)
	ENDIF
ENDPROC
PROCEDURE activateformbutton
LPARAMETERS tHWnd as Integer
*delegate to be executed when a form is activated
*simulate a click on the form associated button
LOCAL loButton as Object
	THIS.cnt_windows.opg_windows.SetAll("Value", 0)

	FOR EACH loButton IN THIS.cnt_windows.opg_windows.Buttons
		IF m.loButton.formhWnd = m.thWnd
			loButton.Value = 1
			EXIT
		ENDIF
	ENDFOR
ENDPROC
PROCEDURE addactiveforms
LOCAL loForm as Form
	IF VARTYPE(m.goApp) = 'O' AND !ISNULL(m.goApp)
		FOR EACH loForm IN m.goApp.oApp_Collection
			IF !EMPTY(m.loForm.Caption) AND m.loForm.BaseClass == "Form"
				THIS.AddFormButton(m.loForm)
			ENDIF 
		ENDFOR
	ENDIF
ENDPROC
PROCEDURE addformbutton
LPARAMETERS toForm as Form
LOCAL lcName, loButton, llAddFormOK
	IF !UPPER(JUSTFNAME(THIS.ClassLibrary)) $ UPPER(SET("Classlib"))
		SET CLASSLIB TO (THIS.ClassLibrary) ADDITIVE 
	ENDIF 
	*first, scan forms collection to see if hWnd is from some active form
	llAddFormOK = .T.

	FOR EACH loButton IN THIS.cnt_windows.opg_windows.Buttons
		IF m.loButton.formHWnd = m.toForm.HWnd
			llAddFormOk = .F.
			EXIT
		ENDIF 
	ENDFOR 

	IF m.llAddFormOK
		lcName = "hWnd" + TRANSFORM(m.toForm.hWnd)
		THIS.cnt_windows.opg_windows.AddObject(m.lcName, "op_window")
		loButton = EVALUATE("THIS.cnt_WINDOWS.opg_windows." + m.lcName)

		WITH m.loButton as op_window
			.formHWnd = m.toForm.HWnd
			.formName = m.toForm.Name

			IF TYPE("m.toForm.shortCaption") = 'C'
				.formShortCaption = m.toForm.shortCaption
			ENDIF

			.formCaption = m.toForm.Caption
			.ToolTipText = m.toForm.Caption
			THIS.setButtonWidthAndCaption(m.loButton)
			THIS.setButtonPicture(m.loButton, m.toForm)
		ENDWITH
		*loop through buttons and add new lines and spinner if necessary
		THIS.orderButtons()

		THIS.activateFormButton(m.toForm.HWnd)
	ENDIF
ENDPROC
PROCEDURE captionassignhandler
LPARAMETERS toForm as Form
LOCAL loButton as Object, llisFound as Logical
	THIS.cnt_windows.opg_windows.SetAll("Value", 0)

	FOR EACH loButton IN THIS.cnt_windows.opg_windows.Buttons
		IF m.loButton.FormHWnd = m.toForm.HWnd
			llisFound = .t.
			EXIT
		ENDIF
	ENDFOR

	IF m.llisFound  
		loButton.FormHWnd = m.toForm.HWnd
		loButton.FormName = m.toForm.Name

		IF TYPE("m.toForm.shortCaption") = 'C'
			loButton.FormShortCaption = m.toForm.ShortCaption
		ENDIF

		loButton.FormCaption = m.toForm.Caption
		loButton.ToolTipText = m.toForm.Caption

		THIS.oTopLevelForm.LockScreen = .T.

		THIS.setButtonWidthAndCaption(m.loButton)
		THIS.orderButtons()

		THIS.oTopLevelForm.LockScreen = .F.
	ENDIF
ENDPROC
PROCEDURE checkresizebinding
LOCAL ARRAY laEv[1]
LOCAL lnEvCount, llOK
	llOK = .T.
	lnEvCount = AEVENTS(laEv, THIS.oTopLevelForm)

	IF m.lnEvCount > 0
		IF ASCAN(laEv, "RESIZETASKBAR") > 0
			llOk = .F.
		ENDIF
	ENDIF
RETURN m.llOK
ENDPROC
PROCEDURE deactivatehandler
LPARAMETERS tHWnd as Integer
*delegate to be executed when a form is deactivated
*check associated button
LOCAL loButton as Object
*!*		*hide minimized forms if needed
*!*		IF laEv[1].WindowState = 1 AND THIS.lHideFormOnMinimize AND laEv[1].Visible = .T.
*!*			laEv[1].Hide()
*!*			*avoid bug with minimized invisible forms, ghost context menu appear, so restore to normal state
*!*			laEv[1].WindowState = 0
*!*		ENDIF 
	FOR EACH loButton IN THIS.cnt_windows.opg_windows.Buttons 
		IF m.loButton.formhWnd = m.tHWnd
			loButton.Value = 0
		ENDIF 
	ENDFOR
ENDPROC
PROCEDURE gettoplevelform
	*from Foundation Classes "_ui.vcx"
	ASSERT TYPE("_SCREEN.ActiveForm") <> "O" OR INLIST(_SCREEN.ActiveForm.ShowWindow, 0, 1, 2)

	DO CASE
	CASE _SCREEN.FormCount = 0 OR (TYPE("_SCREEN.ActiveForm") = "O" AND _SCREEN.ActiveForm.ShowWindow = 0)     && ShowWindow In Screen
	    loTopForm = _SCREEN
	CASE (TYPE("_SCREEN.ActiveForm") = "O" AND _SCREEN.ActiveForm.ShowWindow = 2)    && ShowWindow As Top Form
	    loTopForm = _SCREEN.ActiveForm
	OTHERWISE
	    FOR EACH loForm IN _SCREEN.Forms  && note: these may be toolbars
	                                       && if undocked, but that's okay --
	                                       && they are only ShowWIndow 0 or 1.
	       	IF m.loForm.ShowWindow = 2 && the first one in the collection will
	                               && be "active top form"
	          	loTopForm = m.loForm
	    		EXIT
	    	ENDIF
	    ENDFOR

	    IF VARTYPE(m.loTopForm) <> "O"
	    	loTopForm = _SCREEN
	    ENDIF
	ENDCASE
RETURN m.loTopForm
ENDPROC
PROCEDURE orderbuttons
*loop through buttons and order them after a new one added or width changes. 
LOCAL loButton, lnLeft, lnTop, lnI, lnTotalWidth, lnCurrentLine, lnLineCount
	STORE 0 TO lnLeft, lnTop, lnTotalWidth
	STORE 1 TO lnCurrentLine, lnLineCount

	WITH THIS.cnt_windows.opg_windows
		FOR lnI = 1 to .ButtonCount 
			IF m.lnTotalWidth+.Buttons[m.lnI].Width > .Width
				lnLineCount = m.lnLineCount + 1
				lnTotalWidth = 0
				lnTop = (m.lnLineCount - 1) * TSKB_BTN_HEIGHT +(m.lnLinecount - 1)
			ENDIF

			lnLeft = m.lnTotalWidth
			lnTotalWidth = m.lnTotalWidth+.Buttons[m.lnI].Width + 1

			IF !.Buttons[m.lnI].Top = m.lnTop
				.Buttons[m.lnI].Top = m.lnTop
			ENDIF

			IF !.Buttons[m.lnI].Left = m.lnLeft
				.Buttons[m.lnI].Left = m.lnLeft
			ENDIF
		ENDFOR

		IF INLIST(THIS.DockPosition, -1, 0, 3)
			IF m.lnLineCount > 1
				IF .Height <> (m.lnLineCount - 1) * (1 + TSKB_BTN_HEIGHT)
					.Height = (m.lnLineCount - 1) * (1 + TSKB_BTN_HEIGHT)
				ENDIF
			ELSE
				IF .Height <> TSKB_BTN_HEIGHT
					.Height = TSKB_BTN_HEIGHT
				ENDIF
			ENDIF
		ENDIF

		.SetAll("Visible", .T.)

		IF THIS.singleLine
			IF THIS.cnt_windows.Height <> TSKB_BTN_HEIGHT 
				THIS.cnt_windows.Height = TSKB_BTN_HEIGHT 
			ENDIF
			*set option group line count, for spinner 
			THIS.nLineCount = m.lnLinecount
			*set max value for the spinner
			THIS.cnt_windows.spnActiveLine.SpinnerHighValue = m.lnLinecount
			THIS.cnt_windows.spnActiveLine.KeyboardHighValue = m.lnLinecount
			*if opg has many lines, set top property
			* only .nCurrentLine will be visible
			IF m.lnLinecount > 1
				IF .Top <> -((.nCurrentLine - 1) * TSKB_BTN_HEIGHT + (THIS.nCurrentLine - 1))
					.Top = -((.nCurrentLine - 1) * TSKB_BTN_HEIGHT + (THIS.nCurrentLine - 1))
				ENDIF

				.Parent.spnActiveLine.Visible = .T.
				.ToolTipText = "Line " + TRANSFORM(THIS.nCurrentLine) + " / " + TRANSFORM(THIS.nLineCount)
				.Parent.spnActiveLine.ToolTipText = .ToolTipText
			ELSE
				IF .Top <> 0
					.Top = 0
				ENDIF

				.Parent.spnActiveLine.Visible = .F.
				.ToolTipText = ''
			ENDIF
		ELSE
			IF THIS.cnt_windows.Height <> .Height AND INLIST(THIS.DockPosition, -1, 0, 3)
				THIS.cnt_windows.Height = .Height
			ENDIF

			.Parent.spnActiveLine.Visible = .F.
			.ToolTipText = ''
		ENDIF  
	ENDWITH 

	IF THIS.cnt_windows.opg_windows.ButtonCount = 0
		THIS.Hide()
	ELSE
		THIS.Show()
	ENDIF
ENDPROC
PROCEDURE removeformbutton
LPARAMETERS thWnd as Integer
LOCAL lcName, lcObject
	lcName = "hwnd" + TRANSFORM(m.thWnd)
	lcObject = "THIS.cnt_windows.opg_windows." + m.lcName

	IF TYPE(m.lcObject) = 'O'
		 THIS.cnt_windows.opg_windows.RemoveObject(m.lcName)
		 THIS.orderButtons() 
	ENDIF
ENDPROC
PROCEDURE resizehandler
*added 2005.11.13
*delegate to be executed when a form is resized
*only needed to hide the last form minimized, Deactivate doesn't fire
LOCAL ARRAY laEv[1]
LOCAL lhWnd as Integer
	AEVENTS(laEv, 0)

	IF UPPER(laEv[2]) = "RESIZE" AND laEv[3] = 0
		lhWnd = laEv[1].hWnd
		*hide minimized forms if needed, but restore to normal state, bug workaround
		IF laEv[1].WindowState = 1 AND THIS.lHideFormOnMinimize &&AND laEv[1].Visible = .t.
			laEv[1].Hide()
			laEv[1].WindowState = 0
		ENDIF 
	ENDIF
ENDPROC
PROCEDURE resizetaskbar
*temporary unbind host resize event 
*!*	UNBINDEVENT(THIS.oTopLevelForm, "Resize", THIS, "ResizeTaskbar")

THIS.oTopLevelForm.LockScreen = .T.

DO CASE
CASE INLIST(THIS.DockPosition, -1, 0, 3)
*‚Âı, ÌËÁ
	THIS.Left = 0
	THIS.cnt_windows.Width = THIS.oTopLevelForm.Width - (THIS.nScrollbarWidth + 1) + THIS.nExtraWidth
CASE INLIST(THIS.DockPosition, 1, 2)
*Ô‡‚Ó, ÎÂ‚Ó
	THIS.Top = 0
	THIS.SingleLine = .F.
	THIS.cnt_windows.Width = THIS.nMaxButtonWidth + THIS.nExtraWidth
	THIS.cnt_windows.Height = THIS.oTopLevelForm.Height - (THIS.nScrollbarHeight + 1) + THIS.nExtraHeight
ENDCASE

IF !THIS.Tag == "init"
	FOR EACH loButton IN THIS.cnt_windows.opg_windows.Buttons
		THIS.setButtonWidthAndCaption(m.loButton)
	ENDFOR 

	THIS.orderButtons()
	THIS.Tag = ''
ENDIF

THIS.oTopLevelForm.LockScreen = .F.
*!*	BINDEVENT(THIS.oTopLevelForm, "Resize", THIS, "ResizeTaskbar")
ENDPROC
PROCEDURE setbuttonpicture
LPARAMETERS toButton, toForm as Form
LOCAL lcTempIcon, lcImage, loThumb as gpimage OF _gdiplus.vcx
	IF EMPTY(m.toForm.Icon) OR !FILE(m.toForm.Icon)
		RETURN 
	ENDIF 

	lcImage = SYS(2015)
	lcTempIcon = SYS(2023) + '\' + m.lcImage + ".ico"
	*STRTOFILE(FILETOSTR)) is used because icons can be embedded in EXE and the 
	*gdi+ class needs to locate files on disk
	IF STRTOFILE(FILETOSTR(m.toForm.Icon), m.lcTempIcon) > 0
		IF THIS.oImage.CreateFromFile(m.lcTempIcon)
			loThumb = THIS.oImage.GetThumbnailImage(m.toButton.Height - 6, m.toButton.Height - 6)
			toButton.cTempImage = SYS(2023) + '\' + m.lcImage + ".tif"

			IF loThumb.SaveToFile(m.toButton.cTempImage, "image/tiff")
				*save successful, hadle transparency issues by creating an image control
				toButton.Picture = m.toButton.cTempImage
				toButton.cTempIcon = m.lcTempIcon
			ENDIF
		ENDIF
		*free icon file hadle, we need to delete it
		THIS.oImage.Destroy()
		loThumb.Destroy()

		ERASE (m.lcTempIcon)
	ENDIF
ENDPROC
PROCEDURE setbuttonwidthandcaption
LPARAMETERS toButton
LOCAL lcCaption, lcCaptionVar, lni, lnwidth
	lcCaption = ALLTRIM(IIF(EMPTY(m.toButton.formShortCaption), m.toButton.formCaption, m.toButton.formShortCaption))
	toButton.Caption = m.lcCaption

	lnwidth = TXTWIDTH(m.lcCaption, m.toButton.FontName,;
				  	   m.toButton.FontSize,;
					   IIF(m.toButton.FontBold, 'B', ''));
			  * FONTMETRIC(6, m.toButton.FontName,;
					       m.toButton.FontSize,;
					       IIF(m.toButton.FontBold, 'B', '')) + 24

	DO CASE
	CASE m.lnwidth > m.toButton.Parent.Parent.Parent.nMaxButtonWidth	&&exceed max button width limit
		FOR lni = LEN(m.lcCaption) TO 0 STEP -1
			lcCaptionVar = LEFT(m.lcCaption, m.lni) + "..."
			lnwidth = TXTWIDTH(m.lcCaptionVar, m.toButton.FontName,;
							   m.toButton.FontSize,;
							   IIF(m.toButton.FontBold, 'B', ''));
					  * FONTMETRIC(6, m.toButton.FontName,;
							     m.toButton.FontSize,;
							     IIF(m.toButton.FontBold, 'B', '')) + 24

			IF m.lnwidth <= m.toButton.Parent.Parent.Parent.nMaxButtonWidth
				toButton.Caption = m.lcCaptionVar
				EXIT
			ENDIF
		ENDFOR
	CASE m.lnwidth <= m.toButton.Parent.Parent.Parent.nMinButtonWidth
		lnwidth = m.toButton.Parent.Parent.Parent.nMinButtonWidth
	ENDCASE

	toButton.Width = IIF(INLIST(THIS.DockPosition, 1, 2), m.toButton.Parent.Parent.Parent.nMaxButtonWidth, m.lnwidth)

	m.toButton.Refresh()
ENDPROC
PROCEDURE singleline_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
	IF THIS.SingleLine <> m.vNewVal
		THIS.SingleLine = m.vNewVal
		THIS.orderButtons() 
	ENDIF
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
4[END RESERVED2]
[START RESERVED3]
*activateformbutton 
*addactiveforms 
*addformbutton 
*captionassignhandler 
*checkresizebinding 
*deactivatehandler 
*gettoplevelform 
*orderbuttons 
*removeformbutton 
*resizehandler 
*resizetaskbar 
*setbuttonpicture 
*setbuttonwidthandcaption 
*singleline_assign 
_memberdata XML Metadata for customizable properties
coldcursor
lhideformonminimaze
lhideonclickifactive
lresizebinding
ncurrentline
nextraheight
nextrawidth
nlinecount
nmaxbuttonwidth
nminbuttonwidth
nscrollbarheight
nscrollbarwidth
oimage
otoplevelform
singleline
[END RESERVED3]
[START RESERVED4]
..\bmp\16x16\windows.bmp[END RESERVED4]
[START RESERVED5]
..\bmp\16x16\windows.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
taskbar.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q509W15G
[CLASS] base_container
[CLASSLOC] base_gui.vcx
[BASECLASS] container
[OBJNAME] Cnt_windows
[PARENT] taskbar
[START PROPERTIES]
Height = 22
Left = 5
Name = "Cnt_windows"
Top = 3
Width = 200
ZOrderSet = 1
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q7074B35
[CLASS] optiongroup
[BASECLASS] optiongroup
[OBJNAME] opg_windows
[PARENT] taskbar.Cnt_windows
[START PROPERTIES]
Anchor = 15
BorderStyle = 0
ButtonCount = 0
Height = 22
Left = 0
Name = "opg_windows"
Top = 0
Value = 0
Width = 182
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
WITH THIS.Parent
	THIS.Width = .Width - IIF(.Parent.SingleLine, SYSMETRIC(5), 0)

	THIS.Height = IIF(.Height < TSKB_BTN_HEIGHT, TSKB_BTN_HEIGHT, .Height)
	.Parent.nMaxButtonWidth = TSKB_BTN_MAXWIDTH
	.Parent.nMinButtonWidth = TSKB_BTN_MINWIDTH
ENDWITH
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Q7078NJ6
[CLASS] base_spinner
[CLASSLOC] base_gui.vcx
[BASECLASS] spinner
[OBJNAME] spnactiveline
[PARENT] taskbar.Cnt_windows
[START PROPERTIES]
Anchor = 8
BorderStyle = 0
Height = 22
Increment =  -1.00
KeyboardHighValue = 1
KeyboardLowValue = 1
Left = 183
Name = "spnactiveline"
SpinnerHighValue =   1.00
SpinnerLowValue =   1.00
Top = 0
Visible = .F.
Width = 17
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
THIS.Width = SYSMETRIC(5)
THIS.Height = TSKB_BTN_HEIGHT
THIS.Left = THIS.Parent.Width - THIS.Width
ENDPROC
PROCEDURE InteractiveChange
THIS.Parent.Parent.nCurrentLine = THIS.Value

WITH THIS.Parent.opg_windows
	IF .Top <> -((.Parent.nCurrentLine - 1) * TSKB_BTN_HEIGHT + (.Parent.nCurrentLine - 1))
		.Top = -((.Parent.nCurrentLine - 1) * TSKB_BTN_HEIGHT + (.Parent.nCurrentLine - 1))
	ENDIF

	THIS.ToolTipText = "Line " + TRANSFORM(.Parent.nCurrentLine) + " / " + TRANSFORM(.Parent.nLineCount)
	.ToolTipText = THIS.ToolTipText
	THIS.SelStart = 0
	THIS.SelLength = 1
ENDWITH
ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] taskbar
[START PROPERTIES]
Microsoft Sans Serif, 0, 8, 5, 13, 11, 22, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1QC0DCWHS
[CLASS] custom
[BASECLASS] custom
[OBJNAME] tasklist
[START PROPERTIES]

Name = "tasklist"
Width = 20
_memberdata =      679<VFPData><memberdata name="cusername" type="property" display="cUserName"/><memberdata name="lactive" type="property" display="lActive"/><memberdata name="lstorestatewindows" type="property" display="lStoreStateWindows"/><memberdata name="ctaskdesktoppicture" type="property" display="cTaskDesktopPicture"/><memberdata name="cuserpassword" type="property" display="cUserPassword"/><memberdata name="cdbschema" type="property" display="cDBSchema"/><memberdata name="nidsession" type="property" display="nIdSession"/><memberdata name="cstorepassword" type="property" display="cStorePassword"/><memberdata name="lstorepassword" type="property" display="lStorePassword"/></VFPData>
nidsession = 
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
*!*	Custom::AddObject("Vars", "cstVars")
THIS.AddObject("oVars", "cstVars")
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
_memberdata XML Metadata for customizable properties
nidsession
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] tasklist
[EOF]
